exports.ids = [2];
exports.modules = {

/***/ "./md/blog/2018-04_versioning-features-in-an-angular-app.md":
/*!******************************************************************!*\
  !*** ./md/blog/2018-04_versioning-features-in-an-angular-app.md ***!
  \******************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__[\"default\"] = (\"---\\ntitle: \\\"Versioning features in an angular app\\\"\\nexcerpt: \\\"Versioning components and instantiating the appropriate version dynamically is not only possible but also has some use cases. Check this post where I explain how to accomplish that using a ComponentFactoryResolver and structural directives.\\\"\\npublished: true\\ndatePublished: 1524553200000\\ndate: \\\"2018-04-24T09:00:00.000Z\\\"\\nauthor: Juangui Jordán\\ntags:\\n  - Dan Abramov\\nauthorPhoto: /img/authors/jguix.jpeg\\nbannerPhoto: \\\"/img/blog/2018-04_versioning-features-in-an-angular-app/versioning-features-in-an-angular-app.png\\\"\\nthumbnailPhoto: \\\"/img/blog/2018-04_versioning-features-in-an-angular-app/versioning-features-in-an-angular-app.png\\\"\\ncanonicalUrl: https://juanguijordan.com/blog/2018-04_versioning-features-in-an-angular-app\\n---\\n\\nImagine a scenario where your app needs to show different versions of a component or services to different groups of users.\\nIf it sounds a bit farfetched, take the following scenario that was proposed to our development team in some real project:\\n\\n- The app is downloaded from **Google Play/App Store**, and will be deployed in different countries, using the same app ID.\\n- Different countries have different regulations as to whether the app can display user photographies, specific fields, and so on.\\n  Also, some features should be totally disabled in some countries.\\n- The app will keep growing in functionality, but not necessarily at the same time for all countries:\\n  some countries may decide not to upgrade some feature, or upgrade it later;\\n  some countries may take more time to review if some particular new feature follows their privacy regulations…\\n\\nThe naive approach of having ngIf directives all over the place can work for the simpler cases\\nbut it would be hard to maintain and would also clutter our beautiful templates.\\nAlso, components using different services when switching from one version to another would be very difficult to maintain.\\n\\nSo we came up to the following approach, to cope with all those situations:\\n\\n- Create a directive to show/hide parts of a template depending on the country and version.\\n  That would be like an extension of _ngIf_ with our _country_ and _version_ parameters,\\n  and would give an answer to simple problems like hiding a whole feature in some countries,\\n  or hiding a particular field for some countries/versions.\\n- Create a directive that returns a dynamic component, depending on the _country_ and _version_ parameters.\\n  This directive would be used for more general cases,\\n  where a component version can provide very different functionality from another version.\\n\\nTo illustrate this post, we created an app. Our app proudly shows some country data,\\nlike a country flag, area and population.\\nWe made contact with governments all over the world and kindly asked them to join our non-profit revolutionary app,\\nproviding some basic data:\\n\\n- Country name\\n- Area\\n- Population\\n\\nSome of these countries have really severe regulations and wanted to join the app,\\nbut without revealing their area and population initially,\\nuntil their lawyers would determine if this data could be displayed.\\nSo we designed the first version of the app with a single screen,\\nwhere the user would select the country from a select combo box,\\nand a component with two subcomponents displaying the country data:\\n\\n- A header component for the country name\\n- A content component for the data\\n\\nThe content component should be optional, and will display depending on the country’s regulations.\\n\\n![Design of the first version of the components](/img/blog/2018-04_versioning-features-in-an-angular-app/features_v1.png)\\n\\nThese are some screenshots of the app at this point:\\n\\n![Screenshots of the first version of the app](/img/blog/2018-04_versioning-features-in-an-angular-app/features_v1_screenshots.png)\\n\\nAfter the kick off, some users were so excited that started to ask for some new features:\\n\\n- They wanted to get the country flag displayed in the header\\n- Some more data like country capital and wait for it… the national anthem, of course\\n\\nThe development team agreed that, given that some countries still had not provided their area and population,\\nit was reasonable to think that some of them would not provide instantly their flag, capital and anthem.\\nSo we decided to version the header and content components, so we could give them a smooth path to upgrade their data,\\nwhile still looking good in the app, showing the old components instead of new components with empty fields.\\n\\n![Design of the final version of the components](/img/blog/2018-04_versioning-features-in-an-angular-app/features_v2.png)\\n\\nThese are some screenshots of the final version of the app:\\n\\n![Screenshots of the final version of the app](/img/blog/2018-04_versioning-features-in-an-angular-app/features_v2_screenshots.png)\\n\\nOur app builds on two directives, as we said.\\nThe first one will show/hide an element depending on the feature availability for a certain country,\\nwhere the features will be _COUNTRY_HEADER_ and _COUNTRY_CONTENT_.\\nThis directive will get the feature availability from a service, the so called _CountryConfigService_.\\n\\n```typescript\\nimport {\\n  CountryConfigDictionary,\\n  DEFAULT_COUNTRY_CONFIG,\\n  FeatureVersionDictionary,\\n} from \\\"./country-config.model\\\";\\n\\n@Injectable()\\nexport class CountryConfigService {\\n  private config: CountryConfigDictionary = DEFAULT_COUNTRY_CONFIG;\\n  getCountryFeatures(countryCode: string): FeatureVersionDictionary {\\n    return this.config[countryCode].features;\\n  }\\n\\n  isFeatureEnabled(feature: string, countryCode: string): boolean {\\n    const countryFeatures = this.getCountryFeatures(countryCode);\\n    return countryFeatures.hasOwnProperty(feature);\\n  }\\n\\n  getFeatureVersion(feature: string, countryCode: string): number {\\n    const countryFeatures = this.getCountryFeatures(countryCode);\\n    return countryFeatures[feature];\\n  }\\n}\\n```\\n\\nThe _config_ is an object following a _CountryConfigDictionary_ model\\nthat lets us define which version of the _COUNTRY_HEADER_ and _COUNTRY_CONTENT_ components,\\nif any, is using each country:\\n\\n```typescript\\nexport const DEFAULT_COUNTRY_CONFIG: CountryConfigDictionary = {\\n  es: {\\n    features: {\\n      COUNTRY_HEADER: 2,\\n      COUNTRY_CONTENT: 2,\\n    },\\n  },\\n  fr: {\\n    features: {\\n      COUNTRY_HEADER: 2,\\n      COUNTRY_CONTENT: 2,\\n    },\\n  },\\n  it: {\\n    features: {\\n      COUNTRY_HEADER: 2,\\n      COUNTRY_CONTENT: 1,\\n    },\\n  },\\n  pt: {\\n    features: {\\n      COUNTRY_HEADER: 1,\\n      COUNTRY_CONTENT: 1,\\n    },\\n  },\\n  uk: {\\n    features: {\\n      COUNTRY_HEADER: 1,\\n    },\\n  },\\n};\\n```\\n\\n## The FeatureIf directive\\n\\nWith that in mind, let’s see the _FeatureIf_ directive.\\nIt will display an element if the feature is enabled for the country.\\nOptionally, we can define the minimum version implemented by the country,\\nmeaning that if the country uses a lower version, the element will be hidden.\\nI will skip the standard imports to save space in the listing:\\n\\n```typescript\\nimport { CountryConfigService } from \\\"../../services/country-config/country-config.service\\\";\\n\\n@Directive({\\n  selector: \\\"[appFeatureIf]\\\",\\n})\\nexport class FeatureIfDirective implements OnChanges {\\n  private _featureName: string;\\n  private _countryCode: string;\\n  private _minVersion = 0;\\n  private _else = false;\\n  private _hasView: boolean;\\n\\n  @Input() set appFeatureIf(featureName: string) {\\n    this._featureName = featureName;\\n  }\\n\\n  @Input() set appFeatureIfCountryCode(value: string) {\\n    this._countryCode = value;\\n  }\\n\\n  @Input() set appFeatureIfVersion(value: number) {\\n    this._minVersion = value;\\n  }\\n\\n  @Input() set appFeatureIfElse(value: boolean) {\\n    this._else = value;\\n  }\\n\\n  constructor(\\n    private templateRef: TemplateRef<any>,\\n    private viewContainerRef: ViewContainerRef,\\n    private countryConfigService: CountryConfigService\\n  ) {}\\n\\n  ngOnChanges(changes: SimpleChanges): void {\\n    if (changes) {\\n      this.applyChanges();\\n    }\\n  }\\n\\n  private applyChanges(): void {\\n    const featureEnabled = this.countryConfigService.isFeatureEnabled(\\n      this._featureName,\\n      this._countryCode\\n    );\\n    const featureVersion =\\n      this.countryConfigService.getFeatureVersion(\\n        this._featureName,\\n        this._countryCode\\n      ) || 0;\\n    const enabled: boolean =\\n      featureEnabled && featureVersion >= this._minVersion;\\n    const displayed: boolean =\\n      (enabled && !this._else) || (!enabled && this._else);\\n    this.embedTemplate(displayed);\\n  }\\n\\n  private embedTemplate(enabled): void {\\n    if (enabled && !this._hasView) {\\n      this.viewContainerRef.createEmbeddedView(this.templateRef);\\n      this._hasView = true;\\n    } else if (!enabled && this._hasView) {\\n      this.viewContainerRef.clear();\\n      this._hasView = false;\\n    }\\n  }\\n}\\n```\\n\\nThis structural directive makes use of 4 parameters: _featureName_, _countryCode_, _featureVersion_ and _else_.\\nPay attention on how we define input properties in a structural directive:\\n\\n- The first input takes the name of the very same directive: _appFeatureIf_.\\n  We use a setter to internally save it as _\\\\_featureName_.\\n- The rest of the inputs take the name of the directive plus the name of the parameter.\\n  For instance, the input _appFeatureIfCountryCode_ references the directive parameter _countryCode_.\\n  We also use here a setter to map the input to the private variable _\\\\_countryCode_.\\n\\nPlease remark below how the directive is used in a template.\\nThe first parameter doesn’t need a key, while the rest is passed with _“key: value”_ tuples, separated by a semicolon (;).\\n\\n```html\\n<div *appFeatureIf=\\\"'COUNTRY_HEADER';countryCode:code;version:2\\\">\\n  Show only for countries implementing the COUNTRY_HEADER feature with version\\n  >= 2\\n</div>\\n\\n<div *appFeatureIf=\\\"'COUNTRY_HEADER';countryCode:code;version:2; else:'true'\\\">\\n  Show otherwise\\n</div>\\n```\\n\\nWhat the directive basically does is:\\n\\n- Registers for changes in any of the inputs.\\n- When the directive is instantiated or any of the input changes, executes _applyChanges()_.\\n- Computes if the feature is enabled according to feature _name_, _country code_ and _version_.\\n- Computes if the element has to be displayed.\\n  If the _else_ parameter is defined and true, then it will be displayed if the feature is disabled.\\n- Executes _embedTemplate()_, which creates the embedded view into the view container if the element should be displayed,\\n  or clears the view container otherwise.\\n\\nWe use this directive in two cases in our app.\\nIn the header, we use it to hide the flag for countries implementing _COUNTRY_HEADER_ version 1.\\n\\n```html\\n<div\\n  *appFeatureIf=\\\"'COUNTRY_HEADER';countryCode:country.code;\\n  version:2\\\"\\n  class=\\\"flag {{country.code}}\\\"\\n></div>\\n```\\n\\nIn the parent component, we use the directive with the _else_ parameter set to _true_,\\nto display an informative text when the content component is not available.\\n\\n```html\\n<div\\n  class=\\\"no-feature\\\"\\n  *appFeatureIf=\\\"'COUNTRY_CONTENT';\\n  countryCode:country.code;else:'true'\\\"\\n>\\n  This feature is not yet available in {{country.name}}.\\n</div>\\n```\\n\\n## The FeatureVersion directive\\n\\nOur second directive will allow us to dynamically inject a component or another, depending on some parameters.\\n\\n```typescript\\nimport { CountryConfigService } from \\\"../../services/country-config/country-config.service\\\";\\nimport { DynamicComponentService } from \\\"../../services/dynamic-component/dynamic-component.service\\\";\\nimport { DynamicComponent } from \\\"../../services/dynamic-component/dynamic-component.model\\\";\\n\\n@Directive({\\n  selector: \\\"[appFeatureVersion]\\\",\\n})\\nexport class FeatureVersionDirective implements OnChanges {\\n  private _featureName: string;\\n  private _countryCode: string;\\n  private _data: any;\\n  private componentRef: ComponentRef<DynamicComponent>;\\n\\n  @Input() set appFeatureVersion(featureName: string) {\\n    this._featureName = featureName;\\n  }\\n\\n  @Input()\\n  set appFeatureVersionCountryCode(value: string) {\\n    this._countryCode = value;\\n  }\\n\\n  @Input()\\n  set appFeatureVersionData(value: any) {\\n    this._data = value;\\n  }\\n\\n  constructor(\\n    private viewContainerRef: ViewContainerRef,\\n    private countryConfigService: CountryConfigService,\\n    private dynamicComponentService: DynamicComponentService,\\n    private componentFactoryResolver: ComponentFactoryResolver\\n  ) {}\\n\\n  ngOnChanges(changes: SimpleChanges): void {\\n    if (changes) {\\n      this.applyChanges();\\n    }\\n  }\\n\\n  private applyChanges(): void {\\n    const featureEnabled = this.countryConfigService.isFeatureEnabled(\\n      this._featureName,\\n      this._countryCode\\n    );\\n    const featureVersion =\\n      this.countryConfigService.getFeatureVersion(\\n        this._featureName,\\n        this._countryCode\\n      ) || 0;\\n    const dynamicComponent = this.dynamicComponentService.getComponent(\\n      this._featureName,\\n      featureVersion\\n    );\\n    this.clearViewContainer();\\n    if (featureEnabled && dynamicComponent) {\\n      this.embedComponent(dynamicComponent);\\n      this.injectComponentData();\\n    }\\n  }\\n\\n  private clearViewContainer(): void {\\n    this.viewContainerRef.clear();\\n  }\\n\\n  private embedComponent(component: Type<DynamicComponent>): void {\\n    const componentFactory = this.componentFactoryResolver.resolveComponentFactory(\\n      component\\n    );\\n    this.componentRef = this.viewContainerRef.createComponent(componentFactory);\\n  }\\n\\n  private injectComponentData(): void {\\n    this.componentRef.instance.data = this._data;\\n  }\\n}\\n```\\n\\nThis time, the directive takes three parameters: _featureName_, _countryCode_ and _data_.\\nThe _data_ parameter will be used to pass data to our dynamic component.\\nSince different components may have different inputs,\\nwe took the approach of receiving any external data through this _data_ object.\\nDynamic components may also receive external data through services, as we will see later.\\n\\nSo basically, what this directive does is:\\n\\n- Registers for changes in any of the inputs.\\n- When the directive is instantiated or any of the input changes, executes _applyChanges()_.\\n- Computes if the feature is enabled according to feature name and country code.\\n- Gets the dynamic component type for the feature name and version from the _DynamicComponentService_.\\n- Clears the view container.\\n- If a dynamic component type was retrieved successfully, executes _embedTemplate()_,\\n  which resolves a factory for this type of component and creates the embedded view into the view container.\\n- Finally, it injects the data object into the dynamically instantiated component.\\n\\nLet’s see the code for those _DynamicComponent_ and _DynamicComponentService_ classes.\\n\\nThe _DynamicComponent_ is just a class with a public _data_ property.\\nWe will also create a dictionary interface and a constant with the current dynamic component classes\\n(country content version 1 and 2) that will be used by the service.\\n\\n```typescript\\nimport { CountryContentV1Component } from \\\"../../../country/components/country-content/v1/country-content.v1.component\\\";\\nimport { CountryContentV2Component } from \\\"../../../country/components/country-content/v2/country-content.v2.component\\\";\\n\\nexport class DynamicComponent {\\n  data: any;\\n}\\n\\nexport interface DynamicComponentDictionary {\\n  [key: string]: {\\n    [key: number]: Type<DynamicComponent>;\\n  };\\n}\\n\\nexport const DEFAULT_DYNAMIC_COMPONENT_DICTIONARY: DynamicComponentDictionary = {\\n  COUNTRY_CONTENT: {\\n    1: CountryContentV1Component,\\n    2: CountryContentV2Component,\\n  },\\n};\\n```\\n\\nThe _DynamicComponentService_ simply returns the appropriate component class,\\ndepending on the _featureName_ and _version_ parameters.\\n\\n```typescript\\nimport {\\n  DEFAULT_DYNAMIC_COMPONENT_DICTIONARY,\\n  DynamicComponent,\\n  DynamicComponentDictionary,\\n} from \\\"./dynamic-component.model\\\";\\n\\n@Injectable()\\nexport class DynamicComponentService {\\n  private componentDictionary: DynamicComponentDictionary = DEFAULT_DYNAMIC_COMPONENT_DICTIONARY;\\n\\n  getComponent(featureName: string, version: number): Type<DynamicComponent> {\\n    const selectedComponent = this.componentDictionary[featureName]\\n      ? this.componentDictionary[featureName][version]\\n      : undefined;\\n    return selectedComponent;\\n  }\\n}\\n```\\n\\nLet’s see how this directive is used in the parent component.\\n\\n```html\\n<ng-template\\n  *appFeatureVersion=\\\"'COUNTRY_CONTENT';\\n  countryCode:country.code;data:{country: country}\\\"\\n>\\n</ng-template>\\n```\\n\\nThis is the code for the _CountryContentV1Component_ class.\\n\\n```typescript\\nimport { DynamicComponent } from \\\"../../../../shared/services/dynamic-component/dynamic-component.model\\\";\\nimport { Country } from \\\"../../../services/country.model\\\";\\n\\n@Component({\\n  selector: \\\"app-country-content-v1\\\",\\n  templateUrl: \\\"./country-content.v1.component.html\\\",\\n  styleUrls: [\\\"./country-content.v1.component.scss\\\"],\\n})\\nexport class CountryContentV1Component implements DynamicComponent {\\n  data: { country: Country };\\n}\\n```\\n\\nAnd this is how the template uses the _data_ property to display the country data.\\n\\n```html\\n<div class=\\\"country-content\\\">\\n  <div class=\\\"data-row\\\">\\n    <span class=\\\"data-label\\\"> Area: </span>\\n    <span class=\\\"data-value\\\"> {{data.country.area | number}} </span>\\n  </div>\\n  <div class=\\\"data-row\\\">\\n    <span class=\\\"data-label\\\"> Population: </span>\\n    <span class=\\\"data-value\\\"> {{data.country.population | number}} </span>\\n  </div>\\n</div>\\n```\\n\\nYou can see a demo of the application here:\\n\\nhttps://stackblitz.com/edit/component-version-demo\\n\\n## Versioned services\\n\\nThe situation can get a bit more complicated if services are also versioned.\\nLet’s imagine that the first version of the service providing country data just included the country name,\\narea and population, and that a new version should be created to include the new data,\\nwhile still providing the old version for backward compatibility.\\n\\nIn this case we can inject the corresponding service version in the versioned components.\\nWe won’t be using the _data_ property from _DynamicComponent_, but will get the data from the service instead.\\nWe could also use injection tokens to dynamically inject the versioned service depending on certain conditions.\\n\\nThe following demo is a simple approach using versioned services.\\n\\nhttps://stackblitz.com/edit/component-version-demo-services\\n\\n## Final considerations\\n\\nThe demo app is probably too simple for that kind of solution.\\nWe could still smartly use some _ngIf_ and _ngTemplate_ stuff to get to the same solution.\\nBut think of a case where the user doesn’t select the country from a combo box,\\nbut the country gets auto detected from your device settings,\\nand think of a more complicated UI with a dashboard with several widgets that should be displayed or hidden,\\nor have different content according to the country, and then this approach will make much more sense.\\n\\nThis post is long enough to get into more details.\\nIf you have suggestions to enhance it, please include them in your comments :)\\n\");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9tZC9ibG9nLzIwMTgtMDRfdmVyc2lvbmluZy1mZWF0dXJlcy1pbi1hbi1hbmd1bGFyLWFwcC5tZD84Y2JiIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQWUsa21EQUFtaUQsNG1IQUE0bUgsdUZBQXVGLGlDQUFpQyxzREFBc0QscUVBQXFFLHVFQUF1RSwrQ0FBK0MsS0FBSyx1RUFBdUUsbUVBQW1FLHFEQUFxRCxLQUFLLHVFQUF1RSxtRUFBbUUsc0NBQXNDLEtBQUssR0FBRyw4UkFBOFIsU0FBUyxpQkFBaUIsNERBQTRELE1BQU0sVUFBVSxpQkFBaUIsNERBQTRELE1BQU0sVUFBVSxpQkFBaUIsNERBQTRELE1BQU0sVUFBVSxpQkFBaUIsNERBQTRELE1BQU0sVUFBVSxpQkFBaUIsaUNBQWlDLE1BQU0sS0FBSywwWkFBMFosdUJBQXVCLCtEQUErRCxnQkFBZ0Isb0NBQW9DLHlEQUF5RCxpQ0FBaUMsaUNBQWlDLDRCQUE0QiwwQkFBMEIsOEJBQThCLHNEQUFzRCxzQ0FBc0MsS0FBSywyREFBMkQsZ0NBQWdDLEtBQUssdURBQXVELCtCQUErQixLQUFLLHFEQUFxRCx5QkFBeUIsS0FBSywrS0FBK0ssaURBQWlELG9CQUFvQiw0QkFBNEIsT0FBTyxLQUFLLG9DQUFvQyxtSUFBbUksc0pBQXNKLDJGQUEyRiw2RkFBNkYsb0NBQW9DLEtBQUssNENBQTRDLHNDQUFzQyxtRUFBbUUsNkJBQTZCLE9BQU8sc0NBQXNDLHNDQUFzQyw4QkFBOEIsT0FBTyxLQUFLLEdBQUcsb3lCQUFveUIscURBQXFELGlCQUFpQixzSkFBc0osaUJBQWlCLFVBQVUsNjBCQUE2MEIseUJBQXlCLGtDQUFrQyxjQUFjLHNRQUFzUSw2QkFBNkIsMkRBQTJELGNBQWMsOExBQThMLHVCQUF1QiwrREFBK0QsVUFBVSwwQkFBMEIscUVBQXFFLFVBQVUsbUJBQW1CLG1FQUFtRSxnQkFBZ0IseUNBQXlDLDhEQUE4RCxpQ0FBaUMsaUNBQWlDLHVCQUF1Qix5REFBeUQsMkRBQTJELHNDQUFzQyxLQUFLLG1FQUFtRSxnQ0FBZ0MsS0FBSyx5REFBeUQseUJBQXlCLEtBQUssbVFBQW1RLGlEQUFpRCxvQkFBb0IsNEJBQTRCLE9BQU8sS0FBSyxvQ0FBb0MsbUlBQW1JLHNKQUFzSixpSUFBaUksZ0NBQWdDLCtDQUErQyw4Q0FBOEMsbUNBQW1DLE9BQU8sS0FBSywwQ0FBMEMsb0NBQW9DLEtBQUssdUVBQXVFLDhHQUE4RyxrRkFBa0YsS0FBSywyQ0FBMkMsbURBQW1ELEtBQUssR0FBRyxzNkNBQXM2Qyw0QkFBNEIsc0ZBQXNGLFVBQVUsNEJBQTRCLHNGQUFzRixtQ0FBbUMsY0FBYyxHQUFHLGlEQUFpRCxvQkFBb0IsNENBQTRDLE1BQU0sR0FBRyxxRkFBcUYsc0JBQXNCLDJFQUEyRSxLQUFLLDJLQUEySyxnR0FBZ0csb0NBQW9DLHlEQUF5RCxtR0FBbUcsa0ZBQWtGLGlKQUFpSiwrQkFBK0IsS0FBSyxHQUFHLDBJQUEwSSw2QkFBNkIsTUFBTSxpQkFBaUIsb0hBQW9ILG1CQUFtQixnRkFBZ0YsVUFBVSxVQUFVLDBDQUEwQyxnQkFBZ0IsOEpBQThKLHVFQUF1RSxXQUFXLG9CQUFvQixHQUFHLHNQQUFzUCw0QkFBNEIsdUlBQXVJLGtDQUFrQyw2bERBQTZsRCIsImZpbGUiOiIuL21kL2Jsb2cvMjAxOC0wNF92ZXJzaW9uaW5nLWZlYXR1cmVzLWluLWFuLWFuZ3VsYXItYXBwLm1kLmpzIiwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGRlZmF1bHQgXCItLS1cXG50aXRsZTogXFxcIlZlcnNpb25pbmcgZmVhdHVyZXMgaW4gYW4gYW5ndWxhcsKgYXBwXFxcIlxcbmV4Y2VycHQ6IFxcXCJWZXJzaW9uaW5nIGNvbXBvbmVudHMgYW5kIGluc3RhbnRpYXRpbmcgdGhlIGFwcHJvcHJpYXRlIHZlcnNpb24gZHluYW1pY2FsbHkgaXMgbm90IG9ubHkgcG9zc2libGUgYnV0IGFsc28gaGFzIHNvbWUgdXNlIGNhc2VzLiBDaGVjayB0aGlzIHBvc3Qgd2hlcmUgSSBleHBsYWluIGhvdyB0byBhY2NvbXBsaXNoIHRoYXQgdXNpbmcgYSBDb21wb25lbnRGYWN0b3J5UmVzb2x2ZXIgYW5kIHN0cnVjdHVyYWwgZGlyZWN0aXZlcy5cXFwiXFxucHVibGlzaGVkOiB0cnVlXFxuZGF0ZVB1Ymxpc2hlZDogMTUyNDU1MzIwMDAwMFxcbmRhdGU6IFxcXCIyMDE4LTA0LTI0VDA5OjAwOjAwLjAwMFpcXFwiXFxuYXV0aG9yOiBKdWFuZ3VpIEpvcmTDoW5cXG50YWdzOlxcbiAgLSBEYW4gQWJyYW1vdlxcbmF1dGhvclBob3RvOiAvaW1nL2F1dGhvcnMvamd1aXguanBlZ1xcbmJhbm5lclBob3RvOiBcXFwiL2ltZy9ibG9nLzIwMTgtMDRfdmVyc2lvbmluZy1mZWF0dXJlcy1pbi1hbi1hbmd1bGFyLWFwcC92ZXJzaW9uaW5nLWZlYXR1cmVzLWluLWFuLWFuZ3VsYXItYXBwLnBuZ1xcXCJcXG50aHVtYm5haWxQaG90bzogXFxcIi9pbWcvYmxvZy8yMDE4LTA0X3ZlcnNpb25pbmctZmVhdHVyZXMtaW4tYW4tYW5ndWxhci1hcHAvdmVyc2lvbmluZy1mZWF0dXJlcy1pbi1hbi1hbmd1bGFyLWFwcC5wbmdcXFwiXFxuY2Fub25pY2FsVXJsOiBodHRwczovL2p1YW5ndWlqb3JkYW4uY29tL2Jsb2cvMjAxOC0wNF92ZXJzaW9uaW5nLWZlYXR1cmVzLWluLWFuLWFuZ3VsYXItYXBwXFxuLS0tXFxuXFxuSW1hZ2luZSBhIHNjZW5hcmlvIHdoZXJlIHlvdXIgYXBwIG5lZWRzIHRvIHNob3cgZGlmZmVyZW50IHZlcnNpb25zIG9mIGEgY29tcG9uZW50IG9yIHNlcnZpY2VzIHRvIGRpZmZlcmVudCBncm91cHMgb2YgdXNlcnMuXFxuSWYgaXQgc291bmRzIGEgYml0IGZhcmZldGNoZWQsIHRha2UgdGhlIGZvbGxvd2luZyBzY2VuYXJpbyB0aGF0IHdhcyBwcm9wb3NlZCB0byBvdXIgZGV2ZWxvcG1lbnQgdGVhbSBpbiBzb21lIHJlYWwgcHJvamVjdDpcXG5cXG4tIFRoZSBhcHAgaXMgZG93bmxvYWRlZCBmcm9tICoqR29vZ2xlIFBsYXkvQXBwIFN0b3JlKiosIGFuZCB3aWxsIGJlIGRlcGxveWVkIGluIGRpZmZlcmVudCBjb3VudHJpZXMsIHVzaW5nIHRoZSBzYW1lIGFwcCBJRC5cXG4tIERpZmZlcmVudCBjb3VudHJpZXMgaGF2ZSBkaWZmZXJlbnQgcmVndWxhdGlvbnMgYXMgdG8gd2hldGhlciB0aGUgYXBwIGNhbiBkaXNwbGF5IHVzZXIgcGhvdG9ncmFwaGllcywgc3BlY2lmaWMgZmllbGRzLCBhbmQgc28gb24uXFxuICBBbHNvLCBzb21lIGZlYXR1cmVzIHNob3VsZCBiZSB0b3RhbGx5IGRpc2FibGVkIGluIHNvbWUgY291bnRyaWVzLlxcbi0gVGhlIGFwcCB3aWxsIGtlZXAgZ3Jvd2luZyBpbiBmdW5jdGlvbmFsaXR5LCBidXQgbm90IG5lY2Vzc2FyaWx5IGF0IHRoZSBzYW1lIHRpbWUgZm9yIGFsbCBjb3VudHJpZXM6XFxuICBzb21lIGNvdW50cmllcyBtYXkgZGVjaWRlIG5vdCB0byB1cGdyYWRlIHNvbWUgZmVhdHVyZSwgb3IgdXBncmFkZSBpdCBsYXRlcjtcXG4gIHNvbWUgY291bnRyaWVzIG1heSB0YWtlIG1vcmUgdGltZSB0byByZXZpZXcgaWYgc29tZSBwYXJ0aWN1bGFyIG5ldyBmZWF0dXJlIGZvbGxvd3MgdGhlaXIgcHJpdmFjeSByZWd1bGF0aW9uc+KAplxcblxcblRoZSBuYWl2ZSBhcHByb2FjaCBvZiBoYXZpbmcgbmdJZiBkaXJlY3RpdmVzIGFsbCBvdmVyIHRoZSBwbGFjZSBjYW4gd29yayBmb3IgdGhlIHNpbXBsZXIgY2FzZXNcXG5idXQgaXQgd291bGQgYmUgaGFyZCB0byBtYWludGFpbiBhbmQgd291bGQgYWxzbyBjbHV0dGVyIG91ciBiZWF1dGlmdWwgdGVtcGxhdGVzLlxcbkFsc28sIGNvbXBvbmVudHMgdXNpbmcgZGlmZmVyZW50IHNlcnZpY2VzIHdoZW4gc3dpdGNoaW5nIGZyb20gb25lIHZlcnNpb24gdG8gYW5vdGhlciB3b3VsZCBiZSB2ZXJ5IGRpZmZpY3VsdCB0byBtYWludGFpbi5cXG5cXG5TbyB3ZSBjYW1lIHVwIHRvIHRoZSBmb2xsb3dpbmcgYXBwcm9hY2gsIHRvIGNvcGUgd2l0aCBhbGwgdGhvc2Ugc2l0dWF0aW9uczpcXG5cXG4tIENyZWF0ZSBhIGRpcmVjdGl2ZSB0byBzaG93L2hpZGUgcGFydHMgb2YgYSB0ZW1wbGF0ZSBkZXBlbmRpbmcgb24gdGhlIGNvdW50cnkgYW5kIHZlcnNpb24uXFxuICBUaGF0IHdvdWxkIGJlIGxpa2UgYW4gZXh0ZW5zaW9uIG9mIF9uZ0lmXyB3aXRoIG91ciBfY291bnRyeV8gYW5kIF92ZXJzaW9uXyBwYXJhbWV0ZXJzLFxcbiAgYW5kIHdvdWxkIGdpdmUgYW4gYW5zd2VyIHRvIHNpbXBsZSBwcm9ibGVtcyBsaWtlIGhpZGluZyBhIHdob2xlIGZlYXR1cmUgaW4gc29tZSBjb3VudHJpZXMsXFxuICBvciBoaWRpbmcgYSBwYXJ0aWN1bGFyIGZpZWxkIGZvciBzb21lIGNvdW50cmllcy92ZXJzaW9ucy5cXG4tIENyZWF0ZSBhIGRpcmVjdGl2ZSB0aGF0IHJldHVybnMgYSBkeW5hbWljIGNvbXBvbmVudCwgZGVwZW5kaW5nIG9uIHRoZSBfY291bnRyeV8gYW5kIF92ZXJzaW9uXyBwYXJhbWV0ZXJzLlxcbiAgVGhpcyBkaXJlY3RpdmUgd291bGQgYmUgdXNlZCBmb3IgbW9yZSBnZW5lcmFsIGNhc2VzLFxcbiAgd2hlcmUgYSBjb21wb25lbnQgdmVyc2lvbiBjYW4gcHJvdmlkZSB2ZXJ5IGRpZmZlcmVudCBmdW5jdGlvbmFsaXR5IGZyb20gYW5vdGhlciB2ZXJzaW9uLlxcblxcblRvIGlsbHVzdHJhdGUgdGhpcyBwb3N0LCB3ZSBjcmVhdGVkIGFuIGFwcC4gT3VyIGFwcCBwcm91ZGx5IHNob3dzIHNvbWUgY291bnRyeSBkYXRhLFxcbmxpa2UgYSBjb3VudHJ5IGZsYWcsIGFyZWEgYW5kIHBvcHVsYXRpb24uXFxuV2UgbWFkZSBjb250YWN0IHdpdGggZ292ZXJubWVudHMgYWxsIG92ZXIgdGhlIHdvcmxkIGFuZCBraW5kbHkgYXNrZWQgdGhlbSB0byBqb2luIG91ciBub24tcHJvZml0IHJldm9sdXRpb25hcnkgYXBwLFxcbnByb3ZpZGluZyBzb21lIGJhc2ljIGRhdGE6XFxuXFxuLSBDb3VudHJ5IG5hbWVcXG4tIEFyZWFcXG4tIFBvcHVsYXRpb25cXG5cXG5Tb21lIG9mIHRoZXNlIGNvdW50cmllcyBoYXZlIHJlYWxseSBzZXZlcmUgcmVndWxhdGlvbnMgYW5kIHdhbnRlZCB0byBqb2luIHRoZSBhcHAsXFxuYnV0IHdpdGhvdXQgcmV2ZWFsaW5nIHRoZWlyIGFyZWEgYW5kIHBvcHVsYXRpb24gaW5pdGlhbGx5LFxcbnVudGlsIHRoZWlyIGxhd3llcnMgd291bGQgZGV0ZXJtaW5lIGlmIHRoaXMgZGF0YSBjb3VsZCBiZSBkaXNwbGF5ZWQuXFxuU28gd2UgZGVzaWduZWQgdGhlIGZpcnN0IHZlcnNpb24gb2YgdGhlIGFwcCB3aXRoIGEgc2luZ2xlIHNjcmVlbixcXG53aGVyZSB0aGUgdXNlciB3b3VsZCBzZWxlY3QgdGhlIGNvdW50cnkgZnJvbSBhIHNlbGVjdCBjb21ibyBib3gsXFxuYW5kIGEgY29tcG9uZW50IHdpdGggdHdvIHN1YmNvbXBvbmVudHMgZGlzcGxheWluZyB0aGUgY291bnRyeSBkYXRhOlxcblxcbi0gQSBoZWFkZXIgY29tcG9uZW50IGZvciB0aGUgY291bnRyeSBuYW1lXFxuLSBBIGNvbnRlbnQgY29tcG9uZW50IGZvciB0aGUgZGF0YVxcblxcblRoZSBjb250ZW50IGNvbXBvbmVudCBzaG91bGQgYmUgb3B0aW9uYWwsIGFuZCB3aWxsIGRpc3BsYXkgZGVwZW5kaW5nIG9uIHRoZSBjb3VudHJ54oCZcyByZWd1bGF0aW9ucy5cXG5cXG4hW0Rlc2lnbiBvZiB0aGUgZmlyc3QgdmVyc2lvbiBvZiB0aGUgY29tcG9uZW50c10oL2ltZy9ibG9nLzIwMTgtMDRfdmVyc2lvbmluZy1mZWF0dXJlcy1pbi1hbi1hbmd1bGFyLWFwcC9mZWF0dXJlc192MS5wbmcpXFxuXFxuVGhlc2UgYXJlIHNvbWUgc2NyZWVuc2hvdHMgb2YgdGhlIGFwcCBhdCB0aGlzIHBvaW50OlxcblxcbiFbU2NyZWVuc2hvdHMgb2YgdGhlIGZpcnN0IHZlcnNpb24gb2YgdGhlIGFwcF0oL2ltZy9ibG9nLzIwMTgtMDRfdmVyc2lvbmluZy1mZWF0dXJlcy1pbi1hbi1hbmd1bGFyLWFwcC9mZWF0dXJlc192MV9zY3JlZW5zaG90cy5wbmcpXFxuXFxuQWZ0ZXIgdGhlIGtpY2sgb2ZmLCBzb21lIHVzZXJzIHdlcmUgc28gZXhjaXRlZCB0aGF0IHN0YXJ0ZWQgdG8gYXNrIGZvciBzb21lIG5ldyBmZWF0dXJlczpcXG5cXG4tIFRoZXkgd2FudGVkIHRvIGdldCB0aGUgY291bnRyeSBmbGFnIGRpc3BsYXllZCBpbiB0aGUgaGVhZGVyXFxuLSBTb21lIG1vcmUgZGF0YSBsaWtlIGNvdW50cnkgY2FwaXRhbCBhbmQgd2FpdCBmb3IgaXTigKYgdGhlIG5hdGlvbmFsIGFudGhlbSwgb2YgY291cnNlXFxuXFxuVGhlIGRldmVsb3BtZW50IHRlYW0gYWdyZWVkIHRoYXQsIGdpdmVuIHRoYXQgc29tZSBjb3VudHJpZXMgc3RpbGwgaGFkIG5vdCBwcm92aWRlZCB0aGVpciBhcmVhIGFuZCBwb3B1bGF0aW9uLFxcbml0IHdhcyByZWFzb25hYmxlIHRvIHRoaW5rIHRoYXQgc29tZSBvZiB0aGVtIHdvdWxkIG5vdCBwcm92aWRlIGluc3RhbnRseSB0aGVpciBmbGFnLCBjYXBpdGFsIGFuZCBhbnRoZW0uXFxuU28gd2UgZGVjaWRlZCB0byB2ZXJzaW9uIHRoZSBoZWFkZXIgYW5kIGNvbnRlbnQgY29tcG9uZW50cywgc28gd2UgY291bGQgZ2l2ZSB0aGVtIGEgc21vb3RoIHBhdGggdG8gdXBncmFkZSB0aGVpciBkYXRhLFxcbndoaWxlIHN0aWxsIGxvb2tpbmcgZ29vZCBpbiB0aGUgYXBwLCBzaG93aW5nIHRoZSBvbGQgY29tcG9uZW50cyBpbnN0ZWFkIG9mIG5ldyBjb21wb25lbnRzIHdpdGggZW1wdHkgZmllbGRzLlxcblxcbiFbRGVzaWduIG9mIHRoZSBmaW5hbCB2ZXJzaW9uIG9mIHRoZSBjb21wb25lbnRzXSgvaW1nL2Jsb2cvMjAxOC0wNF92ZXJzaW9uaW5nLWZlYXR1cmVzLWluLWFuLWFuZ3VsYXItYXBwL2ZlYXR1cmVzX3YyLnBuZylcXG5cXG5UaGVzZSBhcmUgc29tZSBzY3JlZW5zaG90cyBvZiB0aGUgZmluYWwgdmVyc2lvbiBvZiB0aGUgYXBwOlxcblxcbiFbU2NyZWVuc2hvdHMgb2YgdGhlIGZpbmFsIHZlcnNpb24gb2YgdGhlIGFwcF0oL2ltZy9ibG9nLzIwMTgtMDRfdmVyc2lvbmluZy1mZWF0dXJlcy1pbi1hbi1hbmd1bGFyLWFwcC9mZWF0dXJlc192Ml9zY3JlZW5zaG90cy5wbmcpXFxuXFxuT3VyIGFwcCBidWlsZHMgb24gdHdvIGRpcmVjdGl2ZXMsIGFzIHdlIHNhaWQuXFxuVGhlIGZpcnN0IG9uZSB3aWxsIHNob3cvaGlkZSBhbiBlbGVtZW50IGRlcGVuZGluZyBvbiB0aGUgZmVhdHVyZSBhdmFpbGFiaWxpdHkgZm9yIGEgY2VydGFpbiBjb3VudHJ5LFxcbndoZXJlIHRoZSBmZWF0dXJlcyB3aWxsIGJlIF9DT1VOVFJZX0hFQURFUl8gYW5kIF9DT1VOVFJZX0NPTlRFTlRfLlxcblRoaXMgZGlyZWN0aXZlIHdpbGwgZ2V0IHRoZSBmZWF0dXJlIGF2YWlsYWJpbGl0eSBmcm9tIGEgc2VydmljZSwgdGhlIHNvIGNhbGxlZCBfQ291bnRyeUNvbmZpZ1NlcnZpY2VfLlxcblxcbmBgYHR5cGVzY3JpcHRcXG5pbXBvcnQge1xcbiAgQ291bnRyeUNvbmZpZ0RpY3Rpb25hcnksXFxuICBERUZBVUxUX0NPVU5UUllfQ09ORklHLFxcbiAgRmVhdHVyZVZlcnNpb25EaWN0aW9uYXJ5LFxcbn0gZnJvbSBcXFwiLi9jb3VudHJ5LWNvbmZpZy5tb2RlbFxcXCI7XFxuXFxuQEluamVjdGFibGUoKVxcbmV4cG9ydCBjbGFzcyBDb3VudHJ5Q29uZmlnU2VydmljZSB7XFxuICBwcml2YXRlIGNvbmZpZzogQ291bnRyeUNvbmZpZ0RpY3Rpb25hcnkgPSBERUZBVUxUX0NPVU5UUllfQ09ORklHO1xcbiAgZ2V0Q291bnRyeUZlYXR1cmVzKGNvdW50cnlDb2RlOiBzdHJpbmcpOiBGZWF0dXJlVmVyc2lvbkRpY3Rpb25hcnkge1xcbiAgICByZXR1cm4gdGhpcy5jb25maWdbY291bnRyeUNvZGVdLmZlYXR1cmVzO1xcbiAgfVxcblxcbiAgaXNGZWF0dXJlRW5hYmxlZChmZWF0dXJlOiBzdHJpbmcsIGNvdW50cnlDb2RlOiBzdHJpbmcpOiBib29sZWFuIHtcXG4gICAgY29uc3QgY291bnRyeUZlYXR1cmVzID0gdGhpcy5nZXRDb3VudHJ5RmVhdHVyZXMoY291bnRyeUNvZGUpO1xcbiAgICByZXR1cm4gY291bnRyeUZlYXR1cmVzLmhhc093blByb3BlcnR5KGZlYXR1cmUpO1xcbiAgfVxcblxcbiAgZ2V0RmVhdHVyZVZlcnNpb24oZmVhdHVyZTogc3RyaW5nLCBjb3VudHJ5Q29kZTogc3RyaW5nKTogbnVtYmVyIHtcXG4gICAgY29uc3QgY291bnRyeUZlYXR1cmVzID0gdGhpcy5nZXRDb3VudHJ5RmVhdHVyZXMoY291bnRyeUNvZGUpO1xcbiAgICByZXR1cm4gY291bnRyeUZlYXR1cmVzW2ZlYXR1cmVdO1xcbiAgfVxcbn1cXG5gYGBcXG5cXG5UaGUgX2NvbmZpZ18gaXMgYW4gb2JqZWN0IGZvbGxvd2luZyBhIF9Db3VudHJ5Q29uZmlnRGljdGlvbmFyeV8gbW9kZWxcXG50aGF0IGxldHMgdXMgZGVmaW5lIHdoaWNoIHZlcnNpb24gb2YgdGhlIF9DT1VOVFJZX0hFQURFUl8gYW5kIF9DT1VOVFJZX0NPTlRFTlRfIGNvbXBvbmVudHMsXFxuaWYgYW55LCBpcyB1c2luZyBlYWNoIGNvdW50cnk6XFxuXFxuYGBgdHlwZXNjcmlwdFxcbmV4cG9ydCBjb25zdCBERUZBVUxUX0NPVU5UUllfQ09ORklHOiBDb3VudHJ5Q29uZmlnRGljdGlvbmFyeSA9IHtcXG4gIGVzOiB7XFxuICAgIGZlYXR1cmVzOiB7XFxuICAgICAgQ09VTlRSWV9IRUFERVI6IDIsXFxuICAgICAgQ09VTlRSWV9DT05URU5UOiAyLFxcbiAgICB9LFxcbiAgfSxcXG4gIGZyOiB7XFxuICAgIGZlYXR1cmVzOiB7XFxuICAgICAgQ09VTlRSWV9IRUFERVI6IDIsXFxuICAgICAgQ09VTlRSWV9DT05URU5UOiAyLFxcbiAgICB9LFxcbiAgfSxcXG4gIGl0OiB7XFxuICAgIGZlYXR1cmVzOiB7XFxuICAgICAgQ09VTlRSWV9IRUFERVI6IDIsXFxuICAgICAgQ09VTlRSWV9DT05URU5UOiAxLFxcbiAgICB9LFxcbiAgfSxcXG4gIHB0OiB7XFxuICAgIGZlYXR1cmVzOiB7XFxuICAgICAgQ09VTlRSWV9IRUFERVI6IDEsXFxuICAgICAgQ09VTlRSWV9DT05URU5UOiAxLFxcbiAgICB9LFxcbiAgfSxcXG4gIHVrOiB7XFxuICAgIGZlYXR1cmVzOiB7XFxuICAgICAgQ09VTlRSWV9IRUFERVI6IDEsXFxuICAgIH0sXFxuICB9LFxcbn07XFxuYGBgXFxuXFxuIyMgVGhlIEZlYXR1cmVJZiBkaXJlY3RpdmVcXG5cXG5XaXRoIHRoYXQgaW4gbWluZCwgbGV04oCZcyBzZWUgdGhlIF9GZWF0dXJlSWZfIGRpcmVjdGl2ZS5cXG5JdCB3aWxsIGRpc3BsYXkgYW4gZWxlbWVudCBpZiB0aGUgZmVhdHVyZSBpcyBlbmFibGVkIGZvciB0aGUgY291bnRyeS5cXG5PcHRpb25hbGx5LCB3ZSBjYW4gZGVmaW5lIHRoZSBtaW5pbXVtIHZlcnNpb24gaW1wbGVtZW50ZWQgYnkgdGhlIGNvdW50cnksXFxubWVhbmluZyB0aGF0IGlmIHRoZSBjb3VudHJ5IHVzZXMgYSBsb3dlciB2ZXJzaW9uLCB0aGUgZWxlbWVudCB3aWxsIGJlIGhpZGRlbi5cXG5JIHdpbGwgc2tpcCB0aGUgc3RhbmRhcmQgaW1wb3J0cyB0byBzYXZlIHNwYWNlIGluIHRoZSBsaXN0aW5nOlxcblxcbmBgYHR5cGVzY3JpcHRcXG5pbXBvcnQgeyBDb3VudHJ5Q29uZmlnU2VydmljZSB9IGZyb20gXFxcIi4uLy4uL3NlcnZpY2VzL2NvdW50cnktY29uZmlnL2NvdW50cnktY29uZmlnLnNlcnZpY2VcXFwiO1xcblxcbkBEaXJlY3RpdmUoe1xcbiAgc2VsZWN0b3I6IFxcXCJbYXBwRmVhdHVyZUlmXVxcXCIsXFxufSlcXG5leHBvcnQgY2xhc3MgRmVhdHVyZUlmRGlyZWN0aXZlIGltcGxlbWVudHMgT25DaGFuZ2VzIHtcXG4gIHByaXZhdGUgX2ZlYXR1cmVOYW1lOiBzdHJpbmc7XFxuICBwcml2YXRlIF9jb3VudHJ5Q29kZTogc3RyaW5nO1xcbiAgcHJpdmF0ZSBfbWluVmVyc2lvbiA9IDA7XFxuICBwcml2YXRlIF9lbHNlID0gZmFsc2U7XFxuICBwcml2YXRlIF9oYXNWaWV3OiBib29sZWFuO1xcblxcbiAgQElucHV0KCkgc2V0IGFwcEZlYXR1cmVJZihmZWF0dXJlTmFtZTogc3RyaW5nKSB7XFxuICAgIHRoaXMuX2ZlYXR1cmVOYW1lID0gZmVhdHVyZU5hbWU7XFxuICB9XFxuXFxuICBASW5wdXQoKSBzZXQgYXBwRmVhdHVyZUlmQ291bnRyeUNvZGUodmFsdWU6IHN0cmluZykge1xcbiAgICB0aGlzLl9jb3VudHJ5Q29kZSA9IHZhbHVlO1xcbiAgfVxcblxcbiAgQElucHV0KCkgc2V0IGFwcEZlYXR1cmVJZlZlcnNpb24odmFsdWU6IG51bWJlcikge1xcbiAgICB0aGlzLl9taW5WZXJzaW9uID0gdmFsdWU7XFxuICB9XFxuXFxuICBASW5wdXQoKSBzZXQgYXBwRmVhdHVyZUlmRWxzZSh2YWx1ZTogYm9vbGVhbikge1xcbiAgICB0aGlzLl9lbHNlID0gdmFsdWU7XFxuICB9XFxuXFxuICBjb25zdHJ1Y3RvcihcXG4gICAgcHJpdmF0ZSB0ZW1wbGF0ZVJlZjogVGVtcGxhdGVSZWY8YW55PixcXG4gICAgcHJpdmF0ZSB2aWV3Q29udGFpbmVyUmVmOiBWaWV3Q29udGFpbmVyUmVmLFxcbiAgICBwcml2YXRlIGNvdW50cnlDb25maWdTZXJ2aWNlOiBDb3VudHJ5Q29uZmlnU2VydmljZVxcbiAgKSB7fVxcblxcbiAgbmdPbkNoYW5nZXMoY2hhbmdlczogU2ltcGxlQ2hhbmdlcyk6IHZvaWQge1xcbiAgICBpZiAoY2hhbmdlcykge1xcbiAgICAgIHRoaXMuYXBwbHlDaGFuZ2VzKCk7XFxuICAgIH1cXG4gIH1cXG5cXG4gIHByaXZhdGUgYXBwbHlDaGFuZ2VzKCk6IHZvaWQge1xcbiAgICBjb25zdCBmZWF0dXJlRW5hYmxlZCA9IHRoaXMuY291bnRyeUNvbmZpZ1NlcnZpY2UuaXNGZWF0dXJlRW5hYmxlZChcXG4gICAgICB0aGlzLl9mZWF0dXJlTmFtZSxcXG4gICAgICB0aGlzLl9jb3VudHJ5Q29kZVxcbiAgICApO1xcbiAgICBjb25zdCBmZWF0dXJlVmVyc2lvbiA9XFxuICAgICAgdGhpcy5jb3VudHJ5Q29uZmlnU2VydmljZS5nZXRGZWF0dXJlVmVyc2lvbihcXG4gICAgICAgIHRoaXMuX2ZlYXR1cmVOYW1lLFxcbiAgICAgICAgdGhpcy5fY291bnRyeUNvZGVcXG4gICAgICApIHx8IDA7XFxuICAgIGNvbnN0IGVuYWJsZWQ6IGJvb2xlYW4gPVxcbiAgICAgIGZlYXR1cmVFbmFibGVkICYmIGZlYXR1cmVWZXJzaW9uID49IHRoaXMuX21pblZlcnNpb247XFxuICAgIGNvbnN0IGRpc3BsYXllZDogYm9vbGVhbiA9XFxuICAgICAgKGVuYWJsZWQgJiYgIXRoaXMuX2Vsc2UpIHx8ICghZW5hYmxlZCAmJiB0aGlzLl9lbHNlKTtcXG4gICAgdGhpcy5lbWJlZFRlbXBsYXRlKGRpc3BsYXllZCk7XFxuICB9XFxuXFxuICBwcml2YXRlIGVtYmVkVGVtcGxhdGUoZW5hYmxlZCk6IHZvaWQge1xcbiAgICBpZiAoZW5hYmxlZCAmJiAhdGhpcy5faGFzVmlldykge1xcbiAgICAgIHRoaXMudmlld0NvbnRhaW5lclJlZi5jcmVhdGVFbWJlZGRlZFZpZXcodGhpcy50ZW1wbGF0ZVJlZik7XFxuICAgICAgdGhpcy5faGFzVmlldyA9IHRydWU7XFxuICAgIH0gZWxzZSBpZiAoIWVuYWJsZWQgJiYgdGhpcy5faGFzVmlldykge1xcbiAgICAgIHRoaXMudmlld0NvbnRhaW5lclJlZi5jbGVhcigpO1xcbiAgICAgIHRoaXMuX2hhc1ZpZXcgPSBmYWxzZTtcXG4gICAgfVxcbiAgfVxcbn1cXG5gYGBcXG5cXG5UaGlzIHN0cnVjdHVyYWwgZGlyZWN0aXZlIG1ha2VzIHVzZSBvZiA0IHBhcmFtZXRlcnM6IF9mZWF0dXJlTmFtZV8sIF9jb3VudHJ5Q29kZV8sIF9mZWF0dXJlVmVyc2lvbl8gYW5kIF9lbHNlXy5cXG5QYXkgYXR0ZW50aW9uIG9uIGhvdyB3ZSBkZWZpbmUgaW5wdXQgcHJvcGVydGllcyBpbiBhIHN0cnVjdHVyYWwgZGlyZWN0aXZlOlxcblxcbi0gVGhlIGZpcnN0IGlucHV0IHRha2VzIHRoZSBuYW1lIG9mIHRoZSB2ZXJ5IHNhbWUgZGlyZWN0aXZlOiBfYXBwRmVhdHVyZUlmXy5cXG4gIFdlIHVzZSBhIHNldHRlciB0byBpbnRlcm5hbGx5IHNhdmUgaXQgYXMgX1xcXFxfZmVhdHVyZU5hbWVfLlxcbi0gVGhlIHJlc3Qgb2YgdGhlIGlucHV0cyB0YWtlIHRoZSBuYW1lIG9mIHRoZSBkaXJlY3RpdmUgcGx1cyB0aGUgbmFtZSBvZiB0aGUgcGFyYW1ldGVyLlxcbiAgRm9yIGluc3RhbmNlLCB0aGUgaW5wdXQgX2FwcEZlYXR1cmVJZkNvdW50cnlDb2RlXyByZWZlcmVuY2VzIHRoZSBkaXJlY3RpdmUgcGFyYW1ldGVyIF9jb3VudHJ5Q29kZV8uXFxuICBXZSBhbHNvIHVzZSBoZXJlIGEgc2V0dGVyIHRvIG1hcCB0aGUgaW5wdXQgdG8gdGhlIHByaXZhdGUgdmFyaWFibGUgX1xcXFxfY291bnRyeUNvZGVfLlxcblxcblBsZWFzZSByZW1hcmsgYmVsb3cgaG93IHRoZSBkaXJlY3RpdmUgaXMgdXNlZCBpbiBhIHRlbXBsYXRlLlxcblRoZSBmaXJzdCBwYXJhbWV0ZXIgZG9lc27igJl0IG5lZWQgYSBrZXksIHdoaWxlIHRoZSByZXN0IGlzIHBhc3NlZCB3aXRoIF/igJxrZXk6IHZhbHVl4oCdXyB0dXBsZXMsIHNlcGFyYXRlZCBieSBhIHNlbWljb2xvbiAoOykuXFxuXFxuYGBgaHRtbFxcbjxkaXYgKmFwcEZlYXR1cmVJZj1cXFwiJ0NPVU5UUllfSEVBREVSJztjb3VudHJ5Q29kZTpjb2RlO3ZlcnNpb246MlxcXCI+XFxuICBTaG93IG9ubHkgZm9yIGNvdW50cmllcyBpbXBsZW1lbnRpbmcgdGhlIENPVU5UUllfSEVBREVSIGZlYXR1cmUgd2l0aCB2ZXJzaW9uXFxuICA+PSAyXFxuPC9kaXY+XFxuXFxuPGRpdiAqYXBwRmVhdHVyZUlmPVxcXCInQ09VTlRSWV9IRUFERVInO2NvdW50cnlDb2RlOmNvZGU7dmVyc2lvbjoyOyBlbHNlOid0cnVlJ1xcXCI+XFxuICBTaG93IG90aGVyd2lzZVxcbjwvZGl2PlxcbmBgYFxcblxcbldoYXQgdGhlIGRpcmVjdGl2ZSBiYXNpY2FsbHkgZG9lcyBpczpcXG5cXG4tIFJlZ2lzdGVycyBmb3IgY2hhbmdlcyBpbiBhbnkgb2YgdGhlIGlucHV0cy5cXG4tIFdoZW4gdGhlIGRpcmVjdGl2ZSBpcyBpbnN0YW50aWF0ZWQgb3IgYW55IG9mIHRoZSBpbnB1dCBjaGFuZ2VzLCBleGVjdXRlcyBfYXBwbHlDaGFuZ2VzKClfLlxcbi0gQ29tcHV0ZXMgaWYgdGhlIGZlYXR1cmUgaXMgZW5hYmxlZCBhY2NvcmRpbmcgdG8gZmVhdHVyZSBfbmFtZV8sIF9jb3VudHJ5IGNvZGVfIGFuZCBfdmVyc2lvbl8uXFxuLSBDb21wdXRlcyBpZiB0aGUgZWxlbWVudCBoYXMgdG8gYmUgZGlzcGxheWVkLlxcbiAgSWYgdGhlIF9lbHNlXyBwYXJhbWV0ZXIgaXMgZGVmaW5lZCBhbmQgdHJ1ZSwgdGhlbiBpdCB3aWxsIGJlIGRpc3BsYXllZCBpZiB0aGUgZmVhdHVyZSBpcyBkaXNhYmxlZC5cXG4tIEV4ZWN1dGVzIF9lbWJlZFRlbXBsYXRlKClfLCB3aGljaCBjcmVhdGVzIHRoZSBlbWJlZGRlZCB2aWV3IGludG8gdGhlIHZpZXcgY29udGFpbmVyIGlmIHRoZSBlbGVtZW50IHNob3VsZCBiZSBkaXNwbGF5ZWQsXFxuICBvciBjbGVhcnMgdGhlIHZpZXcgY29udGFpbmVyIG90aGVyd2lzZS5cXG5cXG5XZSB1c2UgdGhpcyBkaXJlY3RpdmUgaW4gdHdvIGNhc2VzIGluIG91ciBhcHAuXFxuSW4gdGhlIGhlYWRlciwgd2UgdXNlIGl0IHRvIGhpZGUgdGhlIGZsYWcgZm9yIGNvdW50cmllcyBpbXBsZW1lbnRpbmcgX0NPVU5UUllfSEVBREVSXyB2ZXJzaW9uIDEuXFxuXFxuYGBgaHRtbFxcbjxkaXZcXG4gICphcHBGZWF0dXJlSWY9XFxcIidDT1VOVFJZX0hFQURFUic7Y291bnRyeUNvZGU6Y291bnRyeS5jb2RlO1xcbiAgdmVyc2lvbjoyXFxcIlxcbiAgY2xhc3M9XFxcImZsYWcge3tjb3VudHJ5LmNvZGV9fVxcXCJcXG4+PC9kaXY+XFxuYGBgXFxuXFxuSW4gdGhlIHBhcmVudCBjb21wb25lbnQsIHdlIHVzZSB0aGUgZGlyZWN0aXZlIHdpdGggdGhlIF9lbHNlXyBwYXJhbWV0ZXIgc2V0IHRvIF90cnVlXyxcXG50byBkaXNwbGF5IGFuIGluZm9ybWF0aXZlIHRleHQgd2hlbiB0aGUgY29udGVudCBjb21wb25lbnQgaXMgbm90IGF2YWlsYWJsZS5cXG5cXG5gYGBodG1sXFxuPGRpdlxcbiAgY2xhc3M9XFxcIm5vLWZlYXR1cmVcXFwiXFxuICAqYXBwRmVhdHVyZUlmPVxcXCInQ09VTlRSWV9DT05URU5UJztcXG4gIGNvdW50cnlDb2RlOmNvdW50cnkuY29kZTtlbHNlOid0cnVlJ1xcXCJcXG4+XFxuICBUaGlzIGZlYXR1cmUgaXMgbm90IHlldCBhdmFpbGFibGUgaW4ge3tjb3VudHJ5Lm5hbWV9fS5cXG48L2Rpdj5cXG5gYGBcXG5cXG4jIyBUaGUgRmVhdHVyZVZlcnNpb24gZGlyZWN0aXZlXFxuXFxuT3VyIHNlY29uZCBkaXJlY3RpdmUgd2lsbCBhbGxvdyB1cyB0byBkeW5hbWljYWxseSBpbmplY3QgYSBjb21wb25lbnQgb3IgYW5vdGhlciwgZGVwZW5kaW5nIG9uIHNvbWUgcGFyYW1ldGVycy5cXG5cXG5gYGB0eXBlc2NyaXB0XFxuaW1wb3J0IHsgQ291bnRyeUNvbmZpZ1NlcnZpY2UgfSBmcm9tIFxcXCIuLi8uLi9zZXJ2aWNlcy9jb3VudHJ5LWNvbmZpZy9jb3VudHJ5LWNvbmZpZy5zZXJ2aWNlXFxcIjtcXG5pbXBvcnQgeyBEeW5hbWljQ29tcG9uZW50U2VydmljZSB9IGZyb20gXFxcIi4uLy4uL3NlcnZpY2VzL2R5bmFtaWMtY29tcG9uZW50L2R5bmFtaWMtY29tcG9uZW50LnNlcnZpY2VcXFwiO1xcbmltcG9ydCB7IER5bmFtaWNDb21wb25lbnQgfSBmcm9tIFxcXCIuLi8uLi9zZXJ2aWNlcy9keW5hbWljLWNvbXBvbmVudC9keW5hbWljLWNvbXBvbmVudC5tb2RlbFxcXCI7XFxuXFxuQERpcmVjdGl2ZSh7XFxuICBzZWxlY3RvcjogXFxcIlthcHBGZWF0dXJlVmVyc2lvbl1cXFwiLFxcbn0pXFxuZXhwb3J0IGNsYXNzIEZlYXR1cmVWZXJzaW9uRGlyZWN0aXZlIGltcGxlbWVudHMgT25DaGFuZ2VzIHtcXG4gIHByaXZhdGUgX2ZlYXR1cmVOYW1lOiBzdHJpbmc7XFxuICBwcml2YXRlIF9jb3VudHJ5Q29kZTogc3RyaW5nO1xcbiAgcHJpdmF0ZSBfZGF0YTogYW55O1xcbiAgcHJpdmF0ZSBjb21wb25lbnRSZWY6IENvbXBvbmVudFJlZjxEeW5hbWljQ29tcG9uZW50PjtcXG5cXG4gIEBJbnB1dCgpIHNldCBhcHBGZWF0dXJlVmVyc2lvbihmZWF0dXJlTmFtZTogc3RyaW5nKSB7XFxuICAgIHRoaXMuX2ZlYXR1cmVOYW1lID0gZmVhdHVyZU5hbWU7XFxuICB9XFxuXFxuICBASW5wdXQoKVxcbiAgc2V0IGFwcEZlYXR1cmVWZXJzaW9uQ291bnRyeUNvZGUodmFsdWU6IHN0cmluZykge1xcbiAgICB0aGlzLl9jb3VudHJ5Q29kZSA9IHZhbHVlO1xcbiAgfVxcblxcbiAgQElucHV0KClcXG4gIHNldCBhcHBGZWF0dXJlVmVyc2lvbkRhdGEodmFsdWU6IGFueSkge1xcbiAgICB0aGlzLl9kYXRhID0gdmFsdWU7XFxuICB9XFxuXFxuICBjb25zdHJ1Y3RvcihcXG4gICAgcHJpdmF0ZSB2aWV3Q29udGFpbmVyUmVmOiBWaWV3Q29udGFpbmVyUmVmLFxcbiAgICBwcml2YXRlIGNvdW50cnlDb25maWdTZXJ2aWNlOiBDb3VudHJ5Q29uZmlnU2VydmljZSxcXG4gICAgcHJpdmF0ZSBkeW5hbWljQ29tcG9uZW50U2VydmljZTogRHluYW1pY0NvbXBvbmVudFNlcnZpY2UsXFxuICAgIHByaXZhdGUgY29tcG9uZW50RmFjdG9yeVJlc29sdmVyOiBDb21wb25lbnRGYWN0b3J5UmVzb2x2ZXJcXG4gICkge31cXG5cXG4gIG5nT25DaGFuZ2VzKGNoYW5nZXM6IFNpbXBsZUNoYW5nZXMpOiB2b2lkIHtcXG4gICAgaWYgKGNoYW5nZXMpIHtcXG4gICAgICB0aGlzLmFwcGx5Q2hhbmdlcygpO1xcbiAgICB9XFxuICB9XFxuXFxuICBwcml2YXRlIGFwcGx5Q2hhbmdlcygpOiB2b2lkIHtcXG4gICAgY29uc3QgZmVhdHVyZUVuYWJsZWQgPSB0aGlzLmNvdW50cnlDb25maWdTZXJ2aWNlLmlzRmVhdHVyZUVuYWJsZWQoXFxuICAgICAgdGhpcy5fZmVhdHVyZU5hbWUsXFxuICAgICAgdGhpcy5fY291bnRyeUNvZGVcXG4gICAgKTtcXG4gICAgY29uc3QgZmVhdHVyZVZlcnNpb24gPVxcbiAgICAgIHRoaXMuY291bnRyeUNvbmZpZ1NlcnZpY2UuZ2V0RmVhdHVyZVZlcnNpb24oXFxuICAgICAgICB0aGlzLl9mZWF0dXJlTmFtZSxcXG4gICAgICAgIHRoaXMuX2NvdW50cnlDb2RlXFxuICAgICAgKSB8fCAwO1xcbiAgICBjb25zdCBkeW5hbWljQ29tcG9uZW50ID0gdGhpcy5keW5hbWljQ29tcG9uZW50U2VydmljZS5nZXRDb21wb25lbnQoXFxuICAgICAgdGhpcy5fZmVhdHVyZU5hbWUsXFxuICAgICAgZmVhdHVyZVZlcnNpb25cXG4gICAgKTtcXG4gICAgdGhpcy5jbGVhclZpZXdDb250YWluZXIoKTtcXG4gICAgaWYgKGZlYXR1cmVFbmFibGVkICYmIGR5bmFtaWNDb21wb25lbnQpIHtcXG4gICAgICB0aGlzLmVtYmVkQ29tcG9uZW50KGR5bmFtaWNDb21wb25lbnQpO1xcbiAgICAgIHRoaXMuaW5qZWN0Q29tcG9uZW50RGF0YSgpO1xcbiAgICB9XFxuICB9XFxuXFxuICBwcml2YXRlIGNsZWFyVmlld0NvbnRhaW5lcigpOiB2b2lkIHtcXG4gICAgdGhpcy52aWV3Q29udGFpbmVyUmVmLmNsZWFyKCk7XFxuICB9XFxuXFxuICBwcml2YXRlIGVtYmVkQ29tcG9uZW50KGNvbXBvbmVudDogVHlwZTxEeW5hbWljQ29tcG9uZW50Pik6IHZvaWQge1xcbiAgICBjb25zdCBjb21wb25lbnRGYWN0b3J5ID0gdGhpcy5jb21wb25lbnRGYWN0b3J5UmVzb2x2ZXIucmVzb2x2ZUNvbXBvbmVudEZhY3RvcnkoXFxuICAgICAgY29tcG9uZW50XFxuICAgICk7XFxuICAgIHRoaXMuY29tcG9uZW50UmVmID0gdGhpcy52aWV3Q29udGFpbmVyUmVmLmNyZWF0ZUNvbXBvbmVudChjb21wb25lbnRGYWN0b3J5KTtcXG4gIH1cXG5cXG4gIHByaXZhdGUgaW5qZWN0Q29tcG9uZW50RGF0YSgpOiB2b2lkIHtcXG4gICAgdGhpcy5jb21wb25lbnRSZWYuaW5zdGFuY2UuZGF0YSA9IHRoaXMuX2RhdGE7XFxuICB9XFxufVxcbmBgYFxcblxcblRoaXMgdGltZSwgdGhlIGRpcmVjdGl2ZSB0YWtlcyB0aHJlZSBwYXJhbWV0ZXJzOiBfZmVhdHVyZU5hbWVfLCBfY291bnRyeUNvZGVfIGFuZCBfZGF0YV8uXFxuVGhlIF9kYXRhXyBwYXJhbWV0ZXIgd2lsbCBiZSB1c2VkIHRvIHBhc3MgZGF0YSB0byBvdXIgZHluYW1pYyBjb21wb25lbnQuXFxuU2luY2UgZGlmZmVyZW50IGNvbXBvbmVudHMgbWF5IGhhdmUgZGlmZmVyZW50IGlucHV0cyxcXG53ZSB0b29rIHRoZSBhcHByb2FjaCBvZiByZWNlaXZpbmcgYW55IGV4dGVybmFsIGRhdGEgdGhyb3VnaCB0aGlzIF9kYXRhXyBvYmplY3QuXFxuRHluYW1pYyBjb21wb25lbnRzIG1heSBhbHNvIHJlY2VpdmUgZXh0ZXJuYWwgZGF0YSB0aHJvdWdoIHNlcnZpY2VzLCBhcyB3ZSB3aWxsIHNlZSBsYXRlci5cXG5cXG5TbyBiYXNpY2FsbHksIHdoYXQgdGhpcyBkaXJlY3RpdmUgZG9lcyBpczpcXG5cXG4tIFJlZ2lzdGVycyBmb3IgY2hhbmdlcyBpbiBhbnkgb2YgdGhlIGlucHV0cy5cXG4tIFdoZW4gdGhlIGRpcmVjdGl2ZSBpcyBpbnN0YW50aWF0ZWQgb3IgYW55IG9mIHRoZSBpbnB1dCBjaGFuZ2VzLCBleGVjdXRlcyBfYXBwbHlDaGFuZ2VzKClfLlxcbi0gQ29tcHV0ZXMgaWYgdGhlIGZlYXR1cmUgaXMgZW5hYmxlZCBhY2NvcmRpbmcgdG8gZmVhdHVyZSBuYW1lIGFuZCBjb3VudHJ5IGNvZGUuXFxuLSBHZXRzIHRoZSBkeW5hbWljIGNvbXBvbmVudCB0eXBlIGZvciB0aGUgZmVhdHVyZSBuYW1lIGFuZCB2ZXJzaW9uIGZyb20gdGhlIF9EeW5hbWljQ29tcG9uZW50U2VydmljZV8uXFxuLSBDbGVhcnMgdGhlIHZpZXcgY29udGFpbmVyLlxcbi0gSWYgYSBkeW5hbWljIGNvbXBvbmVudCB0eXBlIHdhcyByZXRyaWV2ZWQgc3VjY2Vzc2Z1bGx5LCBleGVjdXRlcyBfZW1iZWRUZW1wbGF0ZSgpXyxcXG4gIHdoaWNoIHJlc29sdmVzIGEgZmFjdG9yeSBmb3IgdGhpcyB0eXBlIG9mIGNvbXBvbmVudCBhbmQgY3JlYXRlcyB0aGUgZW1iZWRkZWQgdmlldyBpbnRvIHRoZSB2aWV3IGNvbnRhaW5lci5cXG4tIEZpbmFsbHksIGl0IGluamVjdHMgdGhlIGRhdGEgb2JqZWN0IGludG8gdGhlIGR5bmFtaWNhbGx5IGluc3RhbnRpYXRlZCBjb21wb25lbnQuXFxuXFxuTGV04oCZcyBzZWUgdGhlIGNvZGUgZm9yIHRob3NlIF9EeW5hbWljQ29tcG9uZW50XyBhbmQgX0R5bmFtaWNDb21wb25lbnRTZXJ2aWNlXyBjbGFzc2VzLlxcblxcblRoZSBfRHluYW1pY0NvbXBvbmVudF8gaXMganVzdCBhIGNsYXNzIHdpdGggYSBwdWJsaWMgX2RhdGFfIHByb3BlcnR5LlxcbldlIHdpbGwgYWxzbyBjcmVhdGUgYSBkaWN0aW9uYXJ5IGludGVyZmFjZSBhbmQgYSBjb25zdGFudCB3aXRoIHRoZSBjdXJyZW50IGR5bmFtaWMgY29tcG9uZW50IGNsYXNzZXNcXG4oY291bnRyeSBjb250ZW50IHZlcnNpb24gMSBhbmQgMikgdGhhdCB3aWxsIGJlIHVzZWQgYnkgdGhlIHNlcnZpY2UuXFxuXFxuYGBgdHlwZXNjcmlwdFxcbmltcG9ydCB7IENvdW50cnlDb250ZW50VjFDb21wb25lbnQgfSBmcm9tIFxcXCIuLi8uLi8uLi9jb3VudHJ5L2NvbXBvbmVudHMvY291bnRyeS1jb250ZW50L3YxL2NvdW50cnktY29udGVudC52MS5jb21wb25lbnRcXFwiO1xcbmltcG9ydCB7IENvdW50cnlDb250ZW50VjJDb21wb25lbnQgfSBmcm9tIFxcXCIuLi8uLi8uLi9jb3VudHJ5L2NvbXBvbmVudHMvY291bnRyeS1jb250ZW50L3YyL2NvdW50cnktY29udGVudC52Mi5jb21wb25lbnRcXFwiO1xcblxcbmV4cG9ydCBjbGFzcyBEeW5hbWljQ29tcG9uZW50IHtcXG4gIGRhdGE6IGFueTtcXG59XFxuXFxuZXhwb3J0IGludGVyZmFjZSBEeW5hbWljQ29tcG9uZW50RGljdGlvbmFyeSB7XFxuICBba2V5OiBzdHJpbmddOiB7XFxuICAgIFtrZXk6IG51bWJlcl06IFR5cGU8RHluYW1pY0NvbXBvbmVudD47XFxuICB9O1xcbn1cXG5cXG5leHBvcnQgY29uc3QgREVGQVVMVF9EWU5BTUlDX0NPTVBPTkVOVF9ESUNUSU9OQVJZOiBEeW5hbWljQ29tcG9uZW50RGljdGlvbmFyeSA9IHtcXG4gIENPVU5UUllfQ09OVEVOVDoge1xcbiAgICAxOiBDb3VudHJ5Q29udGVudFYxQ29tcG9uZW50LFxcbiAgICAyOiBDb3VudHJ5Q29udGVudFYyQ29tcG9uZW50LFxcbiAgfSxcXG59O1xcbmBgYFxcblxcblRoZSBfRHluYW1pY0NvbXBvbmVudFNlcnZpY2VfIHNpbXBseSByZXR1cm5zIHRoZSBhcHByb3ByaWF0ZSBjb21wb25lbnQgY2xhc3MsXFxuZGVwZW5kaW5nIG9uIHRoZSBfZmVhdHVyZU5hbWVfIGFuZCBfdmVyc2lvbl8gcGFyYW1ldGVycy5cXG5cXG5gYGB0eXBlc2NyaXB0XFxuaW1wb3J0IHtcXG4gIERFRkFVTFRfRFlOQU1JQ19DT01QT05FTlRfRElDVElPTkFSWSxcXG4gIER5bmFtaWNDb21wb25lbnQsXFxuICBEeW5hbWljQ29tcG9uZW50RGljdGlvbmFyeSxcXG59IGZyb20gXFxcIi4vZHluYW1pYy1jb21wb25lbnQubW9kZWxcXFwiO1xcblxcbkBJbmplY3RhYmxlKClcXG5leHBvcnQgY2xhc3MgRHluYW1pY0NvbXBvbmVudFNlcnZpY2Uge1xcbiAgcHJpdmF0ZSBjb21wb25lbnREaWN0aW9uYXJ5OiBEeW5hbWljQ29tcG9uZW50RGljdGlvbmFyeSA9IERFRkFVTFRfRFlOQU1JQ19DT01QT05FTlRfRElDVElPTkFSWTtcXG5cXG4gIGdldENvbXBvbmVudChmZWF0dXJlTmFtZTogc3RyaW5nLCB2ZXJzaW9uOiBudW1iZXIpOiBUeXBlPER5bmFtaWNDb21wb25lbnQ+IHtcXG4gICAgY29uc3Qgc2VsZWN0ZWRDb21wb25lbnQgPSB0aGlzLmNvbXBvbmVudERpY3Rpb25hcnlbZmVhdHVyZU5hbWVdXFxuICAgICAgPyB0aGlzLmNvbXBvbmVudERpY3Rpb25hcnlbZmVhdHVyZU5hbWVdW3ZlcnNpb25dXFxuICAgICAgOiB1bmRlZmluZWQ7XFxuICAgIHJldHVybiBzZWxlY3RlZENvbXBvbmVudDtcXG4gIH1cXG59XFxuYGBgXFxuXFxuTGV04oCZcyBzZWUgaG93IHRoaXMgZGlyZWN0aXZlIGlzIHVzZWQgaW4gdGhlIHBhcmVudCBjb21wb25lbnQuXFxuXFxuYGBgaHRtbFxcbjxuZy10ZW1wbGF0ZVxcbiAgKmFwcEZlYXR1cmVWZXJzaW9uPVxcXCInQ09VTlRSWV9DT05URU5UJztcXG4gIGNvdW50cnlDb2RlOmNvdW50cnkuY29kZTtkYXRhOntjb3VudHJ5OiBjb3VudHJ5fVxcXCJcXG4+XFxuPC9uZy10ZW1wbGF0ZT5cXG5gYGBcXG5cXG5UaGlzIGlzIHRoZSBjb2RlIGZvciB0aGUgX0NvdW50cnlDb250ZW50VjFDb21wb25lbnRfIGNsYXNzLlxcblxcbmBgYHR5cGVzY3JpcHRcXG5pbXBvcnQgeyBEeW5hbWljQ29tcG9uZW50IH0gZnJvbSBcXFwiLi4vLi4vLi4vLi4vc2hhcmVkL3NlcnZpY2VzL2R5bmFtaWMtY29tcG9uZW50L2R5bmFtaWMtY29tcG9uZW50Lm1vZGVsXFxcIjtcXG5pbXBvcnQgeyBDb3VudHJ5IH0gZnJvbSBcXFwiLi4vLi4vLi4vc2VydmljZXMvY291bnRyeS5tb2RlbFxcXCI7XFxuXFxuQENvbXBvbmVudCh7XFxuICBzZWxlY3RvcjogXFxcImFwcC1jb3VudHJ5LWNvbnRlbnQtdjFcXFwiLFxcbiAgdGVtcGxhdGVVcmw6IFxcXCIuL2NvdW50cnktY29udGVudC52MS5jb21wb25lbnQuaHRtbFxcXCIsXFxuICBzdHlsZVVybHM6IFtcXFwiLi9jb3VudHJ5LWNvbnRlbnQudjEuY29tcG9uZW50LnNjc3NcXFwiXSxcXG59KVxcbmV4cG9ydCBjbGFzcyBDb3VudHJ5Q29udGVudFYxQ29tcG9uZW50IGltcGxlbWVudHMgRHluYW1pY0NvbXBvbmVudCB7XFxuICBkYXRhOiB7IGNvdW50cnk6IENvdW50cnkgfTtcXG59XFxuYGBgXFxuXFxuQW5kIHRoaXMgaXMgaG93IHRoZSB0ZW1wbGF0ZSB1c2VzIHRoZSBfZGF0YV8gcHJvcGVydHkgdG8gZGlzcGxheSB0aGUgY291bnRyeSBkYXRhLlxcblxcbmBgYGh0bWxcXG48ZGl2IGNsYXNzPVxcXCJjb3VudHJ5LWNvbnRlbnRcXFwiPlxcbiAgPGRpdiBjbGFzcz1cXFwiZGF0YS1yb3dcXFwiPlxcbiAgICA8c3BhbiBjbGFzcz1cXFwiZGF0YS1sYWJlbFxcXCI+IEFyZWE6IDwvc3Bhbj5cXG4gICAgPHNwYW4gY2xhc3M9XFxcImRhdGEtdmFsdWVcXFwiPiB7e2RhdGEuY291bnRyeS5hcmVhIHwgbnVtYmVyfX0gPC9zcGFuPlxcbiAgPC9kaXY+XFxuICA8ZGl2IGNsYXNzPVxcXCJkYXRhLXJvd1xcXCI+XFxuICAgIDxzcGFuIGNsYXNzPVxcXCJkYXRhLWxhYmVsXFxcIj4gUG9wdWxhdGlvbjogPC9zcGFuPlxcbiAgICA8c3BhbiBjbGFzcz1cXFwiZGF0YS12YWx1ZVxcXCI+IHt7ZGF0YS5jb3VudHJ5LnBvcHVsYXRpb24gfCBudW1iZXJ9fSA8L3NwYW4+XFxuICA8L2Rpdj5cXG48L2Rpdj5cXG5gYGBcXG5cXG5Zb3UgY2FuIHNlZSBhIGRlbW8gb2YgdGhlIGFwcGxpY2F0aW9uIGhlcmU6XFxuXFxuaHR0cHM6Ly9zdGFja2JsaXR6LmNvbS9lZGl0L2NvbXBvbmVudC12ZXJzaW9uLWRlbW9cXG5cXG4jIyBWZXJzaW9uZWQgc2VydmljZXNcXG5cXG5UaGUgc2l0dWF0aW9uIGNhbiBnZXQgYSBiaXQgbW9yZSBjb21wbGljYXRlZCBpZiBzZXJ2aWNlcyBhcmUgYWxzbyB2ZXJzaW9uZWQuXFxuTGV04oCZcyBpbWFnaW5lIHRoYXQgdGhlIGZpcnN0IHZlcnNpb24gb2YgdGhlIHNlcnZpY2UgcHJvdmlkaW5nIGNvdW50cnkgZGF0YSBqdXN0IGluY2x1ZGVkIHRoZSBjb3VudHJ5IG5hbWUsXFxuYXJlYSBhbmQgcG9wdWxhdGlvbiwgYW5kIHRoYXQgYSBuZXcgdmVyc2lvbiBzaG91bGQgYmUgY3JlYXRlZCB0byBpbmNsdWRlIHRoZSBuZXcgZGF0YSxcXG53aGlsZSBzdGlsbCBwcm92aWRpbmcgdGhlIG9sZCB2ZXJzaW9uIGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LlxcblxcbkluIHRoaXMgY2FzZSB3ZSBjYW4gaW5qZWN0IHRoZSBjb3JyZXNwb25kaW5nIHNlcnZpY2UgdmVyc2lvbiBpbiB0aGUgdmVyc2lvbmVkIGNvbXBvbmVudHMuXFxuV2Ugd29u4oCZdCBiZSB1c2luZyB0aGUgX2RhdGFfIHByb3BlcnR5IGZyb20gX0R5bmFtaWNDb21wb25lbnRfLCBidXQgd2lsbCBnZXQgdGhlIGRhdGEgZnJvbSB0aGUgc2VydmljZSBpbnN0ZWFkLlxcbldlIGNvdWxkIGFsc28gdXNlIGluamVjdGlvbiB0b2tlbnMgdG8gZHluYW1pY2FsbHkgaW5qZWN0IHRoZSB2ZXJzaW9uZWQgc2VydmljZSBkZXBlbmRpbmcgb24gY2VydGFpbiBjb25kaXRpb25zLlxcblxcblRoZSBmb2xsb3dpbmcgZGVtbyBpcyBhIHNpbXBsZSBhcHByb2FjaCB1c2luZyB2ZXJzaW9uZWQgc2VydmljZXMuXFxuXFxuaHR0cHM6Ly9zdGFja2JsaXR6LmNvbS9lZGl0L2NvbXBvbmVudC12ZXJzaW9uLWRlbW8tc2VydmljZXNcXG5cXG4jIyBGaW5hbCBjb25zaWRlcmF0aW9uc1xcblxcblRoZSBkZW1vIGFwcCBpcyBwcm9iYWJseSB0b28gc2ltcGxlIGZvciB0aGF0IGtpbmQgb2Ygc29sdXRpb24uXFxuV2UgY291bGQgc3RpbGwgc21hcnRseSB1c2Ugc29tZSBfbmdJZl8gYW5kIF9uZ1RlbXBsYXRlXyBzdHVmZiB0byBnZXQgdG8gdGhlIHNhbWUgc29sdXRpb24uXFxuQnV0IHRoaW5rIG9mIGEgY2FzZSB3aGVyZSB0aGUgdXNlciBkb2VzbuKAmXQgc2VsZWN0IHRoZSBjb3VudHJ5IGZyb20gYSBjb21ibyBib3gsXFxuYnV0IHRoZSBjb3VudHJ5IGdldHMgYXV0byBkZXRlY3RlZCBmcm9tIHlvdXIgZGV2aWNlIHNldHRpbmdzLFxcbmFuZCB0aGluayBvZiBhIG1vcmUgY29tcGxpY2F0ZWQgVUkgd2l0aCBhIGRhc2hib2FyZCB3aXRoIHNldmVyYWwgd2lkZ2V0cyB0aGF0IHNob3VsZCBiZSBkaXNwbGF5ZWQgb3IgaGlkZGVuLFxcbm9yIGhhdmUgZGlmZmVyZW50IGNvbnRlbnQgYWNjb3JkaW5nIHRvIHRoZSBjb3VudHJ5LCBhbmQgdGhlbiB0aGlzIGFwcHJvYWNoIHdpbGwgbWFrZSBtdWNoIG1vcmUgc2Vuc2UuXFxuXFxuVGhpcyBwb3N0IGlzIGxvbmcgZW5vdWdoIHRvIGdldCBpbnRvIG1vcmUgZGV0YWlscy5cXG5JZiB5b3UgaGF2ZSBzdWdnZXN0aW9ucyB0byBlbmhhbmNlIGl0LCBwbGVhc2UgaW5jbHVkZSB0aGVtIGluIHlvdXIgY29tbWVudHPCoDopXFxuXCI7Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./md/blog/2018-04_versioning-features-in-an-angular-app.md\n");

/***/ })

};;