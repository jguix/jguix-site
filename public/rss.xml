<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[Juangui Jordán]]></title><description><![CDATA[This is my site where I gather my blog posts and some other random stuff]]></description><link>https://juanguijordan.com</link><image><url>https://juanguijordan.com/icon.png</url><title>Juangui Jordán</title><link>https://juanguijordan.com</link></image><generator>RSS for Node</generator><lastBuildDate>Wed, 17 Mar 2021 00:24:27 GMT</lastBuildDate><atom:link href="https://juanguijordan.com/rss.xml" rel="self" type="application/rss+xml"/><pubDate>Wed, 17 Feb 2021 08:00:00 GMT</pubDate><copyright><![CDATA[2021 Juangui Jordán]]></copyright><language><![CDATA[en]]></language><managingEditor><![CDATA[juangui@gmail.com]]></managingEditor><webMaster><![CDATA[juangui@gmail.com]]></webMaster><ttl>60</ttl><item><title><![CDATA[Usando redux con datos relacionales (2/3)]]></title><description><![CDATA[<h2 id="parte2implementandolastorederedux">Parte 2. Implementando la store de redux</h2>
<p>En esta serie de posts crearemos una aplicación usando <strong>react</strong> y <strong>redux</strong>, en la que manejaremos datos relacionales. En esta segunda parte modelaremos la store.</p>
<p>Al final de la anterior parte de esta serie habíamos modelado la tienda. Consulta la parte 1 si necesitas más contexto sobre ello: <a href="https://blog-es.mimacom.com/redux-normalized-store-part-1/">Usando redux con datos relacionales (1/3)</a>.</p>
<p>Nuestra tienda tendrá dos reducers principales, la store <code>entities</code> y la store <code>ui</code>.</p>
<p>Comencemos por crear la store <code>entities</code>. Tendrá 3 tipos de datos o entidades, a saber:</p>
<ul>
<li>user</li>
<li>comment</li>
<li>post</li>
</ul>
<p>Cada entidad tendrá asociados tipos, acciones y reducers. En aras de una fácil comprensión, mostraré los tipos y acciones en primer lugar.</p>
<p>Tipos de usuario:</p>
<pre><code class="javascript language-javascript">// user.types.ts
export type User = {
  avatar: string,
  email: string,
  id: number,
  name: string,
};
</code></pre>
<p>Las acciones del usuario incluirán una acción para cargar todos los usuarios en la store y una acción para cargar un solo usuario. La primera será llamada potencialmente desde la página <code>My Friends</code>, la segunda desde la página <code>My Wall</code> o la página <code>Friend Wall</code>, donde los posts y los comentarios mostrarán el usuario asociado junto a ellos.</p>
<pre><code class="javascript language-javascript">// user.actions.ts
import { User } from './user.types';

export enum UserActionTypes {
  LOAD_USER = 'USER:LOAD_USER',
  LOAD_USERS = 'USER:LOAD_USERS',
}

export type LoadUserPayload = {
  user: User;
};

export type LoadUserAction = {
  type: UserActionTypes.LOAD_USER;
  payload: LoadUserPayload;
};

const loadUserAction = (payload: LoadUserPayload): LoadUserAction =&gt; {
  return {
    payload,
    type: UserActionTypes.LOAD_USER,
  };
};

export type LoadUsersPayload = {
  users: User[];
};

export type LoadUsersAction = {
  type: UserActionTypes.LOAD_USERS;
  payload: LoadUsersPayload;
};

const loadUsersAction = (payload: LoadUsersPayload): LoadUsersAction =&gt; {
  return {
    payload,
    type: UserActionTypes.LOAD_USERS,
  };
};

export const userActions = {
  loadUserAction,
  loadUsersAction,
};
</code></pre>
<p>De igual manera, tendremos tipos de <code>post</code>, donde cada publicación tiene un <code>userId</code>, que es la forma en que nuestra base de datos administrará la relación de uno a muchos (pero recuerda que haremos que estos datos sean más fáciles de buscar creando un reducer <code>postIdsById</code> dentro del reducer <code>users</code>):</p>
<pre><code class="javascript language-javascript">// post.types.ts
export type Post = {
  body: string,
  date: Date,
  id: number,
  userId: number,
};
</code></pre>
<p>Las acciones de los <code>post</code> solo incluyen una acción para cargar publicaciones por usuario, siendo el <code>userId</code> un parámetro opcional. Enviaremos esta acción con el parámetro <code>userId</code> informado desde la página<code>Friend Wall</code> para obtener todas sus publicaciones. Despacharemos esta acción con el parámetro <code>userId</code> con valor <code>undefined</code> desde <code>My Wall</code> para obtener todas las publicaciones de todos los usuarios (para simplificar, digamos que todos los usuarios son amigos míos).</p>
<pre><code class="javascript language-javascript">// post.actions.ts
import { Post } from './post.types';

export enum PostActionTypes {
  LOAD_POSTS = 'POST:LOAD_POSTS',
}

export type LoadPostsPayload = {
  posts: Post[];
  userId?: number;
};

export type LoadPostsAction = {
  type: PostActionTypes.LOAD_POSTS;
  payload: LoadPostsPayload;
};

const loadPostsAction = (payload: LoadPostsPayload): LoadPostsAction =&gt; {
  return {
    payload,
    type: PostActionTypes.LOAD_POSTS,
  };
};

export const postActions = {
  loadPostsAction,
};
</code></pre>
<p>En cuanto a los tipos de <code>comment</code>, contendrán índices que apuntan al <code>post</code> y el <code>user</code> relacionados:</p>
<pre><code class="javascript language-javascript">// comment.types.ts
export type Comment = {
  body: string,
  date: Date,
  id: number,
  postId: number,
  userId: number,
};
</code></pre>
<p>Las acciones de <code>comment</code> también incluyen solo una acción para cargar comentarios por post:</p>
<pre><code class="javascript language-javascript">// comments.actions
import { Comment } from './comment.types';

export enum CommentActionTypes {
  LOAD_COMMENTS = 'COMMENT:LOAD_COMMENTS',
}

export type LoadCommentsPayload = {
  comments: Comment[];
  postId?: number;
};

export type LoadCommentsAction = {
  type: CommentActionTypes.LOAD_COMMENTS;
  payload: LoadCommentsPayload;
};

const loadCommentsAction = (payload: LoadCommentsPayload): LoadCommentsAction =&gt; {
  return {
    payload,
    type: CommentActionTypes.LOAD_COMMENTS,
  };
};

export const commentActions = {
  loadCommentsAction,
};
</code></pre>
<p>Ahora, abordemos los reducers. En cuanto al reducer <code>user</code>, se creará combinando dos reducers. El primero tomará la acción <code>LoadUsersAction</code> y almacenará un mapa de usuarios por<code>id</code>. También procesará la <code>LoadUserAction</code> y almacenará al usuario en el mapa. El segundo tomará el <code>LoadPostsAction</code> y almacenará un mapa de <code>postIds</code> relacionados con un usuario.</p>
<pre><code class="javascript language-javascript">// user.reducer.ts
import { User } from './user.types';
import { UserActionTypes, LoadUsersAction, LoadUserAction } from './user.actions';
import { NumberIndexed } from '../shared/shared.types';
import { AnyAction, combineReducers, Reducer } from 'redux';
import { LoadPostsAction, PostActionTypes } from '../post/post.actions';

export type UserState = {
  byId: NumberIndexed&lt;User&gt;;
  postIdsById: NumberIndexed&lt;number[]&gt;; // one-to-many relation
};

export type UserStore = {
  users: UserState;
};

export const userByIdReducer = (state: NumberIndexed&lt;User&gt; = {}, action: AnyAction) =&gt; {
  switch (action.type) {
    case UserActionTypes.LOAD_USERS:
      const { payload } = action as LoadUsersAction;
      const { users } = payload;
      const loadedUsersMap = users.reduce((map, user) =&gt; ({ ...map, [user.id]: user }), {});

      return {
        ...state,
        ...loadedUsersMap,
      };

    case UserActionTypes.LOAD_USER:
      const { payload: userPayload } = action as LoadUserAction;
      const { user } = userPayload;

      return {
        ...state,
        [user.id]: user,
      };
  }

  return state;
};

export const postIdsByIdReducer = (state: NumberIndexed&lt;number[]&gt; = {}, action: AnyAction) =&gt; {
  switch (action.type) {
    case PostActionTypes.LOAD_POSTS:
      const { payload } = action as LoadPostsAction;
      const { posts, userId } = payload;
      let loadedPostIdsByUserIdMap = posts.reduce(
        (postIdsByUserIdMap, post) =&gt; ({
          ...postIdsByUserIdMap,
          [post.userId]: postIdsByUserIdMap[post.userId] ? [...postIdsByUserIdMap[post.userId], post.id] : [post.id],
        }),
        {} as NumberIndexed&lt;number[]&gt;
      );
      if (posts.length === 0) {
        loadedPostIdsByUserIdMap = { [userId as number]: [] };
      }

      return {
        ...state,
        ...loadedPostIdsByUserIdMap,
      };
  }

  return state;
};

export const userReducer: Reducer&lt;UserState&gt; = combineReducers({
  byId: userByIdReducer,
  postIdsById: postIdsByIdReducer,
});
</code></pre>
<p>El tipo personalizado <code>NumberIndexed</code> se define de la siguiente manera, en un archivo compartido donde también definimos los tipos para los filtros. Este tipo nos permite tipar mapas con números como índices, utilizados por los reductores anteriores.</p>
<pre><code class="javascript language-javascript">// shared.types.ts
export type NumberIndexed&lt;T&gt; = { [index: number]: T };
export type StringIndexed&lt;T&gt; = { [index: string]: T };
export type OrderType = "asc" | "desc";
</code></pre>
<p>De manera similar, el reducer <code>post</code> tiene un reducer relacionado con la acción<code>LoadPost</code> y un reducer que se encarga de la <code>LoadCommentsAction</code>.</p>
<pre><code class="javascript language-javascript">// post.reducer.ts
import { Post } from './post.types';
import { PostActionTypes, LoadPostsAction } from './post.actions';
import { NumberIndexed } from '../shared/shared.types';
import { AnyAction, combineReducers, Reducer } from 'redux';
import { CommentActionTypes, LoadCommentsAction } from '../comment/comment.actions';

export type PostState = {
  byId: NumberIndexed&lt;Post&gt;;
  commentIdsById: NumberIndexed&lt;number[]&gt;; // one-to-many relation
};

export type PostStore = {
  posts: PostState;
};

export const postByIdReducer = (state: NumberIndexed&lt;Post&gt; = {}, action: AnyAction) =&gt; {
  switch (action.type) {
    case PostActionTypes.LOAD_POSTS:
      const { payload } = action as LoadPostsAction;
      const { posts } = payload;
      const loadedPostsMap = posts.reduce((map, post) =&gt; ({ ...map, [post.id]: post }), {});

      return {
        ...state,
        ...loadedPostsMap,
      };
  }

  return state;
};

export const commentIdsByIdReducer = (state: NumberIndexed&lt;number[]&gt; = {}, action: AnyAction) =&gt; {
  switch (action.type) {
    case CommentActionTypes.LOAD_COMMENTS:
      const { payload } = action as LoadCommentsAction;
      const { comments, postId } = payload;
      let loadedCommentIdsByPostIdMap = comments.reduce(
        (commentIdsByPostIdMap, comment) =&gt; ({
          ...commentIdsByPostIdMap,
          [comment.postId]: commentIdsByPostIdMap[comment.postId]
            ? [...commentIdsByPostIdMap[comment.postId], comment.id]
            : [comment.id],
        }),
        {} as NumberIndexed&lt;number[]&gt;
      );
      if (comments.length === 0) {
        loadedCommentIdsByPostIdMap = { [postId as number]: [] };
      }

      return {
        ...state,
        ...loadedCommentIdsByPostIdMap,
      };
  }

  return state;
};

export const postReducer: Reducer&lt;PostState&gt; = combineReducers({
  byId: postByIdReducer,
  commentIdsById: commentIdsByIdReducer,
});
</code></pre>
<p>El reducer de <code>comment</code> es más simple, encargándose solo de la acción<code>LoadComments</code>.</p>
<pre><code class="javascript language-javascript">// comment.reducer.ts
import { Comment } from './comment.types';
import { CommentActionTypes, LoadCommentsAction } from './comment.actions';
import { NumberIndexed } from '../shared/shared.types';
import { AnyAction, combineReducers, Reducer } from 'redux';

export type CommentState = {
  byId: NumberIndexed&lt;Comment&gt;;
};

export type CommentStore = {
  comments: CommentState;
};

export const commentByIdReducer = (state: NumberIndexed&lt;Comment&gt; = {}, action: AnyAction) =&gt; {
  switch (action.type) {
    case CommentActionTypes.LOAD_COMMENTS:
      const { payload } = action as LoadCommentsAction;
      const { comments } = payload;
      const loadedCommentsMap = comments.reduce((map, comment) =&gt; ({ ...map, [comment.id]: comment }), {});

      return {
        ...state,
        ...loadedCommentsMap,
      };
  }

  return state;
};

export const commentReducer: Reducer&lt;CommentState&gt; = combineReducers({
  byId: commentByIdReducer,
});
</code></pre>
<p>A continuación, implementaremos la store <code>ui</code>. Contendrá los datos de la página <code>My Wall</code>, <code>Friend Wall</code> y <code>Friends</code>.</p>
<p><code>My Wall</code> no contendrá tipos personalizados, solo índices a entidades de <code>post</code> que pertenecen al usuario que se mostrarán en la página. Las acciones incluirán una acción para cargar posts del muro.</p>
<pre><code class="javascript language-javascript">// wall.actions.ts
export enum WallActionTypes {
  LOAD_POSTS = 'WALL:LOAD_POSTS',
}

export type LoadWallPostsPayload = {
  postIds: number[];
};

export type LoadWallPostsAction = {
  type: WallActionTypes.LOAD_POSTS;
  payload: LoadWallPostsPayload;
};

const loadWallPostsAction = (payload: LoadWallPostsPayload): LoadWallPostsAction =&gt; {
  return {
    payload,
    type: WallActionTypes.LOAD_POSTS,
  };
};

export const wallActions = {
  loadWallPostsAction,
};
</code></pre>
<p>El reducer será sencillo, encargándose solo de esa acción.</p>
<pre><code class="javascript language-javascript">// wall.reducer.ts
import { AnyAction, combineReducers, Reducer } from 'redux';
import { LoadWallPostsAction, WallActionTypes } from './wall.actions';

export type WallState = {
  postIds: number[];
};

export type WallStore = {
  wall: WallState;
};

export const postIdsReducer = (state: number[] = [], action: AnyAction) =&gt; {
  switch (action.type) {
    case WallActionTypes.LOAD_POSTS:
      const { payload } = action as LoadWallPostsAction;
      const { postIds } = payload;
      return [...state, ...postIds];
  }

  return state;
};

export const wallReducer: Reducer&lt;WallState&gt; = combineReducers({
  postIds: postIdsReducer,
});
</code></pre>
<p>Omitiremos el código para las acciones y reducers asociados al <code>Friend Wall</code>, que son muy similares a los de <code>My Wall</code>. Puedes consultar la <a href="https://github.com/jguix/redux-normalized-example/tree/blogpost-part2">rama del repositorio de git</a> para este post si deseas ver todo el código fuente.</p>
<p>Las acciones de <code>Friends</code> incluirán cargar amigos y establecer el orden de la lista de amigos (ascendente o descendente).</p>
<pre><code class="javascript language-javascript">// friends.actions.ts
import { OrderType } from '../shared/shared.types';

export enum FriendsActionTypes {
  LOAD_FRIENDS = 'FRIENDS:LOAD_FRIENDS',
  SET_FRIENDS_ORDER = 'FRIENDS:SET_FRIENDS_ORDER',
}

export type LoadFriendsPayload = {
  userIds: number[];
};

export type LoadFriendsAction = {
  type: FriendsActionTypes.LOAD_FRIENDS;
  payload: LoadFriendsPayload;
};

const loadFriendsAction = (payload: LoadFriendsPayload): LoadFriendsAction =&gt; {
  return {
    payload,
    type: FriendsActionTypes.LOAD_FRIENDS,
  };
};

export type SetFriendsOrderPayload = {
  order: OrderType;
};

export type SetFriendsOrderAction = {
  type: FriendsActionTypes.SET_FRIENDS_ORDER;
  payload: SetFriendsOrderPayload;
};

const setFriendsOrderAction = (payload: SetFriendsOrderPayload): SetFriendsOrderAction =&gt; {
  return {
    payload,
    type: FriendsActionTypes.SET_FRIENDS_ORDER,
  };
};

export const friendsActions = {
  loadFriendsAction,
  setFriendsOrderAction,
};
</code></pre>
<p>El reducer <code>friends</code> tendrá reducers que solo apunten a las entidades <code>user</code>. Tendremos uno para la lista con orden ascendente y otro para la lista con orden descendente, porque implementaremos una estrategia de paginación con el backend (de eso hablaremos en la próxima publicación de la serie). Otro reducer almacenará el estado del filtro.</p>
<pre><code class="javascript language-javascript">// friends.reducer.ts
import { AnyAction, combineReducers, Reducer } from 'redux';
import { FriendsActionTypes, LoadFriendsAction, SetFriendsOrderAction } from './friends.actions';

export type FriendsState = {
  orderFilter: 'asc' | 'desc';
  userIds: number[];
};

export type FriendsStore = {
  friends: FriendsState;
};

export const orderFilterReducer = (state: 'asc' | 'desc' = 'asc', action: AnyAction) =&gt; {
  switch (action.type) {
    case FriendsActionTypes.SET_FRIENDS_ORDER:
      const { payload } = action as SetFriendsOrderAction;
      const { order } = payload;
      return order;
  }

  return state;
};

export const userIdsReducer = (state: number[] = [], action: AnyAction) =&gt; {
  switch (action.type) {
    case FriendsActionTypes.LOAD_FRIENDS:
      const { payload } = action as LoadFriendsAction;
      const { userIds } = payload;
      return [...state, ...userIds];

    case FriendsActionTypes.SET_FRIENDS_ORDER:
      return [];
  }

  return state;
};

export const friendsReducer: Reducer&lt;FriendsState&gt; = combineReducers({
  orderFilter: orderFilterReducer,
  userIds: userIdsReducer,
});
</code></pre>
<p>Para crear la store, primero instalaremos la <a href="https://github.com/zalmoxisus/redux-devtools-extension">redux-devtools-extension</a>. Con estas herramientas podremos depurar el despacho de acciones y los cambios en el estado de la store.</p>
<pre><code>yarn add redux-devtools-extension
</code></pre>
<p>La <code>root</code> store se compone de la store <code>entities</code> y la store <code>ui</code> de la siguiente manera:</p>
<pre><code class="javascript language-javascript">// store.ts
import { combineReducers, createStore, Reducer } from "redux";
import { userReducer, UserStore } from "../modules/user/user.reducer";
import {
  commentReducer,
  CommentStore,
} from "../modules/comment/comment.reducer";
import { postReducer, PostStore } from "../modules/post/post.reducer";
import {
  friendsReducer,
  FriendsStore,
} from "../modules/friends/friends.reducer";
import {
  FriendWallStore,
  friendWallReducer,
} from "../modules/friend-wall/friend-wall.reducer";
import { wallReducer, WallStore } from "../modules/wall/wall.reducer";
import { composeWithDevTools } from "redux-devtools-extension";

export type EntitiesStore = CommentStore &amp; PostStore &amp; UserStore;

export type UIStore = FriendsStore &amp; FriendWallStore &amp; WallStore;

export type ApplicationStore = {
  entities: EntitiesStore,
  ui: UIStore,
};

export const entitiesReducer = combineReducers({
  comments: commentReducer,
  posts: postReducer,
  users: userReducer,
});

export const uiReducer = combineReducers({
  friends: friendsReducer,
  friendWall: friendWallReducer,
  wall: wallReducer,
});

export const rootReducer: Reducer&lt;ApplicationStore&gt; = combineReducers({
  entities: entitiesReducer,
  ui: uiReducer,
});

export const store = createStore(rootReducer, composeWithDevTools());
</code></pre>
<p>Finalmente, introduzcamos algunos datos en esta store, enviemos algunas acciones y veamos los resultados. Usaremos algunos datos simulados y mostraremos los resultados usando mensajes <code>console.log</code> e imprimiendo el contenido de la store en la página principal. Alternativamente, puede depurar estas acciones con un complemento de Chrome como <a href="https://chrome.google.com/webstore/detail/redux-devtools/lmhkpmbekcpmknklioeibfkpmmfibljd">Redux DevTools</a>.</p>
<pre><code class="javascript language-javascript">// App.tsx
import React from "react";
import "./App.css";
import { store } from "./store/store";
import { userActions } from "./modules/user/user.actions";
import { User } from "./modules/user/user.types";
import { Post } from "./modules/post/post.types";
import { postActions } from "./modules/post/post.actions";
import { Comment } from "./modules/comment/comment.types";
import { commentActions } from "./modules/comment/comment.actions";
import { friendsActions } from "./modules/friends/friends.actions";
import { wallActions } from "./modules/wall/wall.actions";
import { friendWallActions } from "./modules/friend-wall/friend-wall.actions";

const users: User[] = [
  {
    id: 1,
    name: "Josh Martin",
    email: "josh.martin@gmail.com",
    avatar: "http://placekitten.com/g/500/400",
  },
  {
    id: 2,
    name: "Emily Matthews",
    email: "emily.matthews@gmail.com",
    avatar: "http://placekitten.com/g/400/400",
  },
  {
    id: 3,
    name: "Sonia Lee",
    email: "sonia.lee@gmail.com",
    avatar: "http://placekitten.com/g/400/500",
  },
];
const posts: Post[] = [
  { id: 1, body: "Blah", date: new Date(), userId: 1 },
  { id: 2, body: "Bleh", date: new Date(), userId: 1 },
  { id: 3, body: "Blih", date: new Date(), userId: 2 },
  { id: 4, body: "Bloh", date: new Date(), userId: 2 },
  { id: 5, body: "Bluh", date: new Date(), userId: 3 },
];
const comments: Comment[] = [
  { id: 1, body: "No", date: new Date(), postId: 1, userId: 2 },
  { id: 2, body: "Yes", date: new Date(), postId: 1, userId: 3 },
  { id: 3, body: "Yes!", date: new Date(), postId: 1, userId: 1 },
  { id: 4, body: "No!", date: new Date(), postId: 2, userId: 3 },
];

const App = () =&gt; {
  store.subscribe(() =&gt; {
    console.log("New state", store.getState());
  });

  console.log("Loading users");
  store.dispatch(
    userActions.loadUsersAction({
      users,
    })
  );
  console.log("Loading posts");
  store.dispatch(
    postActions.loadPostsAction({
      posts,
    })
  );
  console.log("Loading comments");
  store.dispatch(
    commentActions.loadCommentsAction({
      comments,
    })
  );
  console.log("Loading friends");
  store.dispatch(
    friendsActions.loadFriendsAction({
      userIds: [2, 3],
    })
  );
  console.log("Loading wall posts");
  store.dispatch(
    wallActions.loadWallPostsAction({
      postIds: [1, 2, 3, 4, 5],
    })
  );
  console.log("Loading Emily's posts");
  store.dispatch(
    friendWallActions.loadFriendWallPostsAction({
      postIds: [3, 4],
      userId: 2,
    })
  );

  return (
    &lt;div className="App"&gt;
      &lt;div&gt;Store contents&lt;/div&gt;
      &lt;div&gt;
        &lt;pre&gt;{JSON.stringify(store.getState(), null, 2)}&lt;/pre&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  );
};

export default App;
</code></pre>
<p>Si ejecutamos la aplicación, podemos seguir en la consola cómo la store despacha acciones y el resultado en la página generada. También podemos seguir los pasos, las actualizaciones parciales y el resultado en la extensión React DevTools.</p>
<p><img src="/img/blog/2021-01_redux-normalized-store-part-2/redux-dev-tools.png" alt="Redux DevTools Extension" /></p>
<p>Si deseas profundizar más en el código, recuerda que puedes consultar todo el código fuente en esta rama:</p>
<p><a href="https://github.com/jguix/redux-normalized-example/tree/blogpost-part2">https://github.com/jguix/redux-normalized-example/tree/blogpost-part2</a></p>
<p>En la próxima publicación implementaremos las páginas y componentes y un backend simulado con paginación. También implementaremos métodos de almacenamiento en caché para evitar pedir los mismos datos una y otra vez.</p>
<h2 id="credits">Credits</h2>
<p>Fotografía por <a href="https://unsplash.com/@sigmund">Sigmund</a> on <a href="https://unsplash.com/">Unsplash</a>.</p>]]></description><link>https://juanguijordan.com/blog/2021-01_redux-normalized-store-part-2</link><guid isPermaLink="true">https://juanguijordan.com/blog/2021-01_redux-normalized-store-part-2</guid><category><![CDATA[javascript]]></category><category><![CDATA[frontend]]></category><dc:creator><![CDATA[Juangui Jordán]]></dc:creator><pubDate>Tue, 26 Jan 2021 08:00:00 GMT</pubDate></item><item><title><![CDATA[Usando redux con datos relacionales (1/3)]]></title><description><![CDATA[<h2 id="parte1modelandolastorederedux">Parte 1. Modelando la store de redux</h2>
<p>En esta serie de posts crearemos una aplicación usando <strong>react</strong> y <strong>redux</strong>, en la que manejaremos datos relacionales. En esta primera parte modelaremos la store.</p>
<p>A menudo, los tutoriales sobre redux son demasiado simples y manejan una estructura de datos plana. Es el caso de la típica app de TODOs (lista de tareas), o una lista de la compra, etc. En estos casos solemos tener unos pocos reducers, los cuales son independientes entre sí.</p>
<p>Por ejemplo:</p>
<ul>
<li>La lista de TODOs, incluyendo el estado de cada tarea.</li>
<li>El valor de un filtro de mostrar/ocultar, por ejemplo, "ocultar completas".</li>
<li>El valor de un filtro de orden, por ejemplo, "ordenar por fecha de creación ascendente".</li>
</ul>
<p>En un caso así de simple, la store no tiene que manejar relaciones, y se puede representar en un objeto similar a este:</p>
<pre><code class="json language-json">{
  "todos": [
    {
      "id": 1,
      "completed": true,
      "creationDate": "2020-08-07",
      "description": "Create github repo"
    },
    {
      "id": 2,
      "completed": false,
      "creationDate": "2020-08-11",
      "description": "Finish part 1 of this post"
    },
    {
      "id": 3,
      "completed": false,
      "creationDate": "2020-08-12",
      "description": "Create part 2"
    }
  ],
  "filterBy": "completed",
  "orderBy": "date-asc"
}
</code></pre>
<p>Sin embargo, las aplicaciones reales suelen ser más complejas. Algunos datos dependen de otros y existen jerarquías: relaciones uno a uno, uno a muchos y muchos a muchos. Esto nos va a presentar varios retos, tanto en la representación del estado en la store, como en la eficiencia de la comunicación con el backend.</p>
<p>Para ilustrarlo, usaremos el ejemplo de una red social. Las entidades principales que manejaremos son usuarios, posts y comentarios. Los usuarios podrán crear posts, y los posts podrán contener comentarios de otros usuarios. Simple, ¿verdad?</p>
<p>Veamos en primer lugar algunos de los diseños de nuestra red social, para modelar estos datos.</p>
<p>La página inicial de nuestra red social será <strong>Mi Muro</strong>, la página donde aparecen mis posts y los de todos mis amigos, con sus respectivos comentarios.</p>
<p><img src="/img/blog/2020-08_redux-normalized-store-part-1/my_wall.png" alt="My Wall" /></p>
<p>También habrá una página de <strong>Amigos</strong>, donde se listan los usuarios que son contactos directos míos.</p>
<p><img src="/img/blog/2020-08_redux-normalized-store-part-1/my_friends.png" alt="My Friends" /></p>
<p>Desde esta página, si pulso sobre uno de mis amigos visitaré el <strong>Muro del amigo</strong>, esto es, una página donde aparecerán sus posts, junto con los comentarios de otros usuarios.</p>
<p><img src="/img/blog/2020-08_redux-normalized-store-part-1/friend.png" alt="Friend Page" /></p>
<p>Cada post incluirá el avatar y nombre del usuario, y la fecha. Cada comentario incluirá también el avatar, nombre del usuario y la fecha.</p>
<p><img src="/img/blog/2020-08_redux-normalized-store-part-1/post_and_comments.png" alt="Posts and comments" /></p>
<p>Sin entrar en las relaciones o jerarquías, podemos definir los tipos de las entidades como usuario (<code>User</code>), post (<code>Post</code>) y comentario (<code>Comment</code>):</p>
<pre><code class="typescript language-typescript">// user.types.ts
export type User = {
  avatar: string;
  email: string;
  id: number;
  name: string;
};

// post.types.ts
export type Post = {
  body: string;
  date: Date;
  id: number;
};

// comment.types.ts
export type Comment = {
  body: string;
  date: Date;
  id: number;
};
</code></pre>
<p>Una representación extremadamente simple, basada en la aplicación de los TODOs, consiste en tener un reducer por cada tipo de entidad:</p>
<pre><code class="json language-json">{
  users: [
    { id: 1, name: "Josh", email: "josh@gmail.com", avatar: "josh.jpg" },
    { id: 2, name: "Anne", email: "anne@gmail.com", avatar: "anne.jpg" },
    { id: 3, name: "Mike", email: "mike@gmail.com", avatar: "mike.jpg" },
  ],
  posts: [
    {
      id: 1,
      body: "hi all",
      date: "2020-08-01",
      user: { id: 2, name: "Anne", email: "anne@gmail.com", avatar: "anne.jpg" },
    }
  ],
  comments: [
    {
      {
        id: 1,
        body: "hello!",
        date: "2020-08-02",
        user: { id: 1, name: "Josh", email: "josh@gmail.com", avatar: "josh.jpg" },
      },
      {
        id: 2,
        body: "hi there!",
        date: "2020-08-02",
        user: { id: 3, name: "Mike", email: "mike@gmail.com", avatar: "mike.jpg" },
      },
    }
  ],
}
</code></pre>
<p>Si entro en la página de <strong>Friends</strong> la store almacena los amigos en <code>users</code>; si entro en la página de un amigo la store almacena los posts en <code>posts</code>, y si muestro un post, los comentarios se almacenan en <code>comments</code>.</p>
<p>Esta estrategia me va a obligar a traerme todos los posts del backend cada vez que cambie al muro de un amigo distinto, y además no va a funcionar porque en las páginas de <strong>Amigo</strong> y <strong>Mi muro</strong> debo mostrar varios posts a la vez, donde cada post tiene distintos comentarios. Según la store diseñada arriba, todos los posts visualizados mostrarían siempre los mismos comentarios.</p>
<p>Para evitar este problema podríamos anidar los comentarios dentro de los posts, así:</p>
<pre><code class="json language-json">{
  users: [
    { id: 1, name: "Josh", email: "josh@gmail.com", avatar: "josh.jpg" },
    { id: 2, name: "Anne", email: "anne@gmail.com", avatar: "anne.jpg" },
    { id: 3, name: "Mike", email: "mike@gmail.com", avatar: "mike.jpg" },
  ],
  posts: [
    {
      id: 1,
      body: "hi all",
      date: "2020-08-01",
      user: { id: 2, name: "Anne", email: "anne@gmail.com", avatar: "anne.jpg" },
      comments: [
        {
          {
            id: 1,
            body: "hello!",
            date: "2020-08-02",
            user: { id: 1, name: "Josh", email: "josh@gmail.com", avatar: "josh.jpg" },
          },
          {
            id: 2,
            body: "hi there!",
            date: "2020-08-02",
            user: { id: 3, name: "Mike", email: "mike@gmail.com", avatar: "mike.jpg" },
          },
        }
      ],
    }
  ],
}
</code></pre>
<p>Sin embargo, todavía tenemos varios problemas. No estamos cacheando datos, por ejemplo, si navego de un amigo a otro y vuelvo al primero, tendré que cargar de nuevo todos los posts y comments del backend. También hay muchos datos replicados, como los usuarios, ocupando más espacio del necesario.</p>
<p>Lo ideal sería normalizar la store, como se recomienda en la <a href="https://redux.js.org/recipes/structuring-reducers/normalizing-state-shape">documentación de redux</a>. Podríamos pensar algo así, donde a cada entidad hemos añadido uno o varios ids (<code>userId</code>, <code>postId</code>) que apuntan a las entidades con las que está relacionada:</p>
<pre><code class="json language-json">{
  users: [
    { id: 1, name: "Josh", email: "josh@gmail.com", avatar: "josh.jpg" },
    { id: 2, name: "Anne", email: "anne@gmail.com", avatar: "anne.jpg" },
    { id: 3, name: "Mike", email: "mike@gmail.com", avatar: "mike.jpg" },
  ],
  posts: [
    {
      id: 1,
      body: "hi all",
      date: "2020-08-01",
      userId: 2,
    }
  ],
  comments: [
    {
      {
        id: 1,
        body: "hello!",
        date: "2020-08-02",
        postId: 1,
        userId: 1,
      },
      {
        id: 2,
        body: "hi there!",
        date: "2020-08-02",
        postId: 1,
        userId: 3,
      },
    }
  ],
}
</code></pre>
<p>De esta forma aplanamos la store y evitamos los datos replicados. Sin embargo, la búsqueda por id del usuario asociado a cada post o comentario, y la búsqueda de todos los comentarios asociados a un post no va a ser nada óptima, ya que nos va a obligar a recorrer todos los usuarios o comentarios y filtrar por id. Cuando la store crezca durante una sesión, este proceso se va a volver más y más lento e impactará a la experiencia de usuario.</p>
<p>Podemos mejorar esto indexando cada dato, como se sugiere en la documentación de redux.</p>
<pre><code class="json language-json">{
  "users": {
    "byId": {
      "1": {
        "id": 1,
        "name": "Josh",
        "email": "josh@gmail.com",
        "avatar": "josh.jpg"
      },
      "2": {
        "id": 2,
        "name": "Anne",
        "email": "anne@gmail.com",
        "avatar": "anne.jpg"
      },
      "3": {
        "id": 3,
        "name": "Mike",
        "email": "mike@gmail.com",
        "avatar": "mike.jpg"
      }
    }
  },
  "posts": {
    "byId": {
      "1": {
        "id": 1,
        "body": "hi all",
        "date": "2020-08-01",
        "userId": 2
      }
    }
  },
  "comments": {
    "byId": {
      "1": {
        "id": 1,
        "body": "hello!",
        "date": "2020-08-02",
        "postId": 1,
        "userId": 1
      },
      "2": {
        "id": 2,
        "body": "hi there!",
        "date": "2020-08-02",
        "postId": 1,
        "userId": 3
      }
    }
  }
}
</code></pre>
<p>Ahora es mucho más sencillo y rápido buscar el <code>user</code> asociado a un <code>post</code> o un <code>comment</code>. Sin embargo, sigue siendo complejo obtener la lista de <code>posts</code> por <code>user</code>, o la lista de <code>comments</code> por <code>post</code>. De hecho, ahora es más difícil e ineficiente filtrar estos datos.</p>
<p>Vamos pues a crear estructuras relacionales que nos indiquen qué posts pertenecen a cada usuario (uno a muchos), y qué comentarios a cada post.</p>
<pre><code class="json language-json">{
  users: {
    byId: {
      1: { id: 1, name: "Josh", email: "josh@gmail.com", avatar: "josh.jpg" },
      2: { id: 2, name: "Anne", email: "anne@gmail.com", avatar: "anne.jpg" },
      3: { id: 3, name: "Mike", email: "mike@gmail.com", avatar: "mike.jpg" },
    },
    postIdsById: {
      2: [ 1 ],
    }
  },
  posts: {
    byId: {
      1: {
        id: 1,
        body: "hi all",
        date: "2020-08-01",
        userId: 2,
      }
    },
    commentIdsById: :{
      1:[ 1, 2],
    }
  },
  comments: {
    byId: {
      1: {
        id: 1,
        body: "hello!",
        date: "2020-08-02",
        postId: 1,
        userId: 1,
      },
      2: {
        id: 2,
        body: "hi there!",
        date: "2020-08-02",
        postId: 1,
        userId: 3,
      },
    }
  },
}
</code></pre>
<p>La lectura del reducer <code>postIdsById</code> sería <em>"el usuario con id 2 tiene el post con id 1"</em>. La lectura de <code>commentIdsById</code> sería <em>"el post con id 1 tiene los comentarios con ids 1 y 2"</em>. Ahora ya tenemos todo indexado y la estructura de base de datos está totalmente normalizada.</p>
<p>Únicamente nos faltan estructuras que nos permitan almacenar los ids de los posts que serán visibles en cada muro, ya sea el del usuario o el de sus amigos, así como los ids de los usuarios que deben aparecer en la página de amigos. Incluiremos en la página de amigos un filtro para ordenar alfabéticamente de forma ascendente o descendente.</p>
<p>Para separar las estructuras que modelan entidades que pertenecen a la base de datos, de las estructuras que modelan elementos de la interfaz de usuario, crearemos 2 reducers de mayor nivel, uno llamado <code>entities</code> donde almacenaremos <strong>entidades de la base de datos</strong>, y otro llamado <code>ui</code> donde almacenaremos todos los <strong>elementos de la interfaz de usuario</strong>.</p>
<p>Este es finalmente el modelo de la store, que evita la replicación de datos, facilita la búsqueda gracias a la indexación, y nos va a permitir cachear los datos ya cargados, ya que las estructuras asociadas a la interfaz de usuario solo almacenan ids, y cualquier entidad ya descargada del backend va a permanecer en la store hasta que borremos la caché del navegador.</p>
<pre><code class="json language-json">{
  entities: {
    users: {
      byId: {
        1: { id: 1, name: "Josh", email: "josh@gmail.com", avatar: "josh.jpg" },
        2: { id: 2, name: "Anne", email: "anne@gmail.com", avatar: "anne.jpg" },
        3: { id: 3, name: "Mike", email: "mike@gmail.com", avatar: "mike.jpg" },
      },
      postIdsById: {
        2: [ 1 ],
      },
    },
    posts: {
      byId: {
        1: {
          id: 1,
          body: "hi all",
          date: "2020-08-01",
          userId: 2,
        },
      },
      commentIdsById: :{
        1: [ 1, 2 ],
      },
    },
    comments: {
      byId: {
        1: {
          id: 1,
          body: "hello!",
          date: "2020-08-02",
          postId: 1,
          userId: 1,
        },
        2: {
          id: 2,
          body: "hi there!",
          date: "2020-08-02",
          postId: 1,
          userId: 3,
        },
      },
    },
  },
  ui: {
    friends: {
      orderFilter: "asc",
      userIds: [ 2, 3 ],
    },
    friendWall: {
      postIdsById: {
        2: [ 1 ],
      },
    },
    wall: {
      postIds: [ 1 ],
    },
  },
}
</code></pre>
<p>En próximos posts veremos la implementación de esta store y los métodos de cacheado.</p>
<h2 id="credits">Credits</h2>
<p>Fotografía por <a href="https://unsplash.com/@jeremybishop">Jeremy Bishop</a> en <a href="https://unsplash.com/">Unsplash</a>.</p>]]></description><link>https://juanguijordan.com/blog/2020-08_redux-normalized-store-part-1</link><guid isPermaLink="true">https://juanguijordan.com/blog/2020-08_redux-normalized-store-part-1</guid><category><![CDATA[javascript]]></category><category><![CDATA[frontend]]></category><dc:creator><![CDATA[Juangui Jordán]]></dc:creator><pubDate>Tue, 03 Nov 2020 08:00:00 GMT</pubDate></item><item><title><![CDATA[Creando una extensión de Chrome]]></title><description><![CDATA[<p>En este post, te mostraré cómo crear una simple <a href="https://chrome.google.com/webstore/category/extensions">Chrome extension</a>. Resumiré lo que una extensión de Chrome puede hacer, y también voy a explicar cómo crear extensiones más complejas basadas en JavaScript, React, Angular o Vue.</p>
<p>¿Qué es una extensión de Chrome? Las extensiones de Google Chrome son como pequeñas aplicaciones que viven en tu navegador, basadas en tecnologías web estándar, como HTML, CSS y JavaScript. Aprovechan algunas API de Chrome, proporcionando las bases para construir una aplicación, como el almacenamiento y la mensajería. Las extensiones de Google Chrome pueden interactuar con las páginas web abiertas en las pestañas de tu navegador, pero en realidad no están pensadas para ello. Pueden "vivir" por sí solas y proporcionar cualquier tipo de funcionalidad, más allá de la experiencia de navegación. Puedes crear cualquier cosa, desde una agenda, pasando por un temporizador pomodoro, hasta un web image scrapper. Puedes pensar en Chrome como la plataforma Electron, proporcionando una base para construir aplicaciones JavaScript que pueden interactuar con la experiencia de navegación.</p>
<p>Las extensiones de Chrome pueden permanecer inactivas hasta que algún trigger las despierte, haciendo que se inyecte algún contenido o script, se ejecute o se muestre algún popup. Estos scripts viven en algo llamado "Mundos Aislados" en relación con las páginas web que se están navegando, lo que significa que una extensión de Chrome sólo puede compartir el DOM con una página en particular, pero no las variables o funciones del script. Por lo tanto, las extensiones de Chrome pueden modificar el DOM, inyectar scripts CSS o JavaScript adicionales que interactúan con el mismo DOM, pero no pueden modificar directamente la página original CSS o JavaScript. Por otro lado, las extensiones pueden comunicarse con la página a través de mensajes, por lo que puede crear una página que interactúe con una extensión de Chrome.</p>
<h2 id="capacidadesdelaextensin">Capacidades de la extensión</h2>
<p>Este es un resumen incompleto de lo que puede hacer una extensión:</p>
<ul>
<li><strong>Mostrar un icono</strong>. El icono de la extensión puede ser modificado en tiempo de ejecución, o mostrar una insignia sobre él, con un fondo de color y un texto de 4 letras en él.</li>
<li><strong>Mostrar un popup</strong>. Al hacer clic en el icono de la extensión se puede activar un popup con contenido.</li>
<li><strong>Mostrar un menú secundario</strong>. Haciendo clic con el botón derecho del ratón en el icono de la extensión puede activar un menú secundario.</li>
<li><strong>Responder a atajos de teclado</strong>. Los atajos de teclado pueden asociarse a las acciones de extensión (CTRL+SHIFT+V).</li>
<li><strong>Responder a acciones de la barra de direcciones</strong> (la así llamada omnibox). Los atajos de texto pueden usarse en la omnibox para activar acciones en la extensión (p.ej. “myext+<TAB>").</li>
<li><strong>Responder a la visita a cierta página web</strong>. Por ejemplo, modificar el estado del icono o el contenido de la ventana emergente
Modifica el contenido de un sitio web. Por ejemplo, modificar el DOM por un script de contenido o aplicar archivos CSS adicionales.</li>
<li><strong>Tener una página de opciones</strong> para la configuración de la extensión.</li>
<li><strong>Reemplazar la página de Historial, Favoritos o Nueva Pestaña</strong> de Google Chrome.</li>
<li><strong>Intercambiar mensajes</strong> con un sitio web o consigo mismo. Una extensión puede utilizar la mensajería para hablar con alguna página web que se esté navegando, o para comunicarse entre partes de la propia extensión.</li>
<li><strong>Almacenar información</strong> en el almacenamiento local, el almacenamiento Chrome (almacenamiento que se sincroniza a través de diferentes dispositivos donde el usuario está conectado) o cualquier almacenamiento nativo de JS, por ejemplo sessionStoragef.</li>
<li><strong>Mostrar notificaciones</strong> como un "toast".</li>
<li><strong>Usar varias APIs proporcionadas por Google Chrome</strong>.</li>
<li><strong>Ser gratis, o de pago</strong>. Al crear una extensión de pago, puedes elegir usar la tienda Chrome o tus propios medios de pago.</li>
</ul>
<h2 id="lobsico">Lo básico</h2>
<p>El único archivo obligatorio de una extensión de Chrome es el manifiesto. Debe estar colocado en el directorio raíz, y comunica los metadatos de la extensión, los permisos y otros archivos involucrados.</p>
<p>El formato del manifiesto tiene un montón de opciones, que se pueden ver en esta página (https://developer.chrome.com/extensions/manifest), pero nos centraremos en los más importantes. Presentemos el manifiesto de la extensión "Cat detector":</p>
<pre><code class="json language-json">{
  "name": "Cat detector",
  "description": "Spots cats in the page you are browsing",
  "manifest_version": 2,
  "version": "1.0",
  "background": {
    "persistent": false,
    "scripts": ["background.js"]
  },
  "content_scripts": [
    {
      "matches": ["&lt;all_urls&gt;"],
      "js": ["content.js"]
    }
  ],
  "browser_action": {
    "default_popup": "popup.html"
  },
  "icons": {
    "16": "images/footprint-16.png",
    "32": "images/footprint-32.png",
    "48": "images/footprint-48.png",
    "128": "images/footprint-128.png"
  },
  "permissions": ["activeTab"]
}
</code></pre>
<p>El manifiesto declara algunas capacidades que serán utilizadas por la extensión:</p>
<ul>
<li>Declara un background script. Los background scripts pueden activarse en cualquier momento, pero no tienen acceso directo al contenido de los tabs.</li>
<li>Declara un content script. Los scripts de contenido se implementan en la misma página en la que se está navegando y tienen acceso al contenido. Una expresión de coincidencia es usada para determinar cuándo el script es inyectado. En este caso elegimos <code>&lt;all urls&gt;</code>, lo que significa que se implementa en cualquier página web.</li>
<li>Declara una acción del navegador, es decir, una extensión que es capaz de funcionar independientemente de la página por la que se está navegando. Si quisiéramos crear una extensión que sólo se activa cuando se cumplen algunas condiciones en la página que se está navegando, utilizaríamos una "page action". La razón por la que elegimos la acción de navegación es que los gatos se pueden ver casi en todas partes en Internet. Una segunda razón es que queremos mostrar un badge sobre el icono de la extensión, y eso sólo es posible usando una acción del navegador.</li>
<li>Dentro de la acción del navegador, declara un popup que se abrirá al hacer clic en el icono de la extensión.</li>
<li>Declara los iconos. Los más pequeños se utilizan para el icono del navegador, dependiendo de la resolución de la pantalla, y los más grandes se usan en el menú de extensiones de Chrome y el Chrome Store.</li>
</ul>
<h2 id="nuestraextensindeejemplo">Nuestra extensión de ejemplo</h2>
<p>Vamos al grano de este post: esta page action utiliza un background script que, al cargar la página, envía un mensaje al content script, que a su vez cuenta el número de veces que las palabras "cat", "kitten" o "kitty" aparecen en nuestra página. Después de recibir una respuesta, la tarea de background muestra un badge sobre el icono para comunicar el número de gatitos que aparecen. Al hacer clic en el icono de la extensión, se mostrará un popup con una imagen de un gatito feliz junto con el contador.</p>
<p>Echemos un vistazo a la estructura de los archivos de extensión:</p>
<pre><code>-audios
 |-meow_0.mp3
 |-meow_1.mp3
 |-meow_2.mp3
 |-meow_3.mp3
 |-meow_4.mp3
 |-meow_5.mp3
 |-meow_6.mp3
-images
 |-footprint-16.png
 |-footprint-32.png
 |-footprint-48.png
 |-footprint-128.png
-background.js
-content.js
-manifest.js
-popup.html
-popup.js
</code></pre>
<p>Incluye los iconos de extensión, algunos archivos de audio, el manifiesto, el background script, el content script y los archivos del popup html y js.</p>
<p>Así queda el background script. Se han incluido comentarios para señalar las cosas importantes:</p>
<pre><code>const maxMeows = 6;

// The extension listens to the onUpdated event, and executes when the page is loaded
chrome.tabs.onUpdated.addListener((tabId, changeInfo, tab) =&gt; {
  if (changeInfo.status === "complete" &amp;&amp; tab.active) {
    detectCats(tabId);
  }
});

// It executes the cat detection as well when we switch tabs on the active tab
chrome.tabs.onActivated.addListener((activeTab) =&gt; detectCats(activeTab.tabId));

const detectCats = (tabId) =&gt; {
  // Here we clear the badge
  chrome.browserAction.setBadgeText({ text: "" });
  // Then we send a message to the content script, together with a callback
  chrome.tabs.sendMessage(tabId, { text: "cat_count" }, onCatCount);
};

// This is the callback called by the content script
const onCatCount = (catNumber) =&gt; {
  if (!catNumber) {
    deactivateIcon();
  } else {
    // When cats are detected, show an animation on the badge
    animateBadge(catNumber);
  }
};

const deactivateIcon = () =&gt; {
  // Here we detect what the active tab is and disable the action
  chrome.tabs.query({ active: true, currentWindow: true }, (activeTab) =&gt; {
    chrome.browserAction.disable(activeTab[0].id);
  });
};

const animateBadge = (catNumber) =&gt; {
  // Limit meows, we don't want 1000 sounds to be played
  let i = catNumber - maxMeows &gt; 0 ? catNumber - maxMeows : 1;
  let j = 0;
  // Cats will meow at random times
  for (; i &lt;= catNumber - 1; i++, j++) {
    updateBadge(i, j * Math.random() * 400);
  }
  // Last cat should come last, let's give it the highest delay
  updateBadge(catNumber, j * 500);
};

const updateBadge = (catIndex, delay) =&gt; {
  // After some specified delay display a number on the badge and play a meow sound
  setTimeout(() =&gt; {
    (
      new Audio(chrome.runtime.getURL(`audios/meow_${catIndex % 7}.mp3`))
    ).play();
    chrome.browserAction.setBadgeText({ text: catIndex.toString() });
  }, delay);
};
</code></pre>
<p>El content script básicamente recibe el mensaje <code>cat_count</code> y responde a él. Se ha incluido algo de lógica para contar los gatos con una expresión regex:</p>
<pre><code>chrome.runtime.onMessage.addListener((msg, sender, sendResponse) =&gt; {
  if (msg.text === "cat_count") {
    sendResponse(countCats());
  }
});

const countCats = () =&gt; {
  var content =
    document.body["innerText" in document.body ? "innerText" : "textContent"];
  content = removeScriptsFromContent(content);
  var regex = /(cat|cats|kitten|kittens|kitty|kitties)[\s.,]/gi;

  return content.match(regex)?.length || 0;
};

const removeScriptsFromContent = (strCode) =&gt; {
  return strCode.replace(/&lt;script.*?&gt;.*?&lt;\/script&gt;/gim, "");
};
</code></pre>
<p>El archivo html del popup simplemente muestra una imagen y declara el fichero javascript:</p>
<pre><code>&lt;html&gt;
  &lt;body&gt;
    &lt;img id="cat_image" /&gt;
    &lt;script src="popup.js"&gt;&lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>El archivo js ejecuta una función en la carga que a su vez envía un mensaje al content script para contar gatos de nuevo. Esto se debe a que los popups no "viven" hasta que se abren, así que si hay que hacer alguna actualización en el popup, es el popup el que debe iniciar la acción:</p>
<pre><code>window.onload = () =&gt; {
  chrome.tabs.query({ active: true, currentWindow: true }, (activeTab) =&gt; {
    const tabId = activeTab[0].id;
    chrome.tabs.sendMessage(tabId, { text: "cat_count" }, onCatCount);
  });
};

const onCatCount = (catNumber) =&gt; {
  document.getElementById(
    "cat_image"
  ).src = `https://cataas.com/c/s/${catNumber}%20happy%20cats%20detected?t=sq&amp;width=350`;
};
</code></pre>
<p>ChanChanChan, este es el resultado de la extensión del detector de gatos en acción:</p>
<p><img src="/img/blog/2020-05_creating-a-chrome-extension/cat_extension.png" alt="Cat extension" /></p>
<h2 id="probandolocalmentenuestraextensin">Probando localmente nuestra extensión</h2>
<p>Si quieres probar tu extensión en tu máquina local, sólo tienes que ir al menu item More Tools —&gt; Extensions, luego hacer click en Load Unpacked, y seleccionar la carpeta donde está tu manifiesto y el resto de los archivos.</p>
<p><img src="/img/blog/2020-05_creating-a-chrome-extension/load_extension.png" alt="Loading the extension for testing" /></p>
<h2 id="debugging">Debugging</h2>
<p>El proceso de debugging se vuelve particularmente compleja ya que cada extensión debe ser inspeccionada de manera diferente.</p>
<p>En cuanto a los background scripts, se inspeccionan en las extensiones. Para abrir las herramientas de desarrollo es necesario hacer clic en el enlace "página en segundo plano" en los detalles de la extensión.</p>
<p><img src="/img/blog/2020-05_creating-a-chrome-extension/extension_info.png" alt="Opening the extension dev tools" /></p>
<p>Los content scripts se inspeccionan en la página web que estás navegando, ya que se inyectan en la página. Se muestran en una pestaña de <strong>Content Scripts</strong>.</p>
<p><img src="/img/blog/2020-05_creating-a-chrome-extension/debugging_content_scripts.png" alt="Debugging content scripts" /></p>
<p>No pude encontrar la forma de inspeccionar los popup scripts, incluso los logs de la consola se perdían en algún lugar, así que mostrar una alerta fue la única forma de comprobar que el popup estaba "vivo" y activo.</p>
<h2 id="publicandolaextensin">Publicando la extensión</h2>
<p>Para publicar una extensión de Google Chrome es necesario registrarse como desarrollador de Chrome, pagar 5 dólares y rellenar algunos datos sobre el nombre de la extensión, la descripción y las imágenes o vídeos. El proceso es muy similar al que se sigue para publicar una aplicación en Google Play. Después de enviar tu extensión para la aprobación, tienes que esperar una respuesta. Las respuestas negativas son bastante rápidas -mi primera extensión fue rechazada sin razón alguna, y tuve que enviar un correo electrónico para pedir una revisión humana-, las positivas pueden tardar unas horas o días.</p>
<h2 id="irmsall">Ir más allá…</h2>
<p>El sitio de desarrollo de Chrome para extensiones proporciona un gran número de extensiones de muestra. Estas son extensiones simples que abordan características muy específicas que pueden ayudar a aprender a construir extensiones.</p>
<p>https://developer.chrome.com/extensions/samples</p>
<p>Hay muchos proyectos de boilerplate por ahí para ayudarte a desarrollar extensiones más complejas usando React, Angular o Vue. Toma los siguientes enlaces como punto de partida:</p>
<ul>
<li>https://github.com/lxieyang/chrome-extension-boilerplate-react</li>
<li>https://github.com/larscom/ng-chrome-extension</li>
<li>https://github.com/Kocal/vue-web-extension</li>
</ul>
<h2 id="recap">Recap</h2>
<p>Crear extensiones de Chrome puede ser divertido, y también puedes encontrar muchos escenarios productivos para ellas. Desarrollar extensiones es fácil si conoces las tecnologías web básicas como HTML, CSS y JavaScript. Te mostramos los fundamentos de una extensión de Chrome y te guiamos en la creación de una simple extensión.</p>
<p>Si quiere comprobar el código de extensión completo, ¡échale un vistazo! <a href="https://github.com/jguix/chrome-cat-detector">github repository</a>.</p>
<p>¿Puedes imaginarte algo que pueda ser entregado como una extensión de Chrome? Compártenos tu idea…</p>
<h2 id="crdits">Crédits</h2>
<p>Fotografía de Markus Winkler en <a href="https://unsplash.com/">Unsplash</a>.</p>]]></description><link>https://juanguijordan.com/blog/2020-05_creating-a-chrome-extension</link><guid isPermaLink="true">https://juanguijordan.com/blog/2020-05_creating-a-chrome-extension</guid><category><![CDATA[javascript]]></category><dc:creator><![CDATA[Juangui Jordán]]></dc:creator><pubDate>Mon, 01 Jun 2020 07:00:00 GMT</pubDate></item><item><title><![CDATA[Circular Design SPRINT]]></title><description><![CDATA[<p>En este post os cuento la experiencia de participar en un&nbsp;<strong>Design Sprint</strong>, y cómo Ecoembes utilizó la metodología Design Sprint para explorar nuevas ideas en el contexto de la economía circular y el reciclaje.</p>
<p>Para ello, reclutó mediante becas a un ecléctico grupo de profesionales, incluyendo emprendedores, profesionales del marketing, diseño, y tecnología, entre los que me encuentro. Durante 5 días en Julio de 2018, trabajamos conjuntamente en&nbsp;<a href="https://www.thecircularlab.com">The Circular Lab</a>, un espacio de innovación de Ecoembes localizado en Logroño, particularmente preparado para el trabajo creativo y colaborativo.</p>
<p><img src="/img/blog/2019-05_circular-design-sprint/the_circular_lab_1-1-1024x668.jpg" alt="The Circular Lab" /></p>
<p>La beca consistió en un curso sobre la metodología Design Sprint, durante el cual realizamos un&nbsp;<strong>SPRINT</strong>&nbsp;real para Ecoembes. Tutorizados por&nbsp;<a href="https://www.uxerschool.com">UXER School</a>, aplicamos Design Sprint al mundo del reciclaje, y en solo 5 días fuimos capaces de proponer y desarrollar ideas innovadoras que resuelven problemas en un negocio que inicialmente no conocíamos.</p>
<h2 id="resumenejecutivo">Resumen ejecutivo</h2>
<p>Este será un largo artículo, por lo cual he decidido crear un resumen para que el lector pueda entender la idea global, y ya decidir si quiere adentrarse en todos los detalles.</p>
<p><a href="https://www.gv.com/sprint"><strong>Design SPRINT</strong></a>&nbsp;–o SPRINT, a secas– es una metodología sorprendentemente productiva, que permite obtener excelentes resultados en un breve período de tiempo.</p>
<p>Se puede aplicar al desarrollo de un producto o servicio al inicio de un proyecto, pero también al desarrollo de una funcionalidad de un producto o servicio ya existente, o a la mejora de cualquier proceso. Es una metodología flexible que se ha aplicado con éxito en multitud de ámbitos.</p>
<p>Se fomenta la producción individual y la toma de decisiones colectiva. Esto hace que, por un lado, la generación de ideas sea más abierta. En el momento de pensar y producir lo hacemos en general de forma individual, con lo cual no recibimos feedback negativo que nos cohiba o nos limite. Por otro lado, la toma de decisiones es colectiva, usando una jerarquía plana, lo cual nos hace partícipes incluso de ideas que no hemos generado nosotros mismos, pero con las que nos sentimos de acuerdo.</p>
<p>En mi opinión, el éxito del proceso viene determinado por varios factores. En primer lugar, es importante conformar un equipo multidisciplinar, lo cual nos va a aportar diferentes puntos de vista en la generación de ideas. Otro aspecto importante de la metodología son los plazos cortos: la mayoría de tareas tienen un plazo muy limitado, de 5, 10 o 15 minutos, lo cual nos hace trabajar bajo presión, obligando a escoger y descartar rápidamente ideas.</p>
<p><img src="/img/blog/2019-05_circular-design-sprint/dia1-reloj.jpg" alt="The famous Time Timer helps keep activities in term" /></p>
<p>Otro aspecto importante es dejar los egos a un lado, prescindir de los superhéroes –centrarse en el trabajo colectivo en lugar de dar todo el protagonismo a los gurús o expertos– y ser capaz de renunciar a tus propias ideas –cuando el equipo decide que una idea no se va a utilizar, no debemos presionar para volver a incluirla. Para conducir el proceso, marcar las pautas, favorecer que prevalezca el espíritu colectivo y desatascar los bloqueos existe la figura del facilitador. En este caso el facilitador era Javier Larrea de UXER SCHOOL.</p>
<p>Visto en retrospectiva, el proceso se siente como un puzzle inicialmente desordenado, en el que poco a poco van encajando las piezas, de forma casi automática.</p>
<p>Por último, aclarar que&nbsp;<strong>Design Sprint</strong>&nbsp;es una metodología adaptable a cada proyecto y organización, por tanto algunos procesos realizados pueden diferir de lo que encontramos en el&nbsp;<a href="https://www.gv.com/sprint/#book">libro oficial</a>&nbsp;o lo que hayamos encontrado en otros sprints.</p>
<h2 id="designsprintdeunvistazo">Design Sprint de un vistazo</h2>
<p>Design Sprint es una metodología que se desarrolla típicamente a lo largo de 5 días.</p>
<p><img src="/img/blog/2019-05_circular-design-sprint/design-sprint-resumen.png" alt="Design SPRINT" /></p>
<h3 id="da1comprendermap">Día 1. Comprender (Map)</h3>
<p>Definimos el problema, articulando suposiciones, identificando al consumidor y logrando que todos los stakeholders estén alineados en el mismo objetivo y con la misma información.</p>
<h3 id="da2idearsketch">Día 2. Idear (Sketch)</h3>
<p>Exploramos múltiples formas de resolver el problema, sin importar si es viable o no. Esta libertad para explorar y ser creativos con la solución a menudo puede darnos conceptos e ideas muy novedosas.</p>
<h3 id="da3decidirdecide">Día 3. Decidir (Decide)</h3>
<p>Al no disponer de tiempo para prototipar todas las ideas, es necesario tener un proceso para decidir cuál es la mejor idea y cuáles debemos abandonar. A veces se escogerá una sola versión, mientras que otras se decidirá validar unas pocas alternativas.</p>
<h3 id="da4prototiparprototype">Día 4. Prototipar (Prototype)</h3>
<p>Nuestra idea es mucho más compleja que lo que podemos desarrollar en un día. Sin embargo, adoptando la mentalidad de prototipo construiremos una fachada, un prototipo de fidelidad media, lo bastante fidedigno como para que nos permita recopilar información de calidad de los tests.</p>
<h3 id="da5testeartest">Día 5. Testear (Test)</h3>
<p>¡Llegó el día! El objetivo aquí es validar (o no dar por buenas) las ideas del producto con usuarios reales, descubrir errores en el diseño de concepto, comprender a los usuarios y, en definitiva, crear un producto que las personas quieran usar.</p>
<h2 id="da1entender">Día 1. Entender</h2>
<h3 id="formacindelosequipos">Formación de los equipos</h3>
<p>Los participantes se repartieron entre 3 grupos, previamente formados por los organizadores. Cada grupo fue conformado por una mezcla de perfiles –diseñadores, marketing, emprendedores, ingenieros– y de grupos de edad diferentes.</p>
<p>Cada participante hizo una breve presentación de quién es, a qué se dedica y por qué se apuntó al Circular Design Sprint.</p>
<h3 id="desafo">Desafío</h3>
<p>El cliente nos presentó el desafío, esto es, un resultado que el cliente desea obtener. Este debía ser el foco de las soluciones a las que llegaremos en el&nbsp;<strong>SPRINT.</strong></p>
<blockquote>
  <p>Desafío Ecoembes: ¿Cómo podríamos incentivar y motivar a los ciudadanos para que reciclen mejor los envases domésticos?_</p>
</blockquote>
<p><img src="/img/blog/2019-05_circular-design-sprint/dia1-desafio.jpg" alt="Ecoembes Challenge" /></p>
<p>El desafío podía estar enfocado tanto a ciudadanos como al canal&nbsp;<em>HORECA</em>&nbsp;(HOtel, CAtering y REstaurantes).</p>
<p>Seguidamente se llevaron acabo varias actividades para entrar en contacto con el contexto del desafío: el mundo del reciclaje.</p>
<h3 id="entrevistas">Entrevistas</h3>
<p>En parejas, hicimos dos entrevistas entre los participantes, tratando de averiguar cuáles son los hábitos de consumo, conciencia medioambiental y patrones de reciclado.</p>
<h3 id="presentacindelcliente">Presentación del cliente</h3>
<p>Introducción al origen, labor y objetivos de Ecoembes, a cargo de Zacarías Torbado.</p>
<h3 id="mapadestakeholders">Mapa de Stakeholders</h3>
<p>En un gráfico con 3 círculos concéntricos debíamos colocar los stakeholders (partes implicadas) en el proceso de reciclado, de la siguiente manera:</p>
<ul>
<li>En el círculo interior se sitúan los stakeholders internos, esto es, los usuarios directos: ciudadanos o restaurantes en el caso de HORECA.</li>
<li>En el círculo intermedio los stakeholders directos, aquellos que tratan directamente con el usuario.</li>
<li>En el círculo exterior los indirectos, aquellos que no tratan directamente con el usuario.</li>
</ul>
<p><img src="/img/blog/2019-05_circular-design-sprint/dia1-stakeholders-1.jpg" alt="Sticking sticky notes on the stakeholders map" /></p>
<p>Cada participante debía disponer postits con los stakeholders que se le ocurrieran, sin discutirlo con los demás. En este paso debía prevalecer la cantidad, sin importar que dos postits dijeran casi lo mismo. Aproximadamente 10 minutos.</p>
<p><img src="/img/blog/2019-05_circular-design-sprint/dia1-stakeholders-2.jpg" alt="Stakeholders map" /></p>
<h3 id="contexto">Contexto</h3>
<p>Momento en que los expertos del lado del cliente ayudan a entender el contexto del problema a resolver. Se realizaron tres presentaciones a cargo de Ecoembes, en las cuales se nos explicó el funcionamiento de las plantas de separación de residuos, e investigaciones previas en España y otros países sobre mejoras en el proceso de recogida, separación de residuos y reciclaje (pago por generación, incentivo al reciclado, trazado de bolsas mediante RFID, smartag, NFC, etc.)</p>
<h3 id="revisindestakeholders">Revisión de stakeholders</h3>
<p>Tras conocer el contexto se revisó el mapa de stakeholders, pudiendo añadir los que se considera que faltan. Después se agruparon por tipo, disponiéndolos de forma radial, dividiendo los círculos como si fuera un queso.</p>
<h3 id="howmightwe">How Might We</h3>
<p>Esta es una actividad muy importante en el primer día del&nbsp;<strong>SPRINT</strong>. Vamos a comenzar la exploración de ideas de forma abierta. Cada participante debe formular, en postits, preguntas del estilo “How Might We…?”, esto es, cómo podríamos mejorar esto o aquello, motivar a los usuarios a realizar tal o cual cosa… De nuevo sin interferir y valorando la cantidad por encima de la calidad.</p>
<p>Se disponen en un papel grande y se van ordenando y agrupando verticalmente por afinidad.</p>
<p><img src="/img/blog/2019-05_circular-design-sprint/dia1-hmw-1.jpg" alt="How Might We…?" /></p>
<p>Después, se crean categorías y se colocan debajo los postits similares, donde juntamos uno encima de otro los que coincidan exactamente. Una vez agrupados, tenemos una idea de las preguntas que más se repiten y los temas a los que hemos dado más importancia. Cada persona tiene 3 votos en forma de pegatinas. Los votos se colocan en el tablero a la vez, con el fin de no influenciar a los demás.</p>
<p><img src="/img/blog/2019-05_circular-design-sprint/dia1-hmw-3.jpg" alt="How Might We by categories" /></p>
<p>Los postits que han obtenido votos se pasan al mapa de stakeholders, colocándolos en el cuadrante que corresponda, según las categorías creadas.</p>
<p><img src="/img/blog/2019-05_circular-design-sprint/dia1-stakeholders-3.jpg" alt="Stakeholders map + How Might We" /></p>
<p>Tras la ordenación de los stakeholders, se decidió sobre qué tipo de usuario y stakeholders íbamos a trabajar. En mi grupo seleccionamos el canal HORECA (HOteles, REstaurantes y CAtering), y el cuadrante que denominamos GENERADORES de residuos.</p>
<h3 id="entrevistasausuarios">Entrevistas a usuarios</h3>
<p>Se preparó un guion de entrevistas para los usuarios. Estas entrevistas nos debían permitir validar nuestras primeras hipótesis.</p>
<p>Estas hipótesis incluían el tipo de usuario promedio al que pretendíamos dar servicio, que decidimos que sería&nbsp;<strong>restaurantes de entre 2 y 6 empleados que tuvieran problemas para reciclar envases, por falta de motivación, tiempo o espacio</strong>. El objetivo es no dirigir la entrevista, ni tratar de venderles una solución, sino averiguar sus motivaciones y frustraciones relacionados con el reciclaje de envases domésticos. Finalmente se puede hacer alguna pregunta sobre la solución que tenemos en mente. La entrevista no debería tomar más de 10 minutos.Por la tarde realizamos las entrevistas propiamente dichas, en la calle o por Skype/teléfono.</p>
<p>Cada participante hizo 1-2 entrevistas, siendo el objetivo un total de 6 o más, número que ya se considera representativo. Entre estos 6 normalmente habrá 3-4 usuarios promedio, 1 extremo por arriba (restaurantes grandes) y 1 extremo por debajo (bares con un solo empleado).</p>
<h2 id="da2divergir">Día 2. Divergir</h2>
<h3 id="generarnbsppersona">Generar&nbsp;<em>persona</em></h3>
<p>El primer ejercicio fue recopilar y sintetizar la información de las entrevistas del día anterior. La herramienta utilizada fue una hoja Excel, donde se recopilaron todas las respuestas de cada uno de los usuarios, clasificándolas y buscando patrones. Finalmente se identificaron las frustraciones del usuario, sus motivaciones y los verbatim (frases literales cargadas de emociones, rabia, ira, etc., ideas con fuerza).</p>
<p>Dicha información se pasó a una matriz de síntesis, ordenando las frases y patrones más repetidos en:</p>
<ul>
<li>Patrones de comportamiento.</li>
<li>Motivaciones (Gains).</li>
<li>Frustraciones (Pains).</li>
<li>Verbatims.</li>
</ul>
<p>Tras detectar los patrones que más se repiten se genera la persona, que tendrá la siguiente estructura:</p>
<ul>
<li>Nombre y datos demográficos básicos.</li>
<li>Historia.</li>
<li>Necesidad.</li>
<li>Razón.</li>
</ul>
<p>El modelo debería ser parecido a esta frase:</p>
<blockquote>
  <p>Mario Kempes es un jefe de cocina de 35 años que trabaja en un bar que tiene 3 empleados. Recicla aceite y vidrio porque se lo pagan y se lo vienen a buscar, pero no recicla ni plásticos ni cartón por falta de incentivos económicos y espacio dentro del bar. Necesita que le paguen, le multen o le resuelvan el tema del espacio para poder reciclar más._</p>
</blockquote>
<p>Tras analizar las entrevistas, comprobamos que nuestros supuestos iniciales no fueron validados, y nuestra idea inicial -una especie de etiqueta de restaurante responsable con los residuos, que sirviera para premiar a los que más reciclan- no convencía a los dueños de locales, por lo que debíamos pivotar hacia nuevas soluciones.</p>
<h3 id="lightningdemos">Lightning demos</h3>
<p>Búsqueda de proyectos, prototipos, productos o servicios ya desarrollados o implantados, cuya idea general sea similar a la que ha escogido el equipo, como fuente de inspiración.</p>
<h3 id="brainstorming">Brainstorming</h3>
<p>Durante el tiempo estipulado (unos 10 minutos), cada miembro del equipo generó de forma individual todas las ideas que se le ocurrieron, en postits y bajo las siguientes premisas:</p>
<ul>
<li>Debe primar la cantidad sobre la calidad.</li>
<li>Debe primar lo visual sobre el texto.</li>
<li>Cada idea debe expresarse en aproximadamente 6 palabras.</li>
<li>Ideas ambiciosas.</li>
<li>No juzgar.</li>
<li>Se puede construir sobre las ideas de los demás.</li>
</ul>
<p>Una vez generadas, se leen en voz alta a los demás miembros del equipo y se aclaran dudas.</p>
<p>Seguidamente se disponen en el tablero y se ordenan.</p>
<ul>
<li>Se ponen una sobre otra aquellas que son exactamente iguales.</li>
<li>Se agrupan por temática.</li>
<li>Sobre cada grupo de postits relacionados se dispone un postit en diagonal (rombo) como título.</li>
</ul>
<p><img src="/img/blog/2019-05_circular-design-sprint/dia2-brainstorming-1.jpg" alt="Brainstorming" /></p>
<p>¡Llega el momento de votar! Cada miembro del equipo toma 3 pegatinas para votar 3 ideas diferentes. Se vota y se descartan las ideas que no han recibido ningún voto.</p>
<p><img src="/img/blog/2019-05_circular-design-sprint/dia2-brainstorming-2.jpg" alt="Voting" /></p>
<p>Entre las ideas que han recibido votos, se seleccionan unas pocas con las que vamos a trabajar, y se descarta el resto. No se tiene por qué descartar las menos votadas, aunque en principio es lo lógico, pero el grupo puede decidir incorporar alguna idea que haya recibido pocos votos pero que tenga sentido junto con el resto. Se reúnen estas ideas en el tablero, donde ya podremos visualizar el&nbsp;<em>big picture</em>&nbsp;de nuestra futura solución.</p>
<p><img src="/img/blog/2019-05_circular-design-sprint/dia2-brainstorming-4.jpg" alt="Stakeholders map + voted ideas from brainstorming" /></p>
<h3 id="crazy8">Crazy 8</h3>
<p>Cada miembro del equipo debía tomar un folio y doblarlo en 8 cuadrantes. En cada uno de estos cuadrantes debe hacer un esbozo de la solución que se va a desarrollar. Para ello, cada minuto escribirá o dibujará un cuadrante. Al final de los 8 minutos deberá tener un boceto del prototipo. Este fue mi <strong>crazy 8</strong> para la idea que conjuntamente habíamos decidido en el paso anterior.</p>
<p><img src="/img/blog/2019-05_circular-design-sprint/dia2-crazy8.jpg" alt="Crazy 8" /></p>
<h3 id="prototipoindividual">Prototipo individual</h3>
<p>Cada miembro del equipo, durante aproximadamente 1 hora, debía realizar un prototipo de la solución a desarrollar. Debía hacerlo en papel, usando una o varias hojas, con texto, diagramas, dibujos y postits. Una vez pasado el tiempo se entregó el prototipo al facilitador, que al día siguiente lo dispuso en forma de Art Museum en el tablero, para su exhibición.</p>
<h2 id="da3decidir">Día 3. Decidir</h2>
<h3 id="artmuseum">Art Museum</h3>
<p>En cada tablero de grupo se exhibieron los prototipos individuales. Los miembros del grupo leyeron cada propuesta sin conocer quién la había realizado. Una a una se desveló quién diseñó cada propuesta y se le pudieron formular preguntas para aclarar dudas. Seguidamente, cada integrante del equipo debía tomar 5 pegatinas para votar los aspectos de cada prototipo que más le gustaban. Se debe pensar primero y votar a la vez para evitar influenciar a los demás. Posteriormente, cada miembro del equipo tomó una pegatina azul más grande y emitió un voto sobre su idea preferida. También se piensa primero y se vota después, todos a la vez.</p>
<p><img src="/img/blog/2019-05_circular-design-sprint/dia3-art-museum-1.jpg" alt="Art Museum and votes" /></p>
<h3 id="pitchindividual">Pitch individual</h3>
<p>Cada integrante del equipo debía realizar la presentación de su idea al cliente, en un minuto y medio.</p>
<p><img src="/img/blog/2019-05_circular-design-sprint/dia3-pitch-1.jpg" alt="Individual pitch" /></p>
<p>Una vez presentadas todas las propuestas y después de un tiempo de reflexión, el cliente (llamado&nbsp;<strong>decisor</strong>&nbsp;en la metodología Design Sprint) señaló qué aspectos valoraba positivamente de cada propuesta e indicó mediante pegatinas amarillas cuáles eran las 2 o 3 ideas que deseaba incluir en el prototipo final.</p>
<h3 id="userjourney">User journey</h3>
<p>De forma individual, y tomando como input los puntos más votados de los prototipos y el feedback del cliente, cada integrante debía generar un user journey en 8 pasos. Utilizando 8 postits, en cada uno apuntamos una frase resumiendo un paso del user journey de nuestro producto o servicio. Conceptualmente los repartimos en 3 fases:</p>
<ul>
<li><em>Antes</em>: pasos que se dan antes de usar el producto o servicio</li>
<li><em>Durante</em>: pasos que se dan durante el uso</li>
<li><em>Después</em>: pasos que se dan después del uso</li>
</ul>
<p>Una vez trabajados los user journeys individuales, en el tablero, disponemos en 8 columnas los user journeys de todos los integrantes del equipo. Inicialmente cada user journey utilizará las 8 columnas, a lo largo de una fila. Seguidamente los ordenamos, agrupando los pasos similares o que identifican la misma acción, y poniéndolos debajo de aquel que mejor la resuma. Nos debe quedar un user journey con 8 pasos, y en cada columna solo tendremos unos pocos postits (uno o dos) para las diferentes ideas surgidas para dicho paso.</p>
<p><img src="/img/blog/2019-05_circular-design-sprint/dia3-user-journey.jpg" alt="User Journey" /></p>
<h3 id="pitchdeuserjourney">Pitch de user journey</h3>
<p>Un miembro designado por el equipo debía realizar un nuevo pitch de un minuto y medio describiendo el user journey de la idea tal y como se ha decidió en el punto anterior.</p>
<h3 id="borradordeprototipo">Borrador de prototipo</h3>
<p>Los integrantes del equipo debían trabajar en la creación de un nuevo borrador del prototipo, incorporando el feedback recibido y el user journey generado. En este punto se puede repartir el trabajo entre los miembros del equipo.</p>
<h2 id="da4prototipar">Día 4. Prototipar</h2>
<h3 id="eleccinderoles">Elección de roles</h3>
<p>El equipo debía designar varios roles para la realización del prototipo, donde una persona podía asumir varios roles:</p>
<ul>
<li><em>Diseñadores</em>: diseño gráfico de producto, presentación, landing page o mockups de aplicación.</li>
<li><em>Creadores de contenido</em>: imágenes y textos para presentación, landing pages o mockups de aplicación.</li>
<li><em>Copys</em>: textos para llamadas a la acción y otros textos creativos.</li>
<li><em>Stitcher</em>: aquel que se encarga de ensamblar las piezas y que lo que producen los demás tenga sentido en conjunto.</li>
</ul>
<h3 id="creacindelprototipo">Creación del prototipo</h3>
<p>Los integrantes del equipo debían trabajar en la creación del prototipo, de manera individual, en subgrupos o como estimaran conveniente. Finalmente el stitcher debía encargarse de la coordinación y unión de las piezas.</p>
<p>Dicho prototipo es tan solo una fachada del producto o servicio a diseñar, en ningún caso se pretende implementar un producto de manera exhaustiva, ya que el tiempo es extremadamente limitado. El objetivo de este prototipo es poder validar nuestras suposiciones mediante los tests que se realizarán el día siguiente.</p>
<p>En el caso de mi equipo, el prototipo debía mostrar un servicio de recogida de plásticos en los restaurantes. Dicho servicio incluía el uso de una app móvil, pero esta app no era la parte central de la aplicación, por lo que decidimos hacer una presentación comercial en lugar de un prototipo navegable.</p>
<p><img src="/img/blog/2019-05_circular-design-sprint/dia4-prototipo.png" alt="Prototype" /></p>
<p>Otros equipos estimaron hacer prototipos físicos mediante cajas, papel, etc., ya que debían simular dispositivos electrónicos que no existen.</p>
<h2 id="da5validar">Día 5. Validar</h2>
<h3 id="guiondeentrevistadevalidacin">Guion de entrevista de validación</h3>
<p>En primer lugar era necesario redactar un guion de entrevista al usuario final, incluyendo cómo se le va a abordar, en caso de ser entrevistas a puerta fría. Una vez más, las entrevistas deben buscar la validación del producto, no su aceptación por parte del usuario.</p>
<ul>
<li>¿Cumple nuestra solución con sus necesidades?</li>
<li>¿Son capaces de usar nuestra interfaz/servicio?</li>
<li>¿Qué le gusta o no le gusta de lo que hemos hecho?</li>
<li>¿Qué le gustaría mejorar?</li>
</ul>
<p>Para ello la metodología buscará:</p>
<ul>
<li>Usar preguntas abiertas en lugar de preguntas dirigidas.</li>
<li>Si existe un prototipo utilizable o clicable, dejar al usuario interactuar con él para ver si lo entiende y encontrar sus bloqueos o frustraciones con respecto a la interacción.</li>
<li>Realizar la mínima explicación de contexto necesaria antes de enfrentar al usuario al prototipo, en lugar de contarle todo, para ver si lo entiende, y evitar condicionarlo.</li>
</ul>
<p>En nuestro caso, no había prototipo clicable ya que se trataba más de un servicio que de la propia aplicación, por lo que optamos por mostrarle la presentación completa y averiguar más tarde qué pensaba de la solución.</p>
<h3 id="entrevistasdevalidacin">Entrevistas de validación</h3>
<p>Para la realización de entrevistas, según sean a puerta fría o previamente concertadas, habrá que salir a la calle o bien usar una sala de entrevistas, o Skype.</p>
<p>El caso ideal consistiría en concertar una serie de entrevistas presenciales con usuarios finales, y disponer de una sala en la que solo una persona hable con él, sin apuntar nada, para poder mantener contacto visual. Desde fuera otras personas observarían la entrevista, incluyendo la pantalla que esté manejando el usuario si es el caso, y apuntarían todo lo que observen de lo que el usuario dice y lo que realmente hace. Idealmente se grabaría todo en vídeo para poder repasarlo posteriormente.</p>
<p>Alternativas a esta situación ideal incluyen realizar la entrevista por Skype y grabarla, o bien que realicen la entrevista de forma presencial 2 o más personas, de las cuales una hablará con el usuario sin perder contacto visual, mientras que otras grabarán en audio/video (si la persona se puede mostrar cohibida puede ser mejor audio, ya que no se percibe cómo te graban) y anotarán los comentarios. El número de entrevistas de validación suficiente es de unas 10, entre las cuales debemos apuntar a nuestro usuario objetivo (persona) al menos en un 80%.</p>
<h3 id="conclusionesdelavalidacinaprendizaje">Conclusiones de la validación. Aprendizaje</h3>
<p>Se reúne de nuevo el equipo y se extraen patrones de las entrevistas. Para ello clasificaremos a los usuarios entrevistados según su perfil y agruparemos las respuestas recibidas. A partir de este aprendizaje sacaremos conclusiones sobre qué partes de la solución pueden funcionar y cuáles no, así como la solución a nivel global.</p>
<ul>
<li>¿Tiene sentido nuestra propuesta para los usuarios?</li>
<li>¿Saben interactuar con ella?</li>
<li>¿La podemos mejorar? ¿Cómo?</li>
<li>¿Seguimos con ella o la descartamos?</li>
</ul>
<h3 id="pitchfinal">Pitch final</h3>
<p>El equipo debía preparar un pitch final para presentar al cliente el prototipo realizado junto con las el aprendizaje obtenido de la validación. Este pitch final debía durar 5 minutos. Se realizó el pitch ante el cliente y se escuchó el feedback por parte de este.</p>
<h2 id="conclusiones">Conclusiones</h2>
<p>La impresión final fue que en un muy breve espacio de tiempo se alcanzó un resultado de gran calidad, donde se puso en juego mucha creatividad y soluciones originales. En varios puntos hubo que dar un golpe de timón, cuando se vio que los supuestos iniciales no eran validados, y se logró hacer sin demasiada resistencia por parte de los autores de dichas ideas iniciales. Aparentemente, las ideas no tenían un único autor y, de alguna manera, todos los miembros del equipo se sentían partícipes y realizaron su aportación, tanto en la generación de ideas como en la toma de decisiones.</p>
<p>Resulta un proceso bastante sorprendente desde dentro, ya que al principio hay una multitud de ideas dispares a las que poco a poco se va poniendo orden y descartando, bajo mucha presión de tiempo, hasta que finalmente todo va convergiendo de una forma que parece natural.</p>
<p>Asimismo, debido a la filosofía de exploración sin censura, las soluciones empiezan siendo muy ambiciosas y poco factibles, pero a medida que avanza el proceso se cancelan algunas ideas, se recombinan con otras o se encuentran soluciones degradadas a las ideas más de ciencia ficción, de modo que la solución final es factible. Esto nos permite llegar a poner en práctica ideas que inicialmente habríamos descartado por parecernos imposibles.</p>]]></description><link>https://juanguijordan.com/blog/2019-05_circular-design-sprint</link><guid isPermaLink="true">https://juanguijordan.com/blog/2019-05_circular-design-sprint</guid><category><![CDATA[design-sprint]]></category><category><![CDATA[ux]]></category><dc:creator><![CDATA[Juangui Jordán]]></dc:creator><pubDate>Tue, 25 Jun 2019 07:00:00 GMT</pubDate></item><item><title><![CDATA[Usando componentes web generados con Stencil en Ionic]]></title><description><![CDATA[<p>Esta publicación tiene como objetivo proporcionar instrucciones claras sobre cómo usar componentes creados y compilados con Stencil en una aplicación Ionic. Te guiaré en el proceso de hacer que un componente web esté disponible en tus templates Ionic, sin necesidad de registrarlos en el registro npm o agregar feos tags script a tu índice.</p>
<h2 id="motivacin">Motivación</h2>
<p>Creado por el <a href="http://ionicframework.com/">equipo de Ionic Framework</a>, uno esperaría que el uso de componentes web Stencil en proyectos Ionic sería, si no automático e integrado en el framework mediante algún comando CLI, al menos bien documentado.</p>
<p>Bueno, ese no es el caso, ya que los chicos de Ionic proporcionan <a href="https://stenciljs.com/docs/framework-integration">instrucciones de integración del framework</a> para Angular, React, Vue y Ember, pero no los proporcionan para Ionic. Tal vez descuidé algo obvio, pero tuve que investigar un poco para que mis componentes Stencil funcionaran en un proyecto Ionic, y el esfuerzo fue lo suficientemente grande como para hacerme pensar en crear una publicación, esperando que pueda ayudar a alguien.</p>
<h2 id="requisitos">Requisitos</h2>
<p>Como requisito, debes crear un componente Stencil, una tarea para la que puedes encontrar la documentación adecuada en el sitio web de Stencil. El componente Stencil tampoco necesita estar registrado en el registro npm.</p>
<h2 id="procesodeintegracin">Proceso de integración</h2>
<p>Si integramos componentes web registrados en npm, el proceso es más sencillo. Afrontemos en esta sección el caso en el que desarrollamos un componente personalizado, pero no lo estamos publicando en el registro npm. Nuestro objetivo es una integración limpia sin etiquetas de script en el archivo <code>index.html</code>.</p>
<p>El proceso consta de tres pasos.</p>
<ul>
<li>Primero construimos el componente y copiamos los archivos de distribución a nuestro proyecto.</li>
<li>Luego le decimos al lado Angular de las cosas cómo usar el componente.</li>
<li>Por último, le decimos al lado Ionic de las cosas que incluya el componente cuando construya el paquete. La forma en que hablamos con Angular (realmente Ionic-Angular) depende de si estamos cargando páginas de forma <em>anticipada</em> o de forma <em>diferida</em>.</li>
</ul>
<h3 id="paso1generarycopiarcomponente">Paso 1. Generar y copiar componente</h3>
<p>Construya el componente y copie el contenido de la carpeta dist a una carpeta en nuestro proyecto. En este ejemplo, elegimos la carpeta <code>@img/lib/components/my-google-maps</code>.</p>
<h3 id="paso2importarenelappmodulets">Paso 2. Importar en el app.module.ts</h3>
<p>Primero, necesitas importar el <code>CUSTOM_ELEMENTS_SCHEMA</code>, y agregarlo a la sección<code>schemas</code> del <code>@NgModule</code>. Si importas <code>CUSTOM_ELEMENTS_SCHEMA</code> en uno de los módulos de tu página, el compilador Angular aceptará elementos que no reconoce (de lo contrario, arrojará un error). Si realizas una carga diferida, debes importar este esquema en cada módulo de página en el que desees utilizar el componente web. Si estás cargando con anticipación, solo necesitas importar el esquema en <code>app.module.ts</code>.</p>
<p>Luego, agrega un import a la carpeta <code>dist/mycomponent</code>. Este import no carga todo el componente web. Solo carga una pequeña parte del código que permite a Ionic cargar el componente web completo más tarde, cuando una plantilla lo solicita.</p>
<p>Cuando hayas realizado ambos pasos, tu <code>app.module.ts</code> debería parecerse al siguiente si estás cargando con anticipación.</p>
<pre><code class="typescript language-typescript">import { CUSTOM_ELEMENTS_SCHEMA } from "@angular/core"; // add this import
import "@img/lib/components/my-google-maps/dist/mycomponent"; // add this import

@NgModule({
  declarations: [],
  imports: [],
  bootstrap: [],
  entryComponents: [],
  providers: [],
  schemas: [CUSTOM_ELEMENTS_SCHEMA], // add this line
})
export class AppModule {}
</code></pre>
<p>Si usas lazy loading, importa solo el componente web en <code>app.module.ts</code>, y solo el esquema en los módulos individuales cargados de forma diferida.</p>
<h3 id="paso3usarionicappscriptsparaincluirelcomponenteenelbuild">Paso 3. Usar ionic-app-scripts para incluir el componente en el build</h3>
<p>Crearemos un archivo <code>copy.config.js</code> que definirá algunas reglas para copiar el componente web a nuestra compilación final. Una buena práctica es crearlo en una carpeta de configuración, para separarlo de otros archivos estándar como <code>package.json</code> o <code>ionic.config.json</code>.</p>
<p>Este archivo puede indicarle a los scripts de aplicaciones Ionic que incluyan contenido adicional cuando compile una aplicación iónica. Si creas el archivo, ponlo en una carpeta llamada <code>config</code> que esté en el mismo nivel de directorio que la carpeta <code>src</code>. En primer lugar, declaremos el archivo en <code>package.json</code>. Esto le dirá a los scripts de la aplicación que usen este archivo. Agrega el siguiente campo a tu <code>package.json</code>:</p>
<pre><code class="json language-json">"config": {
    "ionic_copy": "./config/copy.config.js"
}
</code></pre>
<p>Luego, pon esto dentro de <code>config\copy.config.js</code>:</p>
<pre><code class="javascript language-javascript">module.exports = {
  copyTimeAgoWebComponent: {
    src: [
      "{{ROOT}}/src/img/lib/components/my-google-maps/dist/mycomponent**/*",
    ],
    dest: "{{BUILD}}",
  },
};
</code></pre>
<p>Una vez que hayas realizado esos cambios, los app-scripts sabrán cómo incluir el componente web en sus compilaciones.
Ahora puedes utilizar componentes web Stencil en tus plantillas Ionic como cualquier otro componente web.</p>]]></description><link>https://juanguijordan.com/blog/2018-08_ionic-stencil-integration</link><guid isPermaLink="true">https://juanguijordan.com/blog/2018-08_ionic-stencil-integration</guid><category><![CDATA[javascript]]></category><dc:creator><![CDATA[Juangui Jordán]]></dc:creator><pubDate>Wed, 12 Sep 2018 07:00:00 GMT</pubDate></item><item><title><![CDATA[Versioning features in an angular app]]></title><description><![CDATA[<p>Imagine a scenario where your app needs to show different versions of a component or services to different groups of users.
If it sounds a bit farfetched, take the following scenario that was proposed to our development team in some real project:</p>
<ul>
<li>The app is downloaded from <strong>Google Play/App Store</strong>, and will be deployed in different countries, using the same app ID.</li>
<li>Different countries have different regulations as to whether the app can display user photographies, specific fields, and so on.
Also, some features should be totally disabled in some countries.</li>
<li>The app will keep growing in functionality, but not necessarily at the same time for all countries:
some countries may decide not to upgrade some feature, or upgrade it later;
some countries may take more time to review if some particular new feature follows their privacy regulations…</li>
</ul>
<p>The naive approach of having ngIf directives all over the place can work for the simpler cases
but it would be hard to maintain and would also clutter our beautiful templates.
Also, components using different services when switching from one version to another would be very difficult to maintain.</p>
<p>So we came up to the following approach, to cope with all those situations:</p>
<ul>
<li>Create a directive to show/hide parts of a template depending on the country and version.
That would be like an extension of <em>ngIf</em> with our <em>country</em> and <em>version</em> parameters,
and would give an answer to simple problems like hiding a whole feature in some countries,
or hiding a particular field for some countries/versions.</li>
<li>Create a directive that returns a dynamic component, depending on the <em>country</em> and <em>version</em> parameters.
This directive would be used for more general cases,
where a component version can provide very different functionality from another version.</li>
</ul>
<p>To illustrate this post, we created an app. Our app proudly shows some country data,
like a country flag, area and population.
We made contact with governments all over the world and kindly asked them to join our non-profit revolutionary app,
providing some basic data:</p>
<ul>
<li>Country name</li>
<li>Area</li>
<li>Population</li>
</ul>
<p>Some of these countries have really severe regulations and wanted to join the app,
but without revealing their area and population initially,
until their lawyers would determine if this data could be displayed.
So we designed the first version of the app with a single screen,
where the user would select the country from a select combo box,
and a component with two subcomponents displaying the country data:</p>
<ul>
<li>A header component for the country name</li>
<li>A content component for the data</li>
</ul>
<p>The content component should be optional, and will display depending on the country’s regulations.</p>
<p><img src="/img/blog/2018-04_versioning-features-in-an-angular-app/features_v1.png" alt="Design of the first version of the components" /></p>
<p>These are some screenshots of the app at this point:</p>
<p><img src="/img/blog/2018-04_versioning-features-in-an-angular-app/features_v1_screenshots.png" alt="Screenshots of the first version of the app" /></p>
<p>After the kick off, some users were so excited that started to ask for some new features:</p>
<ul>
<li>They wanted to get the country flag displayed in the header</li>
<li>Some more data like country capital and wait for it… the national anthem, of course</li>
</ul>
<p>The development team agreed that, given that some countries still had not provided their area and population,
it was reasonable to think that some of them would not provide instantly their flag, capital and anthem.
So we decided to version the header and content components, so we could give them a smooth path to upgrade their data,
while still looking good in the app, showing the old components instead of new components with empty fields.</p>
<p><img src="/img/blog/2018-04_versioning-features-in-an-angular-app/features_v2.png" alt="Design of the final version of the components" /></p>
<p>These are some screenshots of the final version of the app:</p>
<p><img src="/img/blog/2018-04_versioning-features-in-an-angular-app/features_v2_screenshots.png" alt="Screenshots of the final version of the app" /></p>
<p>Our app builds on two directives, as we said.
The first one will show/hide an element depending on the feature availability for a certain country,
where the features will be <em>COUNTRY</em>HEADER_ and <em>COUNTRY</em>CONTENT_.
This directive will get the feature availability from a service, the so called _CountryConfigService_.</p>
<pre><code class="typescript language-typescript">import {
  CountryConfigDictionary,
  DEFAULT_COUNTRY_CONFIG,
  FeatureVersionDictionary,
} from "./country-config.model";

@Injectable()
export class CountryConfigService {
  private config: CountryConfigDictionary = DEFAULT_COUNTRY_CONFIG;
  getCountryFeatures(countryCode: string): FeatureVersionDictionary {
    return this.config[countryCode].features;
  }

  isFeatureEnabled(feature: string, countryCode: string): boolean {
    const countryFeatures = this.getCountryFeatures(countryCode);
    return countryFeatures.hasOwnProperty(feature);
  }

  getFeatureVersion(feature: string, countryCode: string): number {
    const countryFeatures = this.getCountryFeatures(countryCode);
    return countryFeatures[feature];
  }
}
</code></pre>
<p>The <em>config</em> is an object following a <em>CountryConfigDictionary</em> model
that lets us define which version of the <em>COUNTRY</em>HEADER_ and <em>COUNTRY</em>CONTENT_ components,
if any, is using each country:</p>
<pre><code class="typescript language-typescript">export const DEFAULT_COUNTRY_CONFIG: CountryConfigDictionary = {
  es: {
    features: {
      COUNTRY_HEADER: 2,
      COUNTRY_CONTENT: 2,
    },
  },
  fr: {
    features: {
      COUNTRY_HEADER: 2,
      COUNTRY_CONTENT: 2,
    },
  },
  it: {
    features: {
      COUNTRY_HEADER: 2,
      COUNTRY_CONTENT: 1,
    },
  },
  pt: {
    features: {
      COUNTRY_HEADER: 1,
      COUNTRY_CONTENT: 1,
    },
  },
  uk: {
    features: {
      COUNTRY_HEADER: 1,
    },
  },
};
</code></pre>
<h2 id="thefeatureifdirective">The FeatureIf directive</h2>
<p>With that in mind, let’s see the <em>FeatureIf</em> directive.
It will display an element if the feature is enabled for the country.
Optionally, we can define the minimum version implemented by the country,
meaning that if the country uses a lower version, the element will be hidden.
I will skip the standard imports to save space in the listing:</p>
<pre><code class="typescript language-typescript">import { CountryConfigService } from "../../services/country-config/country-config.service";

@Directive({
  selector: "[appFeatureIf]",
})
export class FeatureIfDirective implements OnChanges {
  private _featureName: string;
  private _countryCode: string;
  private _minVersion = 0;
  private _else = false;
  private _hasView: boolean;

  @Input() set appFeatureIf(featureName: string) {
    this._featureName = featureName;
  }

  @Input() set appFeatureIfCountryCode(value: string) {
    this._countryCode = value;
  }

  @Input() set appFeatureIfVersion(value: number) {
    this._minVersion = value;
  }

  @Input() set appFeatureIfElse(value: boolean) {
    this._else = value;
  }

  constructor(
    private templateRef: TemplateRef&lt;any&gt;,
    private viewContainerRef: ViewContainerRef,
    private countryConfigService: CountryConfigService
  ) {}

  ngOnChanges(changes: SimpleChanges): void {
    if (changes) {
      this.applyChanges();
    }
  }

  private applyChanges(): void {
    const featureEnabled = this.countryConfigService.isFeatureEnabled(
      this._featureName,
      this._countryCode
    );
    const featureVersion =
      this.countryConfigService.getFeatureVersion(
        this._featureName,
        this._countryCode
      ) || 0;
    const enabled: boolean =
      featureEnabled &amp;&amp; featureVersion &gt;= this._minVersion;
    const displayed: boolean =
      (enabled &amp;&amp; !this._else) || (!enabled &amp;&amp; this._else);
    this.embedTemplate(displayed);
  }

  private embedTemplate(enabled): void {
    if (enabled &amp;&amp; !this._hasView) {
      this.viewContainerRef.createEmbeddedView(this.templateRef);
      this._hasView = true;
    } else if (!enabled &amp;&amp; this._hasView) {
      this.viewContainerRef.clear();
      this._hasView = false;
    }
  }
}
</code></pre>
<p>This structural directive makes use of 4 parameters: <em>featureName</em>, <em>countryCode</em>, <em>featureVersion</em> and <em>else</em>.
Pay attention on how we define input properties in a structural directive:</p>
<ul>
<li>The first input takes the name of the very same directive: <em>appFeatureIf</em>.
We use a setter to internally save it as <em>_featureName</em>.</li>
<li>The rest of the inputs take the name of the directive plus the name of the parameter.
For instance, the input <em>appFeatureIfCountryCode</em> references the directive parameter <em>countryCode</em>.
We also use here a setter to map the input to the private variable <em>_countryCode</em>.</li>
</ul>
<p>Please remark below how the directive is used in a template.
The first parameter doesn’t need a key, while the rest is passed with <em>“key: value”</em> tuples, separated by a semicolon (;).</p>
<pre><code class="html language-html">&lt;div *appFeatureIf="'COUNTRY_HEADER';countryCode:code;version:2"&gt;
  Show only for countries implementing the COUNTRY_HEADER feature with version
  &gt;= 2
&lt;/div&gt;

&lt;div *appFeatureIf="'COUNTRY_HEADER';countryCode:code;version:2; else:'true'"&gt;
  Show otherwise
&lt;/div&gt;
</code></pre>
<p>What the directive basically does is:</p>
<ul>
<li>Registers for changes in any of the inputs.</li>
<li>When the directive is instantiated or any of the input changes, executes <em>applyChanges()</em>.</li>
<li>Computes if the feature is enabled according to feature <em>name</em>, <em>country code</em> and <em>version</em>.</li>
<li>Computes if the element has to be displayed.
If the <em>else</em> parameter is defined and true, then it will be displayed if the feature is disabled.</li>
<li>Executes <em>embedTemplate()</em>, which creates the embedded view into the view container if the element should be displayed,
or clears the view container otherwise.</li>
</ul>
<p>We use this directive in two cases in our app.
In the header, we use it to hide the flag for countries implementing <em>COUNTRY</em>HEADER_ version 1.</p>
<pre><code class="html language-html">&lt;div
  *appFeatureIf="'COUNTRY_HEADER';countryCode:country.code;
  version:2"
  class="flag {{country.code}}"
&gt;&lt;/div&gt;
</code></pre>
<p>In the parent component, we use the directive with the <em>else</em> parameter set to <em>true</em>,
to display an informative text when the content component is not available.</p>
<pre><code class="html language-html">&lt;div
  class="no-feature"
  *appFeatureIf="'COUNTRY_CONTENT';
  countryCode:country.code;else:'true'"
&gt;
  This feature is not yet available in {{country.name}}.
&lt;/div&gt;
</code></pre>
<h2 id="thefeatureversiondirective">The FeatureVersion directive</h2>
<p>Our second directive will allow us to dynamically inject a component or another, depending on some parameters.</p>
<pre><code class="typescript language-typescript">import { CountryConfigService } from "../../services/country-config/country-config.service";
import { DynamicComponentService } from "../../services/dynamic-component/dynamic-component.service";
import { DynamicComponent } from "../../services/dynamic-component/dynamic-component.model";

@Directive({
  selector: "[appFeatureVersion]",
})
export class FeatureVersionDirective implements OnChanges {
  private _featureName: string;
  private _countryCode: string;
  private _data: any;
  private componentRef: ComponentRef&lt;DynamicComponent&gt;;

  @Input() set appFeatureVersion(featureName: string) {
    this._featureName = featureName;
  }

  @Input()
  set appFeatureVersionCountryCode(value: string) {
    this._countryCode = value;
  }

  @Input()
  set appFeatureVersionData(value: any) {
    this._data = value;
  }

  constructor(
    private viewContainerRef: ViewContainerRef,
    private countryConfigService: CountryConfigService,
    private dynamicComponentService: DynamicComponentService,
    private componentFactoryResolver: ComponentFactoryResolver
  ) {}

  ngOnChanges(changes: SimpleChanges): void {
    if (changes) {
      this.applyChanges();
    }
  }

  private applyChanges(): void {
    const featureEnabled = this.countryConfigService.isFeatureEnabled(
      this._featureName,
      this._countryCode
    );
    const featureVersion =
      this.countryConfigService.getFeatureVersion(
        this._featureName,
        this._countryCode
      ) || 0;
    const dynamicComponent = this.dynamicComponentService.getComponent(
      this._featureName,
      featureVersion
    );
    this.clearViewContainer();
    if (featureEnabled &amp;&amp; dynamicComponent) {
      this.embedComponent(dynamicComponent);
      this.injectComponentData();
    }
  }

  private clearViewContainer(): void {
    this.viewContainerRef.clear();
  }

  private embedComponent(component: Type&lt;DynamicComponent&gt;): void {
    const componentFactory = this.componentFactoryResolver.resolveComponentFactory(
      component
    );
    this.componentRef = this.viewContainerRef.createComponent(componentFactory);
  }

  private injectComponentData(): void {
    this.componentRef.instance.data = this._data;
  }
}
</code></pre>
<p>This time, the directive takes three parameters: <em>featureName</em>, <em>countryCode</em> and <em>data</em>.
The <em>data</em> parameter will be used to pass data to our dynamic component.
Since different components may have different inputs,
we took the approach of receiving any external data through this <em>data</em> object.
Dynamic components may also receive external data through services, as we will see later.</p>
<p>So basically, what this directive does is:</p>
<ul>
<li>Registers for changes in any of the inputs.</li>
<li>When the directive is instantiated or any of the input changes, executes <em>applyChanges()</em>.</li>
<li>Computes if the feature is enabled according to feature name and country code.</li>
<li>Gets the dynamic component type for the feature name and version from the <em>DynamicComponentService</em>.</li>
<li>Clears the view container.</li>
<li>If a dynamic component type was retrieved successfully, executes <em>embedTemplate()</em>,
which resolves a factory for this type of component and creates the embedded view into the view container.</li>
<li>Finally, it injects the data object into the dynamically instantiated component.</li>
</ul>
<p>Let’s see the code for those <em>DynamicComponent</em> and <em>DynamicComponentService</em> classes.</p>
<p>The <em>DynamicComponent</em> is just a class with a public <em>data</em> property.
We will also create a dictionary interface and a constant with the current dynamic component classes
(country content version 1 and 2) that will be used by the service.</p>
<pre><code class="typescript language-typescript">import { CountryContentV1Component } from "../../../country/components/country-content/v1/country-content.v1.component";
import { CountryContentV2Component } from "../../../country/components/country-content/v2/country-content.v2.component";

export class DynamicComponent {
  data: any;
}

export interface DynamicComponentDictionary {
  [key: string]: {
    [key: number]: Type&lt;DynamicComponent&gt;;
  };
}

export const DEFAULT_DYNAMIC_COMPONENT_DICTIONARY: DynamicComponentDictionary = {
  COUNTRY_CONTENT: {
    1: CountryContentV1Component,
    2: CountryContentV2Component,
  },
};
</code></pre>
<p>The <em>DynamicComponentService</em> simply returns the appropriate component class,
depending on the <em>featureName</em> and <em>version</em> parameters.</p>
<pre><code class="typescript language-typescript">import {
  DEFAULT_DYNAMIC_COMPONENT_DICTIONARY,
  DynamicComponent,
  DynamicComponentDictionary,
} from "./dynamic-component.model";

@Injectable()
export class DynamicComponentService {
  private componentDictionary: DynamicComponentDictionary = DEFAULT_DYNAMIC_COMPONENT_DICTIONARY;

  getComponent(featureName: string, version: number): Type&lt;DynamicComponent&gt; {
    const selectedComponent = this.componentDictionary[featureName]
      ? this.componentDictionary[featureName][version]
      : undefined;
    return selectedComponent;
  }
}
</code></pre>
<p>Let’s see how this directive is used in the parent component.</p>
<pre><code class="html language-html">&lt;ng-template
  *appFeatureVersion="'COUNTRY_CONTENT';
  countryCode:country.code;data:{country: country}"
&gt;
&lt;/ng-template&gt;
</code></pre>
<p>This is the code for the <em>CountryContentV1Component</em> class.</p>
<pre><code class="typescript language-typescript">import { DynamicComponent } from "../../../../shared/services/dynamic-component/dynamic-component.model";
import { Country } from "../../../services/country.model";

@Component({
  selector: "app-country-content-v1",
  templateUrl: "./country-content.v1.component.html",
  styleUrls: ["./country-content.v1.component.scss"],
})
export class CountryContentV1Component implements DynamicComponent {
  data: { country: Country };
}
</code></pre>
<p>And this is how the template uses the <em>data</em> property to display the country data.</p>
<pre><code class="html language-html">&lt;div class="country-content"&gt;
  &lt;div class="data-row"&gt;
    &lt;span class="data-label"&gt; Area: &lt;/span&gt;
    &lt;span class="data-value"&gt; {{data.country.area | number}} &lt;/span&gt;
  &lt;/div&gt;
  &lt;div class="data-row"&gt;
    &lt;span class="data-label"&gt; Population: &lt;/span&gt;
    &lt;span class="data-value"&gt; {{data.country.population | number}} &lt;/span&gt;
  &lt;/div&gt;
&lt;/div&gt;
</code></pre>
<p>You can see a demo of the application here:</p>
<p>https://stackblitz.com/edit/component-version-demo</p>
<h2 id="versionedservices">Versioned services</h2>
<p>The situation can get a bit more complicated if services are also versioned.
Let’s imagine that the first version of the service providing country data just included the country name,
area and population, and that a new version should be created to include the new data,
while still providing the old version for backward compatibility.</p>
<p>In this case we can inject the corresponding service version in the versioned components.
We won’t be using the <em>data</em> property from <em>DynamicComponent</em>, but will get the data from the service instead.
We could also use injection tokens to dynamically inject the versioned service depending on certain conditions.</p>
<p>The following demo is a simple approach using versioned services.</p>
<p>https://stackblitz.com/edit/component-version-demo-services</p>
<h2 id="finalconsiderations">Final considerations</h2>
<p>The demo app is probably too simple for that kind of solution.
We could still smartly use some <em>ngIf</em> and <em>ngTemplate</em> stuff to get to the same solution.
But think of a case where the user doesn’t select the country from a combo box,
but the country gets auto detected from your device settings,
and think of a more complicated UI with a dashboard with several widgets that should be displayed or hidden,
or have different content according to the country, and then this approach will make much more sense.</p>
<p>This post is long enough to get into more details.
If you have suggestions to enhance it, please include them in your comments&nbsp;:)</p>]]></description><link>https://juanguijordan.com/blog/2018-04_versioning-features-in-an-angular-app</link><guid isPermaLink="true">https://juanguijordan.com/blog/2018-04_versioning-features-in-an-angular-app</guid><category><![CDATA[javascript]]></category><dc:creator><![CDATA[Juangui Jordán]]></dc:creator><pubDate>Tue, 24 Apr 2018 07:00:00 GMT</pubDate></item><item><title><![CDATA[Deploying an Angular CLI project on Github Pages and Stackblitz]]></title><description><![CDATA[<p>Can’t wait to show to the world your proof of concept, side project, idea…?
This 5-line bash recipe will put your work on the showcase in a matter of seconds.</p>
<p>So you just finished creating the coolest project with <a href="https://cli.angular.io/">Angular CLI</a> and want to share it with your colleagues, or perhaps write a post about it, but you want to skip the pain to your colleagues of checking out the code, installing dependencies and launching the app — I know, it almost can’t get any easier nowadays — and you don’t own a web server, or perhaps you are as lazy as your colleagues and don’t feel like putting much effort on deploying your code anywhere.</p>
<p>Well, <a href="https://pages.github.com/">Github Pages</a> to the rescue!</p>
<h2 id="githubpages">GitHub Pages</h2>
<p>I am assuming that you already created your project with Angular CLI, so your project is already versioned with git.
Let’s assume too that you already have a <strong>GitHub account</strong> with some <em>NICKNAME</em>.
Head yourself to GitHub and create a new project, let’s call it <em>MY</em>PROJECT_.
Don’t put any files in it, you can come back later and add the _README_ and the desired license,
but for now it will be easier if you just leave it blank.</p>
<p>Then, connect your local git repository with the new remote repository and push the changes:</p>
<pre><code class="bash language-bash">git remote add origin https://github.com/NICKNAME/MY_PROJECT.git
git push origin master
</code></pre>
<p>Now, if you already knew about GitHub Pages, you’d be tempted to manually activate them on the <em>index.html</em> file of your project.
<strong>DON’T DO THAT! It won’t work!!</strong></p>
<p>Your project still needs to be built for production,
then a <em>dist</em> folder will be created from which you could serve your GitHub pages but <strong>DON’T! It won’t work!!!</strong></p>
<p>It looks like GitHub Pages is not suited for SPAs, since it redirects any paths in your app to a 404 page.
But some really nice guys developed <a href="https://www.npmjs.com/package/angular-cli-ghpages">angular-cli-ghpages</a>.
This npm package will fill the gaps and make your app work in GitHub Pages.</p>
<p>Install it with:</p>
<pre><code class="bash language-bash">npm install -g angular-cli-ghpages
</code></pre>
<p>Then execute these 2 commands:</p>
<pre><code class="bash language-bash">ng build --prod --base-href "https://NICKNAME.github.io/MY_PROJECT/"
angular-cli-ghpages
</code></pre>
<p>The second command has a bunch of options, but they are all optional as the word <em>option</em> states,
and you don’t need much more to get your app up and running on GitHub Pages. Enjoy!</p>
<p>Well, certainly you’ll need the URL of your app to share it with the world.
This URL is exactly the one that we used on the ng build command:</p>
<p><a href="#">https://NICKNAME.github.io/MY_PROJECT/</a></p>
<h3 id="deployingionicprojects">Deploying ionic projects</h3>
<p>Update: 2018-05-07</p>
<p>What about Ionic projects.
They are deployed to <code>www</code> instead of the <code>dist</code> folder, and they use Ionic CLI instead of Angular CLI,
so a couple of changes will need to be done.</p>
<pre><code class="bash language-bash">ionic build --prod
</code></pre>
<p>The <code>--base-href</code> is not available in Ionic CLI (not that I'm aware of),
so you will need to open the index.html file and write the base tag on your own, after the build is finished.
You can put it after the title tag, for instance:</p>
<pre><code class="html language-html">&lt;title&gt;Ionic App&lt;/title&gt;
&lt;base href="https://NICKNAME.github.io/MY_PROJECT/" /&gt;
&lt;meta
  name="viewport"
  content="viewport-fit=cover, width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no"
/&gt;
</code></pre>
<p>Now, as I said, the output of the build is not the default for Angular CLI, which would be the dist folder.
Use the <code>--dir</code> flag to specify the <code>www</code> folder as the source for GitHub Pages.</p>
<pre><code class="bash language-bash">angular-cli-ghpages --dir www
</code></pre>
<h2 id="stackblitz">Stackblitz</h2>
<p>Now for the <a href="https://stackblitz.com/">Stackblitz</a> part of the post… wouldn’t it be nice to enable our colleagues or followers, to actually interact with our code and see the impact of the modifications in almost-real-time?</p>
<p>The guys from Stackblitz have created this sort of online IDE where you can create projects and see the build at the same time.
It’s like <strong>JSfiddler</strong> on steroids!</p>
<p><img src="/img/blog/2018-03_angular-cli-github-pages-stackblitz/stackblitz.png" alt="Stackblitz" /></p>
<p>Even simpler than registering on Stackblitz, creating a project and uploading your project files,
this one line trick will load your GitHub project on the Stackblitz IDE.</p>
<p>Just share this URL, using again your GitHub nickname and project name:</p>
<p><a href="#">https://stackblitz.com/github/NICKNAME/MY_PROJECT</a></p>
<p>This is valid also for branches, tags or specific commits. Just use the following scheme for the URL:</p>
<p><a href="#">https://stackblitz.com/github/NICKNAME/MY_PROJECT/tree/{TAG|BRANCH|COMMIT}</a></p>
<p>I hope this post helped you to release your projects in a place where they can be seen, enjoyed and edited by others.</p>]]></description><link>https://juanguijordan.com/blog/2018-03_angular-cli-github-pages-stackblitz</link><guid isPermaLink="true">https://juanguijordan.com/blog/2018-03_angular-cli-github-pages-stackblitz</guid><category><![CDATA[javascript]]></category><dc:creator><![CDATA[Juangui Jordán]]></dc:creator><pubDate>Mon, 26 Mar 2018 07:00:00 GMT</pubDate></item></channel></rss>