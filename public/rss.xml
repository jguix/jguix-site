<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[Juangui Jordán]]></title><description><![CDATA[This is my site where I gather my blog posts and some other random stuff]]></description><link>https://juanguijordan.com</link><image><url>https://juanguijordan.com/icon.png</url><title>Juangui Jordán</title><link>https://juanguijordan.com</link></image><generator>RSS for Node</generator><lastBuildDate>Thu, 18 Mar 2021 00:00:26 GMT</lastBuildDate><atom:link href="https://juanguijordan.com/rss.xml" rel="self" type="application/rss+xml"/><pubDate>Wed, 17 Feb 2021 08:00:00 GMT</pubDate><copyright><![CDATA[2021 Juangui Jordán]]></copyright><language><![CDATA[en]]></language><managingEditor><![CDATA[juangui@gmail.com]]></managingEditor><webMaster><![CDATA[juangui@gmail.com]]></webMaster><ttl>60</ttl><item><title><![CDATA[Usando redux con datos relacionales (2/3)]]></title><description><![CDATA[<h2 id="parte2implementandolastorederedux">Parte 2. Implementando la store de redux</h2>
<p>En esta serie de posts crearemos una aplicación usando <strong>react</strong> y <strong>redux</strong>, en la que manejaremos datos relacionales. En esta segunda parte modelaremos la store.</p>
<p>Al final de la anterior parte de esta serie habíamos modelado la tienda. Consulta la parte 1 si necesitas más contexto sobre ello: <a href="https://blog-es.mimacom.com/redux-normalized-store-part-1/">Usando redux con datos relacionales (1/3)</a>.</p>
<p>Nuestra tienda tendrá dos reducers principales, la store <code>entities</code> y la store <code>ui</code>.</p>
<p>Comencemos por crear la store <code>entities</code>. Tendrá 3 tipos de datos o entidades, a saber:</p>
<ul>
<li>user</li>
<li>comment</li>
<li>post</li>
</ul>
<p>Cada entidad tendrá asociados tipos, acciones y reducers. En aras de una fácil comprensión, mostraré los tipos y acciones en primer lugar.</p>
<p>Tipos de usuario:</p>
<pre><code class="javascript language-javascript">// user.types.ts
export type User = {
  avatar: string,
  email: string,
  id: number,
  name: string,
};
</code></pre>
<p>Las acciones del usuario incluirán una acción para cargar todos los usuarios en la store y una acción para cargar un solo usuario. La primera será llamada potencialmente desde la página <code>My Friends</code>, la segunda desde la página <code>My Wall</code> o la página <code>Friend Wall</code>, donde los posts y los comentarios mostrarán el usuario asociado junto a ellos.</p>
<pre><code class="javascript language-javascript">// user.actions.ts
import { User } from './user.types';

export enum UserActionTypes {
  LOAD_USER = 'USER:LOAD_USER',
  LOAD_USERS = 'USER:LOAD_USERS',
}

export type LoadUserPayload = {
  user: User;
};

export type LoadUserAction = {
  type: UserActionTypes.LOAD_USER;
  payload: LoadUserPayload;
};

const loadUserAction = (payload: LoadUserPayload): LoadUserAction =&gt; {
  return {
    payload,
    type: UserActionTypes.LOAD_USER,
  };
};

export type LoadUsersPayload = {
  users: User[];
};

export type LoadUsersAction = {
  type: UserActionTypes.LOAD_USERS;
  payload: LoadUsersPayload;
};

const loadUsersAction = (payload: LoadUsersPayload): LoadUsersAction =&gt; {
  return {
    payload,
    type: UserActionTypes.LOAD_USERS,
  };
};

export const userActions = {
  loadUserAction,
  loadUsersAction,
};
</code></pre>
<p>De igual manera, tendremos tipos de <code>post</code>, donde cada publicación tiene un <code>userId</code>, que es la forma en que nuestra base de datos administrará la relación de uno a muchos (pero recuerda que haremos que estos datos sean más fáciles de buscar creando un reducer <code>postIdsById</code> dentro del reducer <code>users</code>):</p>
<pre><code class="javascript language-javascript">// post.types.ts
export type Post = {
  body: string,
  date: Date,
  id: number,
  userId: number,
};
</code></pre>
<p>Las acciones de los <code>post</code> solo incluyen una acción para cargar publicaciones por usuario, siendo el <code>userId</code> un parámetro opcional. Enviaremos esta acción con el parámetro <code>userId</code> informado desde la página<code>Friend Wall</code> para obtener todas sus publicaciones. Despacharemos esta acción con el parámetro <code>userId</code> con valor <code>undefined</code> desde <code>My Wall</code> para obtener todas las publicaciones de todos los usuarios (para simplificar, digamos que todos los usuarios son amigos míos).</p>
<pre><code class="javascript language-javascript">// post.actions.ts
import { Post } from './post.types';

export enum PostActionTypes {
  LOAD_POSTS = 'POST:LOAD_POSTS',
}

export type LoadPostsPayload = {
  posts: Post[];
  userId?: number;
};

export type LoadPostsAction = {
  type: PostActionTypes.LOAD_POSTS;
  payload: LoadPostsPayload;
};

const loadPostsAction = (payload: LoadPostsPayload): LoadPostsAction =&gt; {
  return {
    payload,
    type: PostActionTypes.LOAD_POSTS,
  };
};

export const postActions = {
  loadPostsAction,
};
</code></pre>
<p>En cuanto a los tipos de <code>comment</code>, contendrán índices que apuntan al <code>post</code> y el <code>user</code> relacionados:</p>
<pre><code class="javascript language-javascript">// comment.types.ts
export type Comment = {
  body: string,
  date: Date,
  id: number,
  postId: number,
  userId: number,
};
</code></pre>
<p>Las acciones de <code>comment</code> también incluyen solo una acción para cargar comentarios por post:</p>
<pre><code class="javascript language-javascript">// comments.actions
import { Comment } from './comment.types';

export enum CommentActionTypes {
  LOAD_COMMENTS = 'COMMENT:LOAD_COMMENTS',
}

export type LoadCommentsPayload = {
  comments: Comment[];
  postId?: number;
};

export type LoadCommentsAction = {
  type: CommentActionTypes.LOAD_COMMENTS;
  payload: LoadCommentsPayload;
};

const loadCommentsAction = (payload: LoadCommentsPayload): LoadCommentsAction =&gt; {
  return {
    payload,
    type: CommentActionTypes.LOAD_COMMENTS,
  };
};

export const commentActions = {
  loadCommentsAction,
};
</code></pre>
<p>Ahora, abordemos los reducers. En cuanto al reducer <code>user</code>, se creará combinando dos reducers. El primero tomará la acción <code>LoadUsersAction</code> y almacenará un mapa de usuarios por<code>id</code>. También procesará la <code>LoadUserAction</code> y almacenará al usuario en el mapa. El segundo tomará el <code>LoadPostsAction</code> y almacenará un mapa de <code>postIds</code> relacionados con un usuario.</p>
<pre><code class="javascript language-javascript">// user.reducer.ts
import { User } from './user.types';
import { UserActionTypes, LoadUsersAction, LoadUserAction } from './user.actions';
import { NumberIndexed } from '../shared/shared.types';
import { AnyAction, combineReducers, Reducer } from 'redux';
import { LoadPostsAction, PostActionTypes } from '../post/post.actions';

export type UserState = {
  byId: NumberIndexed&lt;User&gt;;
  postIdsById: NumberIndexed&lt;number[]&gt;; // one-to-many relation
};

export type UserStore = {
  users: UserState;
};

export const userByIdReducer = (state: NumberIndexed&lt;User&gt; = {}, action: AnyAction) =&gt; {
  switch (action.type) {
    case UserActionTypes.LOAD_USERS:
      const { payload } = action as LoadUsersAction;
      const { users } = payload;
      const loadedUsersMap = users.reduce((map, user) =&gt; ({ ...map, [user.id]: user }), {});

      return {
        ...state,
        ...loadedUsersMap,
      };

    case UserActionTypes.LOAD_USER:
      const { payload: userPayload } = action as LoadUserAction;
      const { user } = userPayload;

      return {
        ...state,
        [user.id]: user,
      };
  }

  return state;
};

export const postIdsByIdReducer = (state: NumberIndexed&lt;number[]&gt; = {}, action: AnyAction) =&gt; {
  switch (action.type) {
    case PostActionTypes.LOAD_POSTS:
      const { payload } = action as LoadPostsAction;
      const { posts, userId } = payload;
      let loadedPostIdsByUserIdMap = posts.reduce(
        (postIdsByUserIdMap, post) =&gt; ({
          ...postIdsByUserIdMap,
          [post.userId]: postIdsByUserIdMap[post.userId] ? [...postIdsByUserIdMap[post.userId], post.id] : [post.id],
        }),
        {} as NumberIndexed&lt;number[]&gt;
      );
      if (posts.length === 0) {
        loadedPostIdsByUserIdMap = { [userId as number]: [] };
      }

      return {
        ...state,
        ...loadedPostIdsByUserIdMap,
      };
  }

  return state;
};

export const userReducer: Reducer&lt;UserState&gt; = combineReducers({
  byId: userByIdReducer,
  postIdsById: postIdsByIdReducer,
});
</code></pre>
<p>El tipo personalizado <code>NumberIndexed</code> se define de la siguiente manera, en un archivo compartido donde también definimos los tipos para los filtros. Este tipo nos permite tipar mapas con números como índices, utilizados por los reductores anteriores.</p>
<pre><code class="javascript language-javascript">// shared.types.ts
export type NumberIndexed&lt;T&gt; = { [index: number]: T };
export type StringIndexed&lt;T&gt; = { [index: string]: T };
export type OrderType = "asc" | "desc";
</code></pre>
<p>De manera similar, el reducer <code>post</code> tiene un reducer relacionado con la acción<code>LoadPost</code> y un reducer que se encarga de la <code>LoadCommentsAction</code>.</p>
<pre><code class="javascript language-javascript">// post.reducer.ts
import { Post } from './post.types';
import { PostActionTypes, LoadPostsAction } from './post.actions';
import { NumberIndexed } from '../shared/shared.types';
import { AnyAction, combineReducers, Reducer } from 'redux';
import { CommentActionTypes, LoadCommentsAction } from '../comment/comment.actions';

export type PostState = {
  byId: NumberIndexed&lt;Post&gt;;
  commentIdsById: NumberIndexed&lt;number[]&gt;; // one-to-many relation
};

export type PostStore = {
  posts: PostState;
};

export const postByIdReducer = (state: NumberIndexed&lt;Post&gt; = {}, action: AnyAction) =&gt; {
  switch (action.type) {
    case PostActionTypes.LOAD_POSTS:
      const { payload } = action as LoadPostsAction;
      const { posts } = payload;
      const loadedPostsMap = posts.reduce((map, post) =&gt; ({ ...map, [post.id]: post }), {});

      return {
        ...state,
        ...loadedPostsMap,
      };
  }

  return state;
};

export const commentIdsByIdReducer = (state: NumberIndexed&lt;number[]&gt; = {}, action: AnyAction) =&gt; {
  switch (action.type) {
    case CommentActionTypes.LOAD_COMMENTS:
      const { payload } = action as LoadCommentsAction;
      const { comments, postId } = payload;
      let loadedCommentIdsByPostIdMap = comments.reduce(
        (commentIdsByPostIdMap, comment) =&gt; ({
          ...commentIdsByPostIdMap,
          [comment.postId]: commentIdsByPostIdMap[comment.postId]
            ? [...commentIdsByPostIdMap[comment.postId], comment.id]
            : [comment.id],
        }),
        {} as NumberIndexed&lt;number[]&gt;
      );
      if (comments.length === 0) {
        loadedCommentIdsByPostIdMap = { [postId as number]: [] };
      }

      return {
        ...state,
        ...loadedCommentIdsByPostIdMap,
      };
  }

  return state;
};

export const postReducer: Reducer&lt;PostState&gt; = combineReducers({
  byId: postByIdReducer,
  commentIdsById: commentIdsByIdReducer,
});
</code></pre>
<p>El reducer de <code>comment</code> es más simple, encargándose solo de la acción<code>LoadComments</code>.</p>
<pre><code class="javascript language-javascript">// comment.reducer.ts
import { Comment } from './comment.types';
import { CommentActionTypes, LoadCommentsAction } from './comment.actions';
import { NumberIndexed } from '../shared/shared.types';
import { AnyAction, combineReducers, Reducer } from 'redux';

export type CommentState = {
  byId: NumberIndexed&lt;Comment&gt;;
};

export type CommentStore = {
  comments: CommentState;
};

export const commentByIdReducer = (state: NumberIndexed&lt;Comment&gt; = {}, action: AnyAction) =&gt; {
  switch (action.type) {
    case CommentActionTypes.LOAD_COMMENTS:
      const { payload } = action as LoadCommentsAction;
      const { comments } = payload;
      const loadedCommentsMap = comments.reduce((map, comment) =&gt; ({ ...map, [comment.id]: comment }), {});

      return {
        ...state,
        ...loadedCommentsMap,
      };
  }

  return state;
};

export const commentReducer: Reducer&lt;CommentState&gt; = combineReducers({
  byId: commentByIdReducer,
});
</code></pre>
<p>A continuación, implementaremos la store <code>ui</code>. Contendrá los datos de la página <code>My Wall</code>, <code>Friend Wall</code> y <code>Friends</code>.</p>
<p><code>My Wall</code> no contendrá tipos personalizados, solo índices a entidades de <code>post</code> que pertenecen al usuario que se mostrarán en la página. Las acciones incluirán una acción para cargar posts del muro.</p>
<pre><code class="javascript language-javascript">// wall.actions.ts
export enum WallActionTypes {
  LOAD_POSTS = 'WALL:LOAD_POSTS',
}

export type LoadWallPostsPayload = {
  postIds: number[];
};

export type LoadWallPostsAction = {
  type: WallActionTypes.LOAD_POSTS;
  payload: LoadWallPostsPayload;
};

const loadWallPostsAction = (payload: LoadWallPostsPayload): LoadWallPostsAction =&gt; {
  return {
    payload,
    type: WallActionTypes.LOAD_POSTS,
  };
};

export const wallActions = {
  loadWallPostsAction,
};
</code></pre>
<p>El reducer será sencillo, encargándose solo de esa acción.</p>
<pre><code class="javascript language-javascript">// wall.reducer.ts
import { AnyAction, combineReducers, Reducer } from 'redux';
import { LoadWallPostsAction, WallActionTypes } from './wall.actions';

export type WallState = {
  postIds: number[];
};

export type WallStore = {
  wall: WallState;
};

export const postIdsReducer = (state: number[] = [], action: AnyAction) =&gt; {
  switch (action.type) {
    case WallActionTypes.LOAD_POSTS:
      const { payload } = action as LoadWallPostsAction;
      const { postIds } = payload;
      return [...state, ...postIds];
  }

  return state;
};

export const wallReducer: Reducer&lt;WallState&gt; = combineReducers({
  postIds: postIdsReducer,
});
</code></pre>
<p>Omitiremos el código para las acciones y reducers asociados al <code>Friend Wall</code>, que son muy similares a los de <code>My Wall</code>. Puedes consultar la <a href="https://github.com/jguix/redux-normalized-example/tree/blogpost-part2">rama del repositorio de git</a> para este post si deseas ver todo el código fuente.</p>
<p>Las acciones de <code>Friends</code> incluirán cargar amigos y establecer el orden de la lista de amigos (ascendente o descendente).</p>
<pre><code class="javascript language-javascript">// friends.actions.ts
import { OrderType } from '../shared/shared.types';

export enum FriendsActionTypes {
  LOAD_FRIENDS = 'FRIENDS:LOAD_FRIENDS',
  SET_FRIENDS_ORDER = 'FRIENDS:SET_FRIENDS_ORDER',
}

export type LoadFriendsPayload = {
  userIds: number[];
};

export type LoadFriendsAction = {
  type: FriendsActionTypes.LOAD_FRIENDS;
  payload: LoadFriendsPayload;
};

const loadFriendsAction = (payload: LoadFriendsPayload): LoadFriendsAction =&gt; {
  return {
    payload,
    type: FriendsActionTypes.LOAD_FRIENDS,
  };
};

export type SetFriendsOrderPayload = {
  order: OrderType;
};

export type SetFriendsOrderAction = {
  type: FriendsActionTypes.SET_FRIENDS_ORDER;
  payload: SetFriendsOrderPayload;
};

const setFriendsOrderAction = (payload: SetFriendsOrderPayload): SetFriendsOrderAction =&gt; {
  return {
    payload,
    type: FriendsActionTypes.SET_FRIENDS_ORDER,
  };
};

export const friendsActions = {
  loadFriendsAction,
  setFriendsOrderAction,
};
</code></pre>
<p>El reducer <code>friends</code> tendrá reducers que solo apunten a las entidades <code>user</code>. Tendremos uno para la lista con orden ascendente y otro para la lista con orden descendente, porque implementaremos una estrategia de paginación con el backend (de eso hablaremos en la próxima publicación de la serie). Otro reducer almacenará el estado del filtro.</p>
<pre><code class="javascript language-javascript">// friends.reducer.ts
import { AnyAction, combineReducers, Reducer } from 'redux';
import { FriendsActionTypes, LoadFriendsAction, SetFriendsOrderAction } from './friends.actions';

export type FriendsState = {
  orderFilter: 'asc' | 'desc';
  userIds: number[];
};

export type FriendsStore = {
  friends: FriendsState;
};

export const orderFilterReducer = (state: 'asc' | 'desc' = 'asc', action: AnyAction) =&gt; {
  switch (action.type) {
    case FriendsActionTypes.SET_FRIENDS_ORDER:
      const { payload } = action as SetFriendsOrderAction;
      const { order } = payload;
      return order;
  }

  return state;
};

export const userIdsReducer = (state: number[] = [], action: AnyAction) =&gt; {
  switch (action.type) {
    case FriendsActionTypes.LOAD_FRIENDS:
      const { payload } = action as LoadFriendsAction;
      const { userIds } = payload;
      return [...state, ...userIds];

    case FriendsActionTypes.SET_FRIENDS_ORDER:
      return [];
  }

  return state;
};

export const friendsReducer: Reducer&lt;FriendsState&gt; = combineReducers({
  orderFilter: orderFilterReducer,
  userIds: userIdsReducer,
});
</code></pre>
<p>Para crear la store, primero instalaremos la <a href="https://github.com/zalmoxisus/redux-devtools-extension">redux-devtools-extension</a>. Con estas herramientas podremos depurar el despacho de acciones y los cambios en el estado de la store.</p>
<pre><code>yarn add redux-devtools-extension
</code></pre>
<p>La <code>root</code> store se compone de la store <code>entities</code> y la store <code>ui</code> de la siguiente manera:</p>
<pre><code class="javascript language-javascript">// store.ts
import { combineReducers, createStore, Reducer } from "redux";
import { userReducer, UserStore } from "../modules/user/user.reducer";
import {
  commentReducer,
  CommentStore,
} from "../modules/comment/comment.reducer";
import { postReducer, PostStore } from "../modules/post/post.reducer";
import {
  friendsReducer,
  FriendsStore,
} from "../modules/friends/friends.reducer";
import {
  FriendWallStore,
  friendWallReducer,
} from "../modules/friend-wall/friend-wall.reducer";
import { wallReducer, WallStore } from "../modules/wall/wall.reducer";
import { composeWithDevTools } from "redux-devtools-extension";

export type EntitiesStore = CommentStore &amp; PostStore &amp; UserStore;

export type UIStore = FriendsStore &amp; FriendWallStore &amp; WallStore;

export type ApplicationStore = {
  entities: EntitiesStore,
  ui: UIStore,
};

export const entitiesReducer = combineReducers({
  comments: commentReducer,
  posts: postReducer,
  users: userReducer,
});

export const uiReducer = combineReducers({
  friends: friendsReducer,
  friendWall: friendWallReducer,
  wall: wallReducer,
});

export const rootReducer: Reducer&lt;ApplicationStore&gt; = combineReducers({
  entities: entitiesReducer,
  ui: uiReducer,
});

export const store = createStore(rootReducer, composeWithDevTools());
</code></pre>
<p>Finalmente, introduzcamos algunos datos en esta store, enviemos algunas acciones y veamos los resultados. Usaremos algunos datos simulados y mostraremos los resultados usando mensajes <code>console.log</code> e imprimiendo el contenido de la store en la página principal. Alternativamente, puede depurar estas acciones con un complemento de Chrome como <a href="https://chrome.google.com/webstore/detail/redux-devtools/lmhkpmbekcpmknklioeibfkpmmfibljd">Redux DevTools</a>.</p>
<pre><code class="javascript language-javascript">// App.tsx
import React from "react";
import "./App.css";
import { store } from "./store/store";
import { userActions } from "./modules/user/user.actions";
import { User } from "./modules/user/user.types";
import { Post } from "./modules/post/post.types";
import { postActions } from "./modules/post/post.actions";
import { Comment } from "./modules/comment/comment.types";
import { commentActions } from "./modules/comment/comment.actions";
import { friendsActions } from "./modules/friends/friends.actions";
import { wallActions } from "./modules/wall/wall.actions";
import { friendWallActions } from "./modules/friend-wall/friend-wall.actions";

const users: User[] = [
  {
    id: 1,
    name: "Josh Martin",
    email: "josh.martin@gmail.com",
    avatar: "http://placekitten.com/g/500/400",
  },
  {
    id: 2,
    name: "Emily Matthews",
    email: "emily.matthews@gmail.com",
    avatar: "http://placekitten.com/g/400/400",
  },
  {
    id: 3,
    name: "Sonia Lee",
    email: "sonia.lee@gmail.com",
    avatar: "http://placekitten.com/g/400/500",
  },
];
const posts: Post[] = [
  { id: 1, body: "Blah", date: new Date(), userId: 1 },
  { id: 2, body: "Bleh", date: new Date(), userId: 1 },
  { id: 3, body: "Blih", date: new Date(), userId: 2 },
  { id: 4, body: "Bloh", date: new Date(), userId: 2 },
  { id: 5, body: "Bluh", date: new Date(), userId: 3 },
];
const comments: Comment[] = [
  { id: 1, body: "No", date: new Date(), postId: 1, userId: 2 },
  { id: 2, body: "Yes", date: new Date(), postId: 1, userId: 3 },
  { id: 3, body: "Yes!", date: new Date(), postId: 1, userId: 1 },
  { id: 4, body: "No!", date: new Date(), postId: 2, userId: 3 },
];

const App = () =&gt; {
  store.subscribe(() =&gt; {
    console.log("New state", store.getState());
  });

  console.log("Loading users");
  store.dispatch(
    userActions.loadUsersAction({
      users,
    })
  );
  console.log("Loading posts");
  store.dispatch(
    postActions.loadPostsAction({
      posts,
    })
  );
  console.log("Loading comments");
  store.dispatch(
    commentActions.loadCommentsAction({
      comments,
    })
  );
  console.log("Loading friends");
  store.dispatch(
    friendsActions.loadFriendsAction({
      userIds: [2, 3],
    })
  );
  console.log("Loading wall posts");
  store.dispatch(
    wallActions.loadWallPostsAction({
      postIds: [1, 2, 3, 4, 5],
    })
  );
  console.log("Loading Emily's posts");
  store.dispatch(
    friendWallActions.loadFriendWallPostsAction({
      postIds: [3, 4],
      userId: 2,
    })
  );

  return (
    &lt;div className="App"&gt;
      &lt;div&gt;Store contents&lt;/div&gt;
      &lt;div&gt;
        &lt;pre&gt;{JSON.stringify(store.getState(), null, 2)}&lt;/pre&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  );
};

export default App;
</code></pre>
<p>Si ejecutamos la aplicación, podemos seguir en la consola cómo la store despacha acciones y el resultado en la página generada. También podemos seguir los pasos, las actualizaciones parciales y el resultado en la extensión React DevTools.</p>
<p><img src="/img/blog/2021-01_redux-normalized-store-part-2/redux-dev-tools.png" alt="Redux DevTools Extension" /></p>
<p>Si deseas profundizar más en el código, recuerda que puedes consultar todo el código fuente en esta rama:</p>
<p><a href="https://github.com/jguix/redux-normalized-example/tree/blogpost-part2">https://github.com/jguix/redux-normalized-example/tree/blogpost-part2</a></p>
<p>En la próxima publicación implementaremos las páginas y componentes y un backend simulado con paginación. También implementaremos métodos de almacenamiento en caché para evitar pedir los mismos datos una y otra vez.</p>
<h2 id="credits">Credits</h2>
<p>Fotografía por <a href="https://unsplash.com/@sigmund">Sigmund</a> on <a href="https://unsplash.com/">Unsplash</a>.</p>]]></description><link>https://juanguijordan.com/blog/2021-01_redux-normalized-store-part-2</link><guid isPermaLink="true">https://juanguijordan.com/blog/2021-01_redux-normalized-store-part-2</guid><category><![CDATA[javascript]]></category><category><![CDATA[frontend]]></category><dc:creator><![CDATA[Juangui Jordán]]></dc:creator><pubDate>Tue, 26 Jan 2021 08:00:00 GMT</pubDate></item><item><title><![CDATA[Usando redux con datos relacionales (1/3)]]></title><description><![CDATA[<h2 id="parte1modelandolastorederedux">Parte 1. Modelando la store de redux</h2>
<p>En esta serie de posts crearemos una aplicación usando <strong>react</strong> y <strong>redux</strong>, en la que manejaremos datos relacionales. En esta primera parte modelaremos la store.</p>
<p>A menudo, los tutoriales sobre redux son demasiado simples y manejan una estructura de datos plana. Es el caso de la típica app de TODOs (lista de tareas), o una lista de la compra, etc. En estos casos solemos tener unos pocos reducers, los cuales son independientes entre sí.</p>
<p>Por ejemplo:</p>
<ul>
<li>La lista de TODOs, incluyendo el estado de cada tarea.</li>
<li>El valor de un filtro de mostrar/ocultar, por ejemplo, "ocultar completas".</li>
<li>El valor de un filtro de orden, por ejemplo, "ordenar por fecha de creación ascendente".</li>
</ul>
<p>En un caso así de simple, la store no tiene que manejar relaciones, y se puede representar en un objeto similar a este:</p>
<pre><code class="json language-json">{
  "todos": [
    {
      "id": 1,
      "completed": true,
      "creationDate": "2020-08-07",
      "description": "Create github repo"
    },
    {
      "id": 2,
      "completed": false,
      "creationDate": "2020-08-11",
      "description": "Finish part 1 of this post"
    },
    {
      "id": 3,
      "completed": false,
      "creationDate": "2020-08-12",
      "description": "Create part 2"
    }
  ],
  "filterBy": "completed",
  "orderBy": "date-asc"
}
</code></pre>
<p>Sin embargo, las aplicaciones reales suelen ser más complejas. Algunos datos dependen de otros y existen jerarquías: relaciones uno a uno, uno a muchos y muchos a muchos. Esto nos va a presentar varios retos, tanto en la representación del estado en la store, como en la eficiencia de la comunicación con el backend.</p>
<p>Para ilustrarlo, usaremos el ejemplo de una red social. Las entidades principales que manejaremos son usuarios, posts y comentarios. Los usuarios podrán crear posts, y los posts podrán contener comentarios de otros usuarios. Simple, ¿verdad?</p>
<p>Veamos en primer lugar algunos de los diseños de nuestra red social, para modelar estos datos.</p>
<p>La página inicial de nuestra red social será <strong>Mi Muro</strong>, la página donde aparecen mis posts y los de todos mis amigos, con sus respectivos comentarios.</p>
<p><img src="/img/blog/2020-08_redux-normalized-store-part-1/my_wall.png" alt="My Wall" /></p>
<p>También habrá una página de <strong>Amigos</strong>, donde se listan los usuarios que son contactos directos míos.</p>
<p><img src="/img/blog/2020-08_redux-normalized-store-part-1/my_friends.png" alt="My Friends" /></p>
<p>Desde esta página, si pulso sobre uno de mis amigos visitaré el <strong>Muro del amigo</strong>, esto es, una página donde aparecerán sus posts, junto con los comentarios de otros usuarios.</p>
<p><img src="/img/blog/2020-08_redux-normalized-store-part-1/friend.png" alt="Friend Page" /></p>
<p>Cada post incluirá el avatar y nombre del usuario, y la fecha. Cada comentario incluirá también el avatar, nombre del usuario y la fecha.</p>
<p><img src="/img/blog/2020-08_redux-normalized-store-part-1/post_and_comments.png" alt="Posts and comments" /></p>
<p>Sin entrar en las relaciones o jerarquías, podemos definir los tipos de las entidades como usuario (<code>User</code>), post (<code>Post</code>) y comentario (<code>Comment</code>):</p>
<pre><code class="typescript language-typescript">// user.types.ts
export type User = {
  avatar: string;
  email: string;
  id: number;
  name: string;
};

// post.types.ts
export type Post = {
  body: string;
  date: Date;
  id: number;
};

// comment.types.ts
export type Comment = {
  body: string;
  date: Date;
  id: number;
};
</code></pre>
<p>Una representación extremadamente simple, basada en la aplicación de los TODOs, consiste en tener un reducer por cada tipo de entidad:</p>
<pre><code class="json language-json">{
  users: [
    { id: 1, name: "Josh", email: "josh@gmail.com", avatar: "josh.jpg" },
    { id: 2, name: "Anne", email: "anne@gmail.com", avatar: "anne.jpg" },
    { id: 3, name: "Mike", email: "mike@gmail.com", avatar: "mike.jpg" },
  ],
  posts: [
    {
      id: 1,
      body: "hi all",
      date: "2020-08-01",
      user: { id: 2, name: "Anne", email: "anne@gmail.com", avatar: "anne.jpg" },
    }
  ],
  comments: [
    {
      {
        id: 1,
        body: "hello!",
        date: "2020-08-02",
        user: { id: 1, name: "Josh", email: "josh@gmail.com", avatar: "josh.jpg" },
      },
      {
        id: 2,
        body: "hi there!",
        date: "2020-08-02",
        user: { id: 3, name: "Mike", email: "mike@gmail.com", avatar: "mike.jpg" },
      },
    }
  ],
}
</code></pre>
<p>Si entro en la página de <strong>Friends</strong> la store almacena los amigos en <code>users</code>; si entro en la página de un amigo la store almacena los posts en <code>posts</code>, y si muestro un post, los comentarios se almacenan en <code>comments</code>.</p>
<p>Esta estrategia me va a obligar a traerme todos los posts del backend cada vez que cambie al muro de un amigo distinto, y además no va a funcionar porque en las páginas de <strong>Amigo</strong> y <strong>Mi muro</strong> debo mostrar varios posts a la vez, donde cada post tiene distintos comentarios. Según la store diseñada arriba, todos los posts visualizados mostrarían siempre los mismos comentarios.</p>
<p>Para evitar este problema podríamos anidar los comentarios dentro de los posts, así:</p>
<pre><code class="json language-json">{
  users: [
    { id: 1, name: "Josh", email: "josh@gmail.com", avatar: "josh.jpg" },
    { id: 2, name: "Anne", email: "anne@gmail.com", avatar: "anne.jpg" },
    { id: 3, name: "Mike", email: "mike@gmail.com", avatar: "mike.jpg" },
  ],
  posts: [
    {
      id: 1,
      body: "hi all",
      date: "2020-08-01",
      user: { id: 2, name: "Anne", email: "anne@gmail.com", avatar: "anne.jpg" },
      comments: [
        {
          {
            id: 1,
            body: "hello!",
            date: "2020-08-02",
            user: { id: 1, name: "Josh", email: "josh@gmail.com", avatar: "josh.jpg" },
          },
          {
            id: 2,
            body: "hi there!",
            date: "2020-08-02",
            user: { id: 3, name: "Mike", email: "mike@gmail.com", avatar: "mike.jpg" },
          },
        }
      ],
    }
  ],
}
</code></pre>
<p>Sin embargo, todavía tenemos varios problemas. No estamos cacheando datos, por ejemplo, si navego de un amigo a otro y vuelvo al primero, tendré que cargar de nuevo todos los posts y comments del backend. También hay muchos datos replicados, como los usuarios, ocupando más espacio del necesario.</p>
<p>Lo ideal sería normalizar la store, como se recomienda en la <a href="https://redux.js.org/recipes/structuring-reducers/normalizing-state-shape">documentación de redux</a>. Podríamos pensar algo así, donde a cada entidad hemos añadido uno o varios ids (<code>userId</code>, <code>postId</code>) que apuntan a las entidades con las que está relacionada:</p>
<pre><code class="json language-json">{
  users: [
    { id: 1, name: "Josh", email: "josh@gmail.com", avatar: "josh.jpg" },
    { id: 2, name: "Anne", email: "anne@gmail.com", avatar: "anne.jpg" },
    { id: 3, name: "Mike", email: "mike@gmail.com", avatar: "mike.jpg" },
  ],
  posts: [
    {
      id: 1,
      body: "hi all",
      date: "2020-08-01",
      userId: 2,
    }
  ],
  comments: [
    {
      {
        id: 1,
        body: "hello!",
        date: "2020-08-02",
        postId: 1,
        userId: 1,
      },
      {
        id: 2,
        body: "hi there!",
        date: "2020-08-02",
        postId: 1,
        userId: 3,
      },
    }
  ],
}
</code></pre>
<p>De esta forma aplanamos la store y evitamos los datos replicados. Sin embargo, la búsqueda por id del usuario asociado a cada post o comentario, y la búsqueda de todos los comentarios asociados a un post no va a ser nada óptima, ya que nos va a obligar a recorrer todos los usuarios o comentarios y filtrar por id. Cuando la store crezca durante una sesión, este proceso se va a volver más y más lento e impactará a la experiencia de usuario.</p>
<p>Podemos mejorar esto indexando cada dato, como se sugiere en la documentación de redux.</p>
<pre><code class="json language-json">{
  "users": {
    "byId": {
      "1": {
        "id": 1,
        "name": "Josh",
        "email": "josh@gmail.com",
        "avatar": "josh.jpg"
      },
      "2": {
        "id": 2,
        "name": "Anne",
        "email": "anne@gmail.com",
        "avatar": "anne.jpg"
      },
      "3": {
        "id": 3,
        "name": "Mike",
        "email": "mike@gmail.com",
        "avatar": "mike.jpg"
      }
    }
  },
  "posts": {
    "byId": {
      "1": {
        "id": 1,
        "body": "hi all",
        "date": "2020-08-01",
        "userId": 2
      }
    }
  },
  "comments": {
    "byId": {
      "1": {
        "id": 1,
        "body": "hello!",
        "date": "2020-08-02",
        "postId": 1,
        "userId": 1
      },
      "2": {
        "id": 2,
        "body": "hi there!",
        "date": "2020-08-02",
        "postId": 1,
        "userId": 3
      }
    }
  }
}
</code></pre>
<p>Ahora es mucho más sencillo y rápido buscar el <code>user</code> asociado a un <code>post</code> o un <code>comment</code>. Sin embargo, sigue siendo complejo obtener la lista de <code>posts</code> por <code>user</code>, o la lista de <code>comments</code> por <code>post</code>. De hecho, ahora es más difícil e ineficiente filtrar estos datos.</p>
<p>Vamos pues a crear estructuras relacionales que nos indiquen qué posts pertenecen a cada usuario (uno a muchos), y qué comentarios a cada post.</p>
<pre><code class="json language-json">{
  users: {
    byId: {
      1: { id: 1, name: "Josh", email: "josh@gmail.com", avatar: "josh.jpg" },
      2: { id: 2, name: "Anne", email: "anne@gmail.com", avatar: "anne.jpg" },
      3: { id: 3, name: "Mike", email: "mike@gmail.com", avatar: "mike.jpg" },
    },
    postIdsById: {
      2: [ 1 ],
    }
  },
  posts: {
    byId: {
      1: {
        id: 1,
        body: "hi all",
        date: "2020-08-01",
        userId: 2,
      }
    },
    commentIdsById: :{
      1:[ 1, 2],
    }
  },
  comments: {
    byId: {
      1: {
        id: 1,
        body: "hello!",
        date: "2020-08-02",
        postId: 1,
        userId: 1,
      },
      2: {
        id: 2,
        body: "hi there!",
        date: "2020-08-02",
        postId: 1,
        userId: 3,
      },
    }
  },
}
</code></pre>
<p>La lectura del reducer <code>postIdsById</code> sería <em>"el usuario con id 2 tiene el post con id 1"</em>. La lectura de <code>commentIdsById</code> sería <em>"el post con id 1 tiene los comentarios con ids 1 y 2"</em>. Ahora ya tenemos todo indexado y la estructura de base de datos está totalmente normalizada.</p>
<p>Únicamente nos faltan estructuras que nos permitan almacenar los ids de los posts que serán visibles en cada muro, ya sea el del usuario o el de sus amigos, así como los ids de los usuarios que deben aparecer en la página de amigos. Incluiremos en la página de amigos un filtro para ordenar alfabéticamente de forma ascendente o descendente.</p>
<p>Para separar las estructuras que modelan entidades que pertenecen a la base de datos, de las estructuras que modelan elementos de la interfaz de usuario, crearemos 2 reducers de mayor nivel, uno llamado <code>entities</code> donde almacenaremos <strong>entidades de la base de datos</strong>, y otro llamado <code>ui</code> donde almacenaremos todos los <strong>elementos de la interfaz de usuario</strong>.</p>
<p>Este es finalmente el modelo de la store, que evita la replicación de datos, facilita la búsqueda gracias a la indexación, y nos va a permitir cachear los datos ya cargados, ya que las estructuras asociadas a la interfaz de usuario solo almacenan ids, y cualquier entidad ya descargada del backend va a permanecer en la store hasta que borremos la caché del navegador.</p>
<pre><code class="json language-json">{
  entities: {
    users: {
      byId: {
        1: { id: 1, name: "Josh", email: "josh@gmail.com", avatar: "josh.jpg" },
        2: { id: 2, name: "Anne", email: "anne@gmail.com", avatar: "anne.jpg" },
        3: { id: 3, name: "Mike", email: "mike@gmail.com", avatar: "mike.jpg" },
      },
      postIdsById: {
        2: [ 1 ],
      },
    },
    posts: {
      byId: {
        1: {
          id: 1,
          body: "hi all",
          date: "2020-08-01",
          userId: 2,
        },
      },
      commentIdsById: :{
        1: [ 1, 2 ],
      },
    },
    comments: {
      byId: {
        1: {
          id: 1,
          body: "hello!",
          date: "2020-08-02",
          postId: 1,
          userId: 1,
        },
        2: {
          id: 2,
          body: "hi there!",
          date: "2020-08-02",
          postId: 1,
          userId: 3,
        },
      },
    },
  },
  ui: {
    friends: {
      orderFilter: "asc",
      userIds: [ 2, 3 ],
    },
    friendWall: {
      postIdsById: {
        2: [ 1 ],
      },
    },
    wall: {
      postIds: [ 1 ],
    },
  },
}
</code></pre>
<p>En próximos posts veremos la implementación de esta store y los métodos de cacheado.</p>
<h2 id="credits">Credits</h2>
<p>Fotografía por <a href="https://unsplash.com/@jeremybishop">Jeremy Bishop</a> en <a href="https://unsplash.com/">Unsplash</a>.</p>]]></description><link>https://juanguijordan.com/blog/2020-08_redux-normalized-store-part-1</link><guid isPermaLink="true">https://juanguijordan.com/blog/2020-08_redux-normalized-store-part-1</guid><category><![CDATA[javascript]]></category><category><![CDATA[frontend]]></category><dc:creator><![CDATA[Juangui Jordán]]></dc:creator><pubDate>Tue, 03 Nov 2020 08:00:00 GMT</pubDate></item><item><title><![CDATA[Creando una extensión de Chrome]]></title><description><![CDATA[<p>En este post, te mostraré cómo crear una simple <a href="https://chrome.google.com/webstore/category/extensions">Chrome extension</a>. Resumiré lo que una extensión de Chrome puede hacer, y también voy a explicar cómo crear extensiones más complejas basadas en JavaScript, React, Angular o Vue.</p>
<p>¿Qué es una extensión de Chrome? Las extensiones de Google Chrome son como pequeñas aplicaciones que viven en tu navegador, basadas en tecnologías web estándar, como HTML, CSS y JavaScript. Aprovechan algunas API de Chrome, proporcionando las bases para construir una aplicación, como el almacenamiento y la mensajería. Las extensiones de Google Chrome pueden interactuar con las páginas web abiertas en las pestañas de tu navegador, pero en realidad no están pensadas para ello. Pueden "vivir" por sí solas y proporcionar cualquier tipo de funcionalidad, más allá de la experiencia de navegación. Puedes crear cualquier cosa, desde una agenda, pasando por un temporizador pomodoro, hasta un web image scrapper. Puedes pensar en Chrome como la plataforma Electron, proporcionando una base para construir aplicaciones JavaScript que pueden interactuar con la experiencia de navegación.</p>
<p>Las extensiones de Chrome pueden permanecer inactivas hasta que algún trigger las despierte, haciendo que se inyecte algún contenido o script, se ejecute o se muestre algún popup. Estos scripts viven en algo llamado "Mundos Aislados" en relación con las páginas web que se están navegando, lo que significa que una extensión de Chrome sólo puede compartir el DOM con una página en particular, pero no las variables o funciones del script. Por lo tanto, las extensiones de Chrome pueden modificar el DOM, inyectar scripts CSS o JavaScript adicionales que interactúan con el mismo DOM, pero no pueden modificar directamente la página original CSS o JavaScript. Por otro lado, las extensiones pueden comunicarse con la página a través de mensajes, por lo que puede crear una página que interactúe con una extensión de Chrome.</p>
<h2 id="capacidadesdelaextensin">Capacidades de la extensión</h2>
<p>Este es un resumen incompleto de lo que puede hacer una extensión:</p>
<ul>
<li><strong>Mostrar un icono</strong>. El icono de la extensión puede ser modificado en tiempo de ejecución, o mostrar una insignia sobre él, con un fondo de color y un texto de 4 letras en él.</li>
<li><strong>Mostrar un popup</strong>. Al hacer clic en el icono de la extensión se puede activar un popup con contenido.</li>
<li><strong>Mostrar un menú secundario</strong>. Haciendo clic con el botón derecho del ratón en el icono de la extensión puede activar un menú secundario.</li>
<li><strong>Responder a atajos de teclado</strong>. Los atajos de teclado pueden asociarse a las acciones de extensión (CTRL+SHIFT+V).</li>
<li><strong>Responder a acciones de la barra de direcciones</strong> (la así llamada omnibox). Los atajos de texto pueden usarse en la omnibox para activar acciones en la extensión (p.ej. “myext+<TAB>").</li>
<li><strong>Responder a la visita a cierta página web</strong>. Por ejemplo, modificar el estado del icono o el contenido de la ventana emergente
Modifica el contenido de un sitio web. Por ejemplo, modificar el DOM por un script de contenido o aplicar archivos CSS adicionales.</li>
<li><strong>Tener una página de opciones</strong> para la configuración de la extensión.</li>
<li><strong>Reemplazar la página de Historial, Favoritos o Nueva Pestaña</strong> de Google Chrome.</li>
<li><strong>Intercambiar mensajes</strong> con un sitio web o consigo mismo. Una extensión puede utilizar la mensajería para hablar con alguna página web que se esté navegando, o para comunicarse entre partes de la propia extensión.</li>
<li><strong>Almacenar información</strong> en el almacenamiento local, el almacenamiento Chrome (almacenamiento que se sincroniza a través de diferentes dispositivos donde el usuario está conectado) o cualquier almacenamiento nativo de JS, por ejemplo sessionStoragef.</li>
<li><strong>Mostrar notificaciones</strong> como un "toast".</li>
<li><strong>Usar varias APIs proporcionadas por Google Chrome</strong>.</li>
<li><strong>Ser gratis, o de pago</strong>. Al crear una extensión de pago, puedes elegir usar la tienda Chrome o tus propios medios de pago.</li>
</ul>
<h2 id="lobsico">Lo básico</h2>
<p>El único archivo obligatorio de una extensión de Chrome es el manifiesto. Debe estar colocado en el directorio raíz, y comunica los metadatos de la extensión, los permisos y otros archivos involucrados.</p>
<p>El formato del manifiesto tiene un montón de opciones, que se pueden ver en esta página (https://developer.chrome.com/extensions/manifest), pero nos centraremos en los más importantes. Presentemos el manifiesto de la extensión "Cat detector":</p>
<pre><code class="json language-json">{
  "name": "Cat detector",
  "description": "Spots cats in the page you are browsing",
  "manifest_version": 2,
  "version": "1.0",
  "background": {
    "persistent": false,
    "scripts": ["background.js"]
  },
  "content_scripts": [
    {
      "matches": ["&lt;all_urls&gt;"],
      "js": ["content.js"]
    }
  ],
  "browser_action": {
    "default_popup": "popup.html"
  },
  "icons": {
    "16": "images/footprint-16.png",
    "32": "images/footprint-32.png",
    "48": "images/footprint-48.png",
    "128": "images/footprint-128.png"
  },
  "permissions": ["activeTab"]
}
</code></pre>
<p>El manifiesto declara algunas capacidades que serán utilizadas por la extensión:</p>
<ul>
<li>Declara un background script. Los background scripts pueden activarse en cualquier momento, pero no tienen acceso directo al contenido de los tabs.</li>
<li>Declara un content script. Los scripts de contenido se implementan en la misma página en la que se está navegando y tienen acceso al contenido. Una expresión de coincidencia es usada para determinar cuándo el script es inyectado. En este caso elegimos <code>&lt;all urls&gt;</code>, lo que significa que se implementa en cualquier página web.</li>
<li>Declara una acción del navegador, es decir, una extensión que es capaz de funcionar independientemente de la página por la que se está navegando. Si quisiéramos crear una extensión que sólo se activa cuando se cumplen algunas condiciones en la página que se está navegando, utilizaríamos una "page action". La razón por la que elegimos la acción de navegación es que los gatos se pueden ver casi en todas partes en Internet. Una segunda razón es que queremos mostrar un badge sobre el icono de la extensión, y eso sólo es posible usando una acción del navegador.</li>
<li>Dentro de la acción del navegador, declara un popup que se abrirá al hacer clic en el icono de la extensión.</li>
<li>Declara los iconos. Los más pequeños se utilizan para el icono del navegador, dependiendo de la resolución de la pantalla, y los más grandes se usan en el menú de extensiones de Chrome y el Chrome Store.</li>
</ul>
<h2 id="nuestraextensindeejemplo">Nuestra extensión de ejemplo</h2>
<p>Vamos al grano de este post: esta page action utiliza un background script que, al cargar la página, envía un mensaje al content script, que a su vez cuenta el número de veces que las palabras "cat", "kitten" o "kitty" aparecen en nuestra página. Después de recibir una respuesta, la tarea de background muestra un badge sobre el icono para comunicar el número de gatitos que aparecen. Al hacer clic en el icono de la extensión, se mostrará un popup con una imagen de un gatito feliz junto con el contador.</p>
<p>Echemos un vistazo a la estructura de los archivos de extensión:</p>
<pre><code>-audios
 |-meow_0.mp3
 |-meow_1.mp3
 |-meow_2.mp3
 |-meow_3.mp3
 |-meow_4.mp3
 |-meow_5.mp3
 |-meow_6.mp3
-images
 |-footprint-16.png
 |-footprint-32.png
 |-footprint-48.png
 |-footprint-128.png
-background.js
-content.js
-manifest.js
-popup.html
-popup.js
</code></pre>
<p>Incluye los iconos de extensión, algunos archivos de audio, el manifiesto, el background script, el content script y los archivos del popup html y js.</p>
<p>Así queda el background script. Se han incluido comentarios para señalar las cosas importantes:</p>
<pre><code>const maxMeows = 6;

// The extension listens to the onUpdated event, and executes when the page is loaded
chrome.tabs.onUpdated.addListener((tabId, changeInfo, tab) =&gt; {
  if (changeInfo.status === "complete" &amp;&amp; tab.active) {
    detectCats(tabId);
  }
});

// It executes the cat detection as well when we switch tabs on the active tab
chrome.tabs.onActivated.addListener((activeTab) =&gt; detectCats(activeTab.tabId));

const detectCats = (tabId) =&gt; {
  // Here we clear the badge
  chrome.browserAction.setBadgeText({ text: "" });
  // Then we send a message to the content script, together with a callback
  chrome.tabs.sendMessage(tabId, { text: "cat_count" }, onCatCount);
};

// This is the callback called by the content script
const onCatCount = (catNumber) =&gt; {
  if (!catNumber) {
    deactivateIcon();
  } else {
    // When cats are detected, show an animation on the badge
    animateBadge(catNumber);
  }
};

const deactivateIcon = () =&gt; {
  // Here we detect what the active tab is and disable the action
  chrome.tabs.query({ active: true, currentWindow: true }, (activeTab) =&gt; {
    chrome.browserAction.disable(activeTab[0].id);
  });
};

const animateBadge = (catNumber) =&gt; {
  // Limit meows, we don't want 1000 sounds to be played
  let i = catNumber - maxMeows &gt; 0 ? catNumber - maxMeows : 1;
  let j = 0;
  // Cats will meow at random times
  for (; i &lt;= catNumber - 1; i++, j++) {
    updateBadge(i, j * Math.random() * 400);
  }
  // Last cat should come last, let's give it the highest delay
  updateBadge(catNumber, j * 500);
};

const updateBadge = (catIndex, delay) =&gt; {
  // After some specified delay display a number on the badge and play a meow sound
  setTimeout(() =&gt; {
    (
      new Audio(chrome.runtime.getURL(`audios/meow_${catIndex % 7}.mp3`))
    ).play();
    chrome.browserAction.setBadgeText({ text: catIndex.toString() });
  }, delay);
};
</code></pre>
<p>El content script básicamente recibe el mensaje <code>cat_count</code> y responde a él. Se ha incluido algo de lógica para contar los gatos con una expresión regex:</p>
<pre><code>chrome.runtime.onMessage.addListener((msg, sender, sendResponse) =&gt; {
  if (msg.text === "cat_count") {
    sendResponse(countCats());
  }
});

const countCats = () =&gt; {
  var content =
    document.body["innerText" in document.body ? "innerText" : "textContent"];
  content = removeScriptsFromContent(content);
  var regex = /(cat|cats|kitten|kittens|kitty|kitties)[\s.,]/gi;

  return content.match(regex)?.length || 0;
};

const removeScriptsFromContent = (strCode) =&gt; {
  return strCode.replace(/&lt;script.*?&gt;.*?&lt;\/script&gt;/gim, "");
};
</code></pre>
<p>El archivo html del popup simplemente muestra una imagen y declara el fichero javascript:</p>
<pre><code>&lt;html&gt;
  &lt;body&gt;
    &lt;img id="cat_image" /&gt;
    &lt;script src="popup.js"&gt;&lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>El archivo js ejecuta una función en la carga que a su vez envía un mensaje al content script para contar gatos de nuevo. Esto se debe a que los popups no "viven" hasta que se abren, así que si hay que hacer alguna actualización en el popup, es el popup el que debe iniciar la acción:</p>
<pre><code>window.onload = () =&gt; {
  chrome.tabs.query({ active: true, currentWindow: true }, (activeTab) =&gt; {
    const tabId = activeTab[0].id;
    chrome.tabs.sendMessage(tabId, { text: "cat_count" }, onCatCount);
  });
};

const onCatCount = (catNumber) =&gt; {
  document.getElementById(
    "cat_image"
  ).src = `https://cataas.com/c/s/${catNumber}%20happy%20cats%20detected?t=sq&amp;width=350`;
};
</code></pre>
<p>ChanChanChan, este es el resultado de la extensión del detector de gatos en acción:</p>
<p><img src="/img/blog/2020-05_creating-a-chrome-extension/cat_extension.png" alt="Cat extension" /></p>
<h2 id="probandolocalmentenuestraextensin">Probando localmente nuestra extensión</h2>
<p>Si quieres probar tu extensión en tu máquina local, sólo tienes que ir al menu item More Tools —&gt; Extensions, luego hacer click en Load Unpacked, y seleccionar la carpeta donde está tu manifiesto y el resto de los archivos.</p>
<p><img src="/img/blog/2020-05_creating-a-chrome-extension/load_extension.png" alt="Loading the extension for testing" /></p>
<h2 id="debugging">Debugging</h2>
<p>El proceso de debugging se vuelve particularmente compleja ya que cada extensión debe ser inspeccionada de manera diferente.</p>
<p>En cuanto a los background scripts, se inspeccionan en las extensiones. Para abrir las herramientas de desarrollo es necesario hacer clic en el enlace "página en segundo plano" en los detalles de la extensión.</p>
<p><img src="/img/blog/2020-05_creating-a-chrome-extension/extension_info.png" alt="Opening the extension dev tools" /></p>
<p>Los content scripts se inspeccionan en la página web que estás navegando, ya que se inyectan en la página. Se muestran en una pestaña de <strong>Content Scripts</strong>.</p>
<p><img src="/img/blog/2020-05_creating-a-chrome-extension/debugging_content_scripts.png" alt="Debugging content scripts" /></p>
<p>No pude encontrar la forma de inspeccionar los popup scripts, incluso los logs de la consola se perdían en algún lugar, así que mostrar una alerta fue la única forma de comprobar que el popup estaba "vivo" y activo.</p>
<h2 id="publicandolaextensin">Publicando la extensión</h2>
<p>Para publicar una extensión de Google Chrome es necesario registrarse como desarrollador de Chrome, pagar 5 dólares y rellenar algunos datos sobre el nombre de la extensión, la descripción y las imágenes o vídeos. El proceso es muy similar al que se sigue para publicar una aplicación en Google Play. Después de enviar tu extensión para la aprobación, tienes que esperar una respuesta. Las respuestas negativas son bastante rápidas -mi primera extensión fue rechazada sin razón alguna, y tuve que enviar un correo electrónico para pedir una revisión humana-, las positivas pueden tardar unas horas o días.</p>
<h2 id="irmsall">Ir más allá…</h2>
<p>El sitio de desarrollo de Chrome para extensiones proporciona un gran número de extensiones de muestra. Estas son extensiones simples que abordan características muy específicas que pueden ayudar a aprender a construir extensiones.</p>
<p>https://developer.chrome.com/extensions/samples</p>
<p>Hay muchos proyectos de boilerplate por ahí para ayudarte a desarrollar extensiones más complejas usando React, Angular o Vue. Toma los siguientes enlaces como punto de partida:</p>
<ul>
<li>https://github.com/lxieyang/chrome-extension-boilerplate-react</li>
<li>https://github.com/larscom/ng-chrome-extension</li>
<li>https://github.com/Kocal/vue-web-extension</li>
</ul>
<h2 id="recap">Recap</h2>
<p>Crear extensiones de Chrome puede ser divertido, y también puedes encontrar muchos escenarios productivos para ellas. Desarrollar extensiones es fácil si conoces las tecnologías web básicas como HTML, CSS y JavaScript. Te mostramos los fundamentos de una extensión de Chrome y te guiamos en la creación de una simple extensión.</p>
<p>Si quiere comprobar el código de extensión completo, ¡échale un vistazo! <a href="https://github.com/jguix/chrome-cat-detector">github repository</a>.</p>
<p>¿Puedes imaginarte algo que pueda ser entregado como una extensión de Chrome? Compártenos tu idea…</p>
<h2 id="crdits">Crédits</h2>
<p>Fotografía de Markus Winkler en <a href="https://unsplash.com/">Unsplash</a>.</p>]]></description><link>https://juanguijordan.com/blog/2020-05_creating-a-chrome-extension</link><guid isPermaLink="true">https://juanguijordan.com/blog/2020-05_creating-a-chrome-extension</guid><category><![CDATA[javascript]]></category><dc:creator><![CDATA[Juangui Jordán]]></dc:creator><pubDate>Mon, 01 Jun 2020 07:00:00 GMT</pubDate></item><item><title><![CDATA[Circular Design SPRINT]]></title><description><![CDATA[<p>En este post os cuento la experiencia de participar en un&nbsp;<strong>Design Sprint</strong>, y cómo Ecoembes utilizó la metodología Design Sprint para explorar nuevas ideas en el contexto de la economía circular y el reciclaje.</p>
<p>Para ello, reclutó mediante becas a un ecléctico grupo de profesionales, incluyendo emprendedores, profesionales del marketing, diseño, y tecnología, entre los que me encuentro. Durante 5 días en Julio de 2018, trabajamos conjuntamente en&nbsp;<a href="https://www.thecircularlab.com">The Circular Lab</a>, un espacio de innovación de Ecoembes localizado en Logroño, particularmente preparado para el trabajo creativo y colaborativo.</p>
<p><img src="/img/blog/2019-05_circular-design-sprint/the_circular_lab_1-1-1024x668.jpg" alt="The Circular Lab" /></p>
<p>La beca consistió en un curso sobre la metodología Design Sprint, durante el cual realizamos un&nbsp;<strong>SPRINT</strong>&nbsp;real para Ecoembes. Tutorizados por&nbsp;<a href="https://www.uxerschool.com">UXER School</a>, aplicamos Design Sprint al mundo del reciclaje, y en solo 5 días fuimos capaces de proponer y desarrollar ideas innovadoras que resuelven problemas en un negocio que inicialmente no conocíamos.</p>
<h2 id="resumenejecutivo">Resumen ejecutivo</h2>
<p>Este será un largo artículo, por lo cual he decidido crear un resumen para que el lector pueda entender la idea global, y ya decidir si quiere adentrarse en todos los detalles.</p>
<p><a href="https://www.gv.com/sprint"><strong>Design SPRINT</strong></a>&nbsp;–o SPRINT, a secas– es una metodología sorprendentemente productiva, que permite obtener excelentes resultados en un breve período de tiempo.</p>
<p>Se puede aplicar al desarrollo de un producto o servicio al inicio de un proyecto, pero también al desarrollo de una funcionalidad de un producto o servicio ya existente, o a la mejora de cualquier proceso. Es una metodología flexible que se ha aplicado con éxito en multitud de ámbitos.</p>
<p>Se fomenta la producción individual y la toma de decisiones colectiva. Esto hace que, por un lado, la generación de ideas sea más abierta. En el momento de pensar y producir lo hacemos en general de forma individual, con lo cual no recibimos feedback negativo que nos cohiba o nos limite. Por otro lado, la toma de decisiones es colectiva, usando una jerarquía plana, lo cual nos hace partícipes incluso de ideas que no hemos generado nosotros mismos, pero con las que nos sentimos de acuerdo.</p>
<p>En mi opinión, el éxito del proceso viene determinado por varios factores. En primer lugar, es importante conformar un equipo multidisciplinar, lo cual nos va a aportar diferentes puntos de vista en la generación de ideas. Otro aspecto importante de la metodología son los plazos cortos: la mayoría de tareas tienen un plazo muy limitado, de 5, 10 o 15 minutos, lo cual nos hace trabajar bajo presión, obligando a escoger y descartar rápidamente ideas.</p>
<p><img src="/img/blog/2019-05_circular-design-sprint/dia1-reloj.jpg" alt="The famous Time Timer helps keep activities in term" /></p>
<p>Otro aspecto importante es dejar los egos a un lado, prescindir de los superhéroes –centrarse en el trabajo colectivo en lugar de dar todo el protagonismo a los gurús o expertos– y ser capaz de renunciar a tus propias ideas –cuando el equipo decide que una idea no se va a utilizar, no debemos presionar para volver a incluirla. Para conducir el proceso, marcar las pautas, favorecer que prevalezca el espíritu colectivo y desatascar los bloqueos existe la figura del facilitador. En este caso el facilitador era Javier Larrea de UXER SCHOOL.</p>
<p>Visto en retrospectiva, el proceso se siente como un puzzle inicialmente desordenado, en el que poco a poco van encajando las piezas, de forma casi automática.</p>
<p>Por último, aclarar que&nbsp;<strong>Design Sprint</strong>&nbsp;es una metodología adaptable a cada proyecto y organización, por tanto algunos procesos realizados pueden diferir de lo que encontramos en el&nbsp;<a href="https://www.gv.com/sprint/#book">libro oficial</a>&nbsp;o lo que hayamos encontrado en otros sprints.</p>
<h2 id="designsprintdeunvistazo">Design Sprint de un vistazo</h2>
<p>Design Sprint es una metodología que se desarrolla típicamente a lo largo de 5 días.</p>
<p><img src="/img/blog/2019-05_circular-design-sprint/design-sprint-resumen.png" alt="Design SPRINT" /></p>
<h3 id="da1comprendermap">Día 1. Comprender (Map)</h3>
<p>Definimos el problema, articulando suposiciones, identificando al consumidor y logrando que todos los stakeholders estén alineados en el mismo objetivo y con la misma información.</p>
<h3 id="da2idearsketch">Día 2. Idear (Sketch)</h3>
<p>Exploramos múltiples formas de resolver el problema, sin importar si es viable o no. Esta libertad para explorar y ser creativos con la solución a menudo puede darnos conceptos e ideas muy novedosas.</p>
<h3 id="da3decidirdecide">Día 3. Decidir (Decide)</h3>
<p>Al no disponer de tiempo para prototipar todas las ideas, es necesario tener un proceso para decidir cuál es la mejor idea y cuáles debemos abandonar. A veces se escogerá una sola versión, mientras que otras se decidirá validar unas pocas alternativas.</p>
<h3 id="da4prototiparprototype">Día 4. Prototipar (Prototype)</h3>
<p>Nuestra idea es mucho más compleja que lo que podemos desarrollar en un día. Sin embargo, adoptando la mentalidad de prototipo construiremos una fachada, un prototipo de fidelidad media, lo bastante fidedigno como para que nos permita recopilar información de calidad de los tests.</p>
<h3 id="da5testeartest">Día 5. Testear (Test)</h3>
<p>¡Llegó el día! El objetivo aquí es validar (o no dar por buenas) las ideas del producto con usuarios reales, descubrir errores en el diseño de concepto, comprender a los usuarios y, en definitiva, crear un producto que las personas quieran usar.</p>
<h2 id="da1entender">Día 1. Entender</h2>
<h3 id="formacindelosequipos">Formación de los equipos</h3>
<p>Los participantes se repartieron entre 3 grupos, previamente formados por los organizadores. Cada grupo fue conformado por una mezcla de perfiles –diseñadores, marketing, emprendedores, ingenieros– y de grupos de edad diferentes.</p>
<p>Cada participante hizo una breve presentación de quién es, a qué se dedica y por qué se apuntó al Circular Design Sprint.</p>
<h3 id="desafo">Desafío</h3>
<p>El cliente nos presentó el desafío, esto es, un resultado que el cliente desea obtener. Este debía ser el foco de las soluciones a las que llegaremos en el&nbsp;<strong>SPRINT.</strong></p>
<blockquote>
  <p>Desafío Ecoembes: ¿Cómo podríamos incentivar y motivar a los ciudadanos para que reciclen mejor los envases domésticos?_</p>
</blockquote>
<p><img src="/img/blog/2019-05_circular-design-sprint/dia1-desafio.jpg" alt="Ecoembes Challenge" /></p>
<p>El desafío podía estar enfocado tanto a ciudadanos como al canal&nbsp;<em>HORECA</em>&nbsp;(HOtel, CAtering y REstaurantes).</p>
<p>Seguidamente se llevaron acabo varias actividades para entrar en contacto con el contexto del desafío: el mundo del reciclaje.</p>
<h3 id="entrevistas">Entrevistas</h3>
<p>En parejas, hicimos dos entrevistas entre los participantes, tratando de averiguar cuáles son los hábitos de consumo, conciencia medioambiental y patrones de reciclado.</p>
<h3 id="presentacindelcliente">Presentación del cliente</h3>
<p>Introducción al origen, labor y objetivos de Ecoembes, a cargo de Zacarías Torbado.</p>
<h3 id="mapadestakeholders">Mapa de Stakeholders</h3>
<p>En un gráfico con 3 círculos concéntricos debíamos colocar los stakeholders (partes implicadas) en el proceso de reciclado, de la siguiente manera:</p>
<ul>
<li>En el círculo interior se sitúan los stakeholders internos, esto es, los usuarios directos: ciudadanos o restaurantes en el caso de HORECA.</li>
<li>En el círculo intermedio los stakeholders directos, aquellos que tratan directamente con el usuario.</li>
<li>En el círculo exterior los indirectos, aquellos que no tratan directamente con el usuario.</li>
</ul>
<p><img src="/img/blog/2019-05_circular-design-sprint/dia1-stakeholders-1.jpg" alt="Sticking sticky notes on the stakeholders map" /></p>
<p>Cada participante debía disponer postits con los stakeholders que se le ocurrieran, sin discutirlo con los demás. En este paso debía prevalecer la cantidad, sin importar que dos postits dijeran casi lo mismo. Aproximadamente 10 minutos.</p>
<p><img src="/img/blog/2019-05_circular-design-sprint/dia1-stakeholders-2.jpg" alt="Stakeholders map" /></p>
<h3 id="contexto">Contexto</h3>
<p>Momento en que los expertos del lado del cliente ayudan a entender el contexto del problema a resolver. Se realizaron tres presentaciones a cargo de Ecoembes, en las cuales se nos explicó el funcionamiento de las plantas de separación de residuos, e investigaciones previas en España y otros países sobre mejoras en el proceso de recogida, separación de residuos y reciclaje (pago por generación, incentivo al reciclado, trazado de bolsas mediante RFID, smartag, NFC, etc.)</p>
<h3 id="revisindestakeholders">Revisión de stakeholders</h3>
<p>Tras conocer el contexto se revisó el mapa de stakeholders, pudiendo añadir los que se considera que faltan. Después se agruparon por tipo, disponiéndolos de forma radial, dividiendo los círculos como si fuera un queso.</p>
<h3 id="howmightwe">How Might We</h3>
<p>Esta es una actividad muy importante en el primer día del&nbsp;<strong>SPRINT</strong>. Vamos a comenzar la exploración de ideas de forma abierta. Cada participante debe formular, en postits, preguntas del estilo “How Might We…?”, esto es, cómo podríamos mejorar esto o aquello, motivar a los usuarios a realizar tal o cual cosa… De nuevo sin interferir y valorando la cantidad por encima de la calidad.</p>
<p>Se disponen en un papel grande y se van ordenando y agrupando verticalmente por afinidad.</p>
<p><img src="/img/blog/2019-05_circular-design-sprint/dia1-hmw-1.jpg" alt="How Might We…?" /></p>
<p>Después, se crean categorías y se colocan debajo los postits similares, donde juntamos uno encima de otro los que coincidan exactamente. Una vez agrupados, tenemos una idea de las preguntas que más se repiten y los temas a los que hemos dado más importancia. Cada persona tiene 3 votos en forma de pegatinas. Los votos se colocan en el tablero a la vez, con el fin de no influenciar a los demás.</p>
<p><img src="/img/blog/2019-05_circular-design-sprint/dia1-hmw-3.jpg" alt="How Might We by categories" /></p>
<p>Los postits que han obtenido votos se pasan al mapa de stakeholders, colocándolos en el cuadrante que corresponda, según las categorías creadas.</p>
<p><img src="/img/blog/2019-05_circular-design-sprint/dia1-stakeholders-3.jpg" alt="Stakeholders map + How Might We" /></p>
<p>Tras la ordenación de los stakeholders, se decidió sobre qué tipo de usuario y stakeholders íbamos a trabajar. En mi grupo seleccionamos el canal HORECA (HOteles, REstaurantes y CAtering), y el cuadrante que denominamos GENERADORES de residuos.</p>
<h3 id="entrevistasausuarios">Entrevistas a usuarios</h3>
<p>Se preparó un guion de entrevistas para los usuarios. Estas entrevistas nos debían permitir validar nuestras primeras hipótesis.</p>
<p>Estas hipótesis incluían el tipo de usuario promedio al que pretendíamos dar servicio, que decidimos que sería&nbsp;<strong>restaurantes de entre 2 y 6 empleados que tuvieran problemas para reciclar envases, por falta de motivación, tiempo o espacio</strong>. El objetivo es no dirigir la entrevista, ni tratar de venderles una solución, sino averiguar sus motivaciones y frustraciones relacionados con el reciclaje de envases domésticos. Finalmente se puede hacer alguna pregunta sobre la solución que tenemos en mente. La entrevista no debería tomar más de 10 minutos.Por la tarde realizamos las entrevistas propiamente dichas, en la calle o por Skype/teléfono.</p>
<p>Cada participante hizo 1-2 entrevistas, siendo el objetivo un total de 6 o más, número que ya se considera representativo. Entre estos 6 normalmente habrá 3-4 usuarios promedio, 1 extremo por arriba (restaurantes grandes) y 1 extremo por debajo (bares con un solo empleado).</p>
<h2 id="da2divergir">Día 2. Divergir</h2>
<h3 id="generarnbsppersona">Generar&nbsp;<em>persona</em></h3>
<p>El primer ejercicio fue recopilar y sintetizar la información de las entrevistas del día anterior. La herramienta utilizada fue una hoja Excel, donde se recopilaron todas las respuestas de cada uno de los usuarios, clasificándolas y buscando patrones. Finalmente se identificaron las frustraciones del usuario, sus motivaciones y los verbatim (frases literales cargadas de emociones, rabia, ira, etc., ideas con fuerza).</p>
<p>Dicha información se pasó a una matriz de síntesis, ordenando las frases y patrones más repetidos en:</p>
<ul>
<li>Patrones de comportamiento.</li>
<li>Motivaciones (Gains).</li>
<li>Frustraciones (Pains).</li>
<li>Verbatims.</li>
</ul>
<p>Tras detectar los patrones que más se repiten se genera la persona, que tendrá la siguiente estructura:</p>
<ul>
<li>Nombre y datos demográficos básicos.</li>
<li>Historia.</li>
<li>Necesidad.</li>
<li>Razón.</li>
</ul>
<p>El modelo debería ser parecido a esta frase:</p>
<blockquote>
  <p>Mario Kempes es un jefe de cocina de 35 años que trabaja en un bar que tiene 3 empleados. Recicla aceite y vidrio porque se lo pagan y se lo vienen a buscar, pero no recicla ni plásticos ni cartón por falta de incentivos económicos y espacio dentro del bar. Necesita que le paguen, le multen o le resuelvan el tema del espacio para poder reciclar más._</p>
</blockquote>
<p>Tras analizar las entrevistas, comprobamos que nuestros supuestos iniciales no fueron validados, y nuestra idea inicial -una especie de etiqueta de restaurante responsable con los residuos, que sirviera para premiar a los que más reciclan- no convencía a los dueños de locales, por lo que debíamos pivotar hacia nuevas soluciones.</p>
<h3 id="lightningdemos">Lightning demos</h3>
<p>Búsqueda de proyectos, prototipos, productos o servicios ya desarrollados o implantados, cuya idea general sea similar a la que ha escogido el equipo, como fuente de inspiración.</p>
<h3 id="brainstorming">Brainstorming</h3>
<p>Durante el tiempo estipulado (unos 10 minutos), cada miembro del equipo generó de forma individual todas las ideas que se le ocurrieron, en postits y bajo las siguientes premisas:</p>
<ul>
<li>Debe primar la cantidad sobre la calidad.</li>
<li>Debe primar lo visual sobre el texto.</li>
<li>Cada idea debe expresarse en aproximadamente 6 palabras.</li>
<li>Ideas ambiciosas.</li>
<li>No juzgar.</li>
<li>Se puede construir sobre las ideas de los demás.</li>
</ul>
<p>Una vez generadas, se leen en voz alta a los demás miembros del equipo y se aclaran dudas.</p>
<p>Seguidamente se disponen en el tablero y se ordenan.</p>
<ul>
<li>Se ponen una sobre otra aquellas que son exactamente iguales.</li>
<li>Se agrupan por temática.</li>
<li>Sobre cada grupo de postits relacionados se dispone un postit en diagonal (rombo) como título.</li>
</ul>
<p><img src="/img/blog/2019-05_circular-design-sprint/dia2-brainstorming-1.jpg" alt="Brainstorming" /></p>
<p>¡Llega el momento de votar! Cada miembro del equipo toma 3 pegatinas para votar 3 ideas diferentes. Se vota y se descartan las ideas que no han recibido ningún voto.</p>
<p><img src="/img/blog/2019-05_circular-design-sprint/dia2-brainstorming-2.jpg" alt="Voting" /></p>
<p>Entre las ideas que han recibido votos, se seleccionan unas pocas con las que vamos a trabajar, y se descarta el resto. No se tiene por qué descartar las menos votadas, aunque en principio es lo lógico, pero el grupo puede decidir incorporar alguna idea que haya recibido pocos votos pero que tenga sentido junto con el resto. Se reúnen estas ideas en el tablero, donde ya podremos visualizar el&nbsp;<em>big picture</em>&nbsp;de nuestra futura solución.</p>
<p><img src="/img/blog/2019-05_circular-design-sprint/dia2-brainstorming-4.jpg" alt="Stakeholders map + voted ideas from brainstorming" /></p>
<h3 id="crazy8">Crazy 8</h3>
<p>Cada miembro del equipo debía tomar un folio y doblarlo en 8 cuadrantes. En cada uno de estos cuadrantes debe hacer un esbozo de la solución que se va a desarrollar. Para ello, cada minuto escribirá o dibujará un cuadrante. Al final de los 8 minutos deberá tener un boceto del prototipo. Este fue mi <strong>crazy 8</strong> para la idea que conjuntamente habíamos decidido en el paso anterior.</p>
<p><img src="/img/blog/2019-05_circular-design-sprint/dia2-crazy8.jpg" alt="Crazy 8" /></p>
<h3 id="prototipoindividual">Prototipo individual</h3>
<p>Cada miembro del equipo, durante aproximadamente 1 hora, debía realizar un prototipo de la solución a desarrollar. Debía hacerlo en papel, usando una o varias hojas, con texto, diagramas, dibujos y postits. Una vez pasado el tiempo se entregó el prototipo al facilitador, que al día siguiente lo dispuso en forma de Art Museum en el tablero, para su exhibición.</p>
<h2 id="da3decidir">Día 3. Decidir</h2>
<h3 id="artmuseum">Art Museum</h3>
<p>En cada tablero de grupo se exhibieron los prototipos individuales. Los miembros del grupo leyeron cada propuesta sin conocer quién la había realizado. Una a una se desveló quién diseñó cada propuesta y se le pudieron formular preguntas para aclarar dudas. Seguidamente, cada integrante del equipo debía tomar 5 pegatinas para votar los aspectos de cada prototipo que más le gustaban. Se debe pensar primero y votar a la vez para evitar influenciar a los demás. Posteriormente, cada miembro del equipo tomó una pegatina azul más grande y emitió un voto sobre su idea preferida. También se piensa primero y se vota después, todos a la vez.</p>
<p><img src="/img/blog/2019-05_circular-design-sprint/dia3-art-museum-1.jpg" alt="Art Museum and votes" /></p>
<h3 id="pitchindividual">Pitch individual</h3>
<p>Cada integrante del equipo debía realizar la presentación de su idea al cliente, en un minuto y medio.</p>
<p><img src="/img/blog/2019-05_circular-design-sprint/dia3-pitch-1.jpg" alt="Individual pitch" /></p>
<p>Una vez presentadas todas las propuestas y después de un tiempo de reflexión, el cliente (llamado&nbsp;<strong>decisor</strong>&nbsp;en la metodología Design Sprint) señaló qué aspectos valoraba positivamente de cada propuesta e indicó mediante pegatinas amarillas cuáles eran las 2 o 3 ideas que deseaba incluir en el prototipo final.</p>
<h3 id="userjourney">User journey</h3>
<p>De forma individual, y tomando como input los puntos más votados de los prototipos y el feedback del cliente, cada integrante debía generar un user journey en 8 pasos. Utilizando 8 postits, en cada uno apuntamos una frase resumiendo un paso del user journey de nuestro producto o servicio. Conceptualmente los repartimos en 3 fases:</p>
<ul>
<li><em>Antes</em>: pasos que se dan antes de usar el producto o servicio</li>
<li><em>Durante</em>: pasos que se dan durante el uso</li>
<li><em>Después</em>: pasos que se dan después del uso</li>
</ul>
<p>Una vez trabajados los user journeys individuales, en el tablero, disponemos en 8 columnas los user journeys de todos los integrantes del equipo. Inicialmente cada user journey utilizará las 8 columnas, a lo largo de una fila. Seguidamente los ordenamos, agrupando los pasos similares o que identifican la misma acción, y poniéndolos debajo de aquel que mejor la resuma. Nos debe quedar un user journey con 8 pasos, y en cada columna solo tendremos unos pocos postits (uno o dos) para las diferentes ideas surgidas para dicho paso.</p>
<p><img src="/img/blog/2019-05_circular-design-sprint/dia3-user-journey.jpg" alt="User Journey" /></p>
<h3 id="pitchdeuserjourney">Pitch de user journey</h3>
<p>Un miembro designado por el equipo debía realizar un nuevo pitch de un minuto y medio describiendo el user journey de la idea tal y como se ha decidió en el punto anterior.</p>
<h3 id="borradordeprototipo">Borrador de prototipo</h3>
<p>Los integrantes del equipo debían trabajar en la creación de un nuevo borrador del prototipo, incorporando el feedback recibido y el user journey generado. En este punto se puede repartir el trabajo entre los miembros del equipo.</p>
<h2 id="da4prototipar">Día 4. Prototipar</h2>
<h3 id="eleccinderoles">Elección de roles</h3>
<p>El equipo debía designar varios roles para la realización del prototipo, donde una persona podía asumir varios roles:</p>
<ul>
<li><em>Diseñadores</em>: diseño gráfico de producto, presentación, landing page o mockups de aplicación.</li>
<li><em>Creadores de contenido</em>: imágenes y textos para presentación, landing pages o mockups de aplicación.</li>
<li><em>Copys</em>: textos para llamadas a la acción y otros textos creativos.</li>
<li><em>Stitcher</em>: aquel que se encarga de ensamblar las piezas y que lo que producen los demás tenga sentido en conjunto.</li>
</ul>
<h3 id="creacindelprototipo">Creación del prototipo</h3>
<p>Los integrantes del equipo debían trabajar en la creación del prototipo, de manera individual, en subgrupos o como estimaran conveniente. Finalmente el stitcher debía encargarse de la coordinación y unión de las piezas.</p>
<p>Dicho prototipo es tan solo una fachada del producto o servicio a diseñar, en ningún caso se pretende implementar un producto de manera exhaustiva, ya que el tiempo es extremadamente limitado. El objetivo de este prototipo es poder validar nuestras suposiciones mediante los tests que se realizarán el día siguiente.</p>
<p>En el caso de mi equipo, el prototipo debía mostrar un servicio de recogida de plásticos en los restaurantes. Dicho servicio incluía el uso de una app móvil, pero esta app no era la parte central de la aplicación, por lo que decidimos hacer una presentación comercial en lugar de un prototipo navegable.</p>
<p><img src="/img/blog/2019-05_circular-design-sprint/dia4-prototipo.png" alt="Prototype" /></p>
<p>Otros equipos estimaron hacer prototipos físicos mediante cajas, papel, etc., ya que debían simular dispositivos electrónicos que no existen.</p>
<h2 id="da5validar">Día 5. Validar</h2>
<h3 id="guiondeentrevistadevalidacin">Guion de entrevista de validación</h3>
<p>En primer lugar era necesario redactar un guion de entrevista al usuario final, incluyendo cómo se le va a abordar, en caso de ser entrevistas a puerta fría. Una vez más, las entrevistas deben buscar la validación del producto, no su aceptación por parte del usuario.</p>
<ul>
<li>¿Cumple nuestra solución con sus necesidades?</li>
<li>¿Son capaces de usar nuestra interfaz/servicio?</li>
<li>¿Qué le gusta o no le gusta de lo que hemos hecho?</li>
<li>¿Qué le gustaría mejorar?</li>
</ul>
<p>Para ello la metodología buscará:</p>
<ul>
<li>Usar preguntas abiertas en lugar de preguntas dirigidas.</li>
<li>Si existe un prototipo utilizable o clicable, dejar al usuario interactuar con él para ver si lo entiende y encontrar sus bloqueos o frustraciones con respecto a la interacción.</li>
<li>Realizar la mínima explicación de contexto necesaria antes de enfrentar al usuario al prototipo, en lugar de contarle todo, para ver si lo entiende, y evitar condicionarlo.</li>
</ul>
<p>En nuestro caso, no había prototipo clicable ya que se trataba más de un servicio que de la propia aplicación, por lo que optamos por mostrarle la presentación completa y averiguar más tarde qué pensaba de la solución.</p>
<h3 id="entrevistasdevalidacin">Entrevistas de validación</h3>
<p>Para la realización de entrevistas, según sean a puerta fría o previamente concertadas, habrá que salir a la calle o bien usar una sala de entrevistas, o Skype.</p>
<p>El caso ideal consistiría en concertar una serie de entrevistas presenciales con usuarios finales, y disponer de una sala en la que solo una persona hable con él, sin apuntar nada, para poder mantener contacto visual. Desde fuera otras personas observarían la entrevista, incluyendo la pantalla que esté manejando el usuario si es el caso, y apuntarían todo lo que observen de lo que el usuario dice y lo que realmente hace. Idealmente se grabaría todo en vídeo para poder repasarlo posteriormente.</p>
<p>Alternativas a esta situación ideal incluyen realizar la entrevista por Skype y grabarla, o bien que realicen la entrevista de forma presencial 2 o más personas, de las cuales una hablará con el usuario sin perder contacto visual, mientras que otras grabarán en audio/video (si la persona se puede mostrar cohibida puede ser mejor audio, ya que no se percibe cómo te graban) y anotarán los comentarios. El número de entrevistas de validación suficiente es de unas 10, entre las cuales debemos apuntar a nuestro usuario objetivo (persona) al menos en un 80%.</p>
<h3 id="conclusionesdelavalidacinaprendizaje">Conclusiones de la validación. Aprendizaje</h3>
<p>Se reúne de nuevo el equipo y se extraen patrones de las entrevistas. Para ello clasificaremos a los usuarios entrevistados según su perfil y agruparemos las respuestas recibidas. A partir de este aprendizaje sacaremos conclusiones sobre qué partes de la solución pueden funcionar y cuáles no, así como la solución a nivel global.</p>
<ul>
<li>¿Tiene sentido nuestra propuesta para los usuarios?</li>
<li>¿Saben interactuar con ella?</li>
<li>¿La podemos mejorar? ¿Cómo?</li>
<li>¿Seguimos con ella o la descartamos?</li>
</ul>
<h3 id="pitchfinal">Pitch final</h3>
<p>El equipo debía preparar un pitch final para presentar al cliente el prototipo realizado junto con las el aprendizaje obtenido de la validación. Este pitch final debía durar 5 minutos. Se realizó el pitch ante el cliente y se escuchó el feedback por parte de este.</p>
<h2 id="conclusiones">Conclusiones</h2>
<p>La impresión final fue que en un muy breve espacio de tiempo se alcanzó un resultado de gran calidad, donde se puso en juego mucha creatividad y soluciones originales. En varios puntos hubo que dar un golpe de timón, cuando se vio que los supuestos iniciales no eran validados, y se logró hacer sin demasiada resistencia por parte de los autores de dichas ideas iniciales. Aparentemente, las ideas no tenían un único autor y, de alguna manera, todos los miembros del equipo se sentían partícipes y realizaron su aportación, tanto en la generación de ideas como en la toma de decisiones.</p>
<p>Resulta un proceso bastante sorprendente desde dentro, ya que al principio hay una multitud de ideas dispares a las que poco a poco se va poniendo orden y descartando, bajo mucha presión de tiempo, hasta que finalmente todo va convergiendo de una forma que parece natural.</p>
<p>Asimismo, debido a la filosofía de exploración sin censura, las soluciones empiezan siendo muy ambiciosas y poco factibles, pero a medida que avanza el proceso se cancelan algunas ideas, se recombinan con otras o se encuentran soluciones degradadas a las ideas más de ciencia ficción, de modo que la solución final es factible. Esto nos permite llegar a poner en práctica ideas que inicialmente habríamos descartado por parecernos imposibles.</p>]]></description><link>https://juanguijordan.com/blog/2019-05_circular-design-sprint</link><guid isPermaLink="true">https://juanguijordan.com/blog/2019-05_circular-design-sprint</guid><category><![CDATA[design-sprint]]></category><category><![CDATA[ux]]></category><dc:creator><![CDATA[Juangui Jordán]]></dc:creator><pubDate>Tue, 25 Jun 2019 07:00:00 GMT</pubDate></item><item><title><![CDATA[Usando componentes web generados con Stencil en Ionic]]></title><description><![CDATA[<p>Esta publicación tiene como objetivo proporcionar instrucciones claras sobre cómo usar componentes creados y compilados con Stencil en una aplicación Ionic. Te guiaré en el proceso de hacer que un componente web esté disponible en tus templates Ionic, sin necesidad de registrarlos en el registro npm o agregar feos tags script a tu índice.</p>
<h2 id="motivacin">Motivación</h2>
<p>Creado por el <a href="http://ionicframework.com/">equipo de Ionic Framework</a>, uno esperaría que el uso de componentes web Stencil en proyectos Ionic sería, si no automático e integrado en el framework mediante algún comando CLI, al menos bien documentado.</p>
<p>Bueno, ese no es el caso, ya que los chicos de Ionic proporcionan <a href="https://stenciljs.com/docs/framework-integration">instrucciones de integración del framework</a> para Angular, React, Vue y Ember, pero no los proporcionan para Ionic. Tal vez descuidé algo obvio, pero tuve que investigar un poco para que mis componentes Stencil funcionaran en un proyecto Ionic, y el esfuerzo fue lo suficientemente grande como para hacerme pensar en crear una publicación, esperando que pueda ayudar a alguien.</p>
<h2 id="requisitos">Requisitos</h2>
<p>Como requisito, debes crear un componente Stencil, una tarea para la que puedes encontrar la documentación adecuada en el sitio web de Stencil. El componente Stencil tampoco necesita estar registrado en el registro npm.</p>
<h2 id="procesodeintegracin">Proceso de integración</h2>
<p>Si integramos componentes web registrados en npm, el proceso es más sencillo. Afrontemos en esta sección el caso en el que desarrollamos un componente personalizado, pero no lo estamos publicando en el registro npm. Nuestro objetivo es una integración limpia sin etiquetas de script en el archivo <code>index.html</code>.</p>
<p>El proceso consta de tres pasos.</p>
<ul>
<li>Primero construimos el componente y copiamos los archivos de distribución a nuestro proyecto.</li>
<li>Luego le decimos al lado Angular de las cosas cómo usar el componente.</li>
<li>Por último, le decimos al lado Ionic de las cosas que incluya el componente cuando construya el paquete. La forma en que hablamos con Angular (realmente Ionic-Angular) depende de si estamos cargando páginas de forma <em>anticipada</em> o de forma <em>diferida</em>.</li>
</ul>
<h3 id="paso1generarycopiarcomponente">Paso 1. Generar y copiar componente</h3>
<p>Construya el componente y copie el contenido de la carpeta dist a una carpeta en nuestro proyecto. En este ejemplo, elegimos la carpeta <code>@img/lib/components/my-google-maps</code>.</p>
<h3 id="paso2importarenelappmodulets">Paso 2. Importar en el app.module.ts</h3>
<p>Primero, necesitas importar el <code>CUSTOM_ELEMENTS_SCHEMA</code>, y agregarlo a la sección<code>schemas</code> del <code>@NgModule</code>. Si importas <code>CUSTOM_ELEMENTS_SCHEMA</code> en uno de los módulos de tu página, el compilador Angular aceptará elementos que no reconoce (de lo contrario, arrojará un error). Si realizas una carga diferida, debes importar este esquema en cada módulo de página en el que desees utilizar el componente web. Si estás cargando con anticipación, solo necesitas importar el esquema en <code>app.module.ts</code>.</p>
<p>Luego, agrega un import a la carpeta <code>dist/mycomponent</code>. Este import no carga todo el componente web. Solo carga una pequeña parte del código que permite a Ionic cargar el componente web completo más tarde, cuando una plantilla lo solicita.</p>
<p>Cuando hayas realizado ambos pasos, tu <code>app.module.ts</code> debería parecerse al siguiente si estás cargando con anticipación.</p>
<pre><code class="typescript language-typescript">import { CUSTOM_ELEMENTS_SCHEMA } from "@angular/core"; // add this import
import "@img/lib/components/my-google-maps/dist/mycomponent"; // add this import

@NgModule({
  declarations: [],
  imports: [],
  bootstrap: [],
  entryComponents: [],
  providers: [],
  schemas: [CUSTOM_ELEMENTS_SCHEMA], // add this line
})
export class AppModule {}
</code></pre>
<p>Si usas lazy loading, importa solo el componente web en <code>app.module.ts</code>, y solo el esquema en los módulos individuales cargados de forma diferida.</p>
<h3 id="paso3usarionicappscriptsparaincluirelcomponenteenelbuild">Paso 3. Usar ionic-app-scripts para incluir el componente en el build</h3>
<p>Crearemos un archivo <code>copy.config.js</code> que definirá algunas reglas para copiar el componente web a nuestra compilación final. Una buena práctica es crearlo en una carpeta de configuración, para separarlo de otros archivos estándar como <code>package.json</code> o <code>ionic.config.json</code>.</p>
<p>Este archivo puede indicarle a los scripts de aplicaciones Ionic que incluyan contenido adicional cuando compile una aplicación iónica. Si creas el archivo, ponlo en una carpeta llamada <code>config</code> que esté en el mismo nivel de directorio que la carpeta <code>src</code>. En primer lugar, declaremos el archivo en <code>package.json</code>. Esto le dirá a los scripts de la aplicación que usen este archivo. Agrega el siguiente campo a tu <code>package.json</code>:</p>
<pre><code class="json language-json">"config": {
    "ionic_copy": "./config/copy.config.js"
}
</code></pre>
<p>Luego, pon esto dentro de <code>config\copy.config.js</code>:</p>
<pre><code class="javascript language-javascript">module.exports = {
  copyTimeAgoWebComponent: {
    src: [
      "{{ROOT}}/src/img/lib/components/my-google-maps/dist/mycomponent**/*",
    ],
    dest: "{{BUILD}}",
  },
};
</code></pre>
<p>Una vez que hayas realizado esos cambios, los app-scripts sabrán cómo incluir el componente web en sus compilaciones.
Ahora puedes utilizar componentes web Stencil en tus plantillas Ionic como cualquier otro componente web.</p>]]></description><link>https://juanguijordan.com/blog/2018-08_ionic-stencil-integration</link><guid isPermaLink="true">https://juanguijordan.com/blog/2018-08_ionic-stencil-integration</guid><category><![CDATA[javascript]]></category><dc:creator><![CDATA[Juangui Jordán]]></dc:creator><pubDate>Wed, 12 Sep 2018 07:00:00 GMT</pubDate></item><item><title><![CDATA[Versionar características en una aplicación angular]]></title><description><![CDATA[<p>Imagina un escenario en el que tu aplicación debe mostrar diferentes versiones de un componente o servicios a diferentes grupos de usuarios. Si suena un poco traído por los pelos, toma el siguiente escenario que se propuso a nuestro equipo de desarrollo en cierto proyecto real:</p>
<ul>
<li>La aplicación se descarga desde <strong>Google Play/App Store</strong> y se implementará en diferentes países, utilizando el mismo app ID.</li>
<li>Los diferentes países tienen diferentes regulaciones sobre si la aplicación puede mostrar fotografías de usuarios, campos específicos, etc. Además, algunas funciones deberían estar totalmente deshabilitadas en algunos países.</li>
<li>La aplicación seguirá creciendo en funcionalidad, pero no necesariamente al mismo tiempo para todos los países:
algunos países pueden decidir no actualizar alguna función o actualizarla más tarde;
algunos países pueden tomar más tiempo para revisar si alguna característica nueva en particular sigue sus regulaciones de privacidad …</li>
</ul>
<p>El enfoque ingenuo de tener directivas <code>ngIf</code> por todas partes puede funcionar para los casos más simples
pero sería difícil de mantener y también saturaría nuestras hermosas plantillas.
Además, los componentes que utilizan diferentes servicios al cambiar de una versión a otra serían muy difíciles de mantener.</p>
<p>Así que decidimos utilizar el siguiente enfoque para hacer frente a todas esas situaciones:</p>
<ul>
<li>Crear una directiva para mostrar/ocultar partes de una plantilla según el país y la versión.
Eso sería como una extensión de <code>ngIf</code> con nuestros parámetros <code>country</code> y <code>version</code>,
y daría una respuesta a problemas simples como ocultar una funcionalidad completa en algunos países,
u ocultar un campo en particular para algunos países/versiones.</li>
<li>Crear una directiva que devuelva un componente dinámico, según los parámetros <code>country</code> y <code>version</code>.
Esta directiva se utilizaría para casos más generales,
donde una versión de componente puede proporcionar una funcionalidad muy diferente a otra versión.</li>
</ul>
<p>Para ilustrar este post, hemos creado una aplicación. Nuestra aplicación muestra con orgullo algunos datos de países,
como la bandera de un país, el área y la población.
Nos pusimos en contacto con gobiernos de todo el mundo y les pedimos amablemente que se unieran a nuestra revolucionaria aplicación sin fines de lucro. proporcionando algunos datos básicos:</p>
<ul>
<li>Nombre del país</li>
<li>Área</li>
<li>Población</li>
</ul>
<p>Algunos de estos países tienen regulaciones muy severas y querían unirse a la aplicación,
pero sin revelar su área y población inicialmente,
hasta que sus abogados determinen si estos datos podrían mostrarse.
Por eso diseñamos la primera versión de la aplicación con una sola pantalla,
donde el usuario seleccionaría el país de un combo box,
y un componente con dos subcomponentes que muestran los datos del país:</p>
<ul>
<li>Un componente de encabezado para el nombre del país</li>
<li>Un componente de contenido para los datos.</li>
</ul>
<p>El componente de contenido debe ser opcional y se mostrará según las normativas del país.</p>
<p><img src="/img/blog/2018-04_versioning-features-in-an-angular-app/features_v1.png" alt="Diseño de la primera versión de los componentes" /></p>
<p>Estas son algunas capturas de pantalla de la aplicación en este punto:</p>
<p><img src="/img/blog/2018-04_versioning-features-in-an-angular-app/features_v1_screenshots.png" alt="Capturas de pantalla de la primera versión de la aplicación." /></p>
<p>Después de la puesta en marcha, algunos usuarios estaban tan emocionados que empezaron a pedir algunas funcionalidades nuevas:</p>
<ul>
<li>Querían que se mostrara la bandera del país en el encabezado.</li>
<li>Algunos datos más como capital del país y ¿qué más…? el himno nacional, claro.</li>
</ul>
<p>El equipo de desarrollo estuvo de acuerdo en que, dado que algunos países aún no habían proporcionado su área y población,
Era razonable pensar que algunos de ellos no entregarían instantáneamente su bandera, capital e himno.
Así que decidimos versionar el encabezado y los componentes de contenido, de modo que pudiéramos darles un camino sencillo para actualizar sus datos sin dejar de verse bien en la aplicación, mostrando los componentes antiguos en lugar de los componentes nuevos con campos vacíos.</p>
<p><img src="/img/blog/2018-04_versioning-features-in-an-angular-app/features_v2.png" alt="Diseño de la versión final de los componentes" /></p>
<p>Estas son algunas capturas de pantalla de la versión final de la aplicación:</p>
<p><img src="/img/blog/2018-04_versioning-features-in-an-angular-app/features_v2_screenshots.png" alt="Screenshots of the final version of the app" /></p>
<p>Nuestra aplicación se basa en dos directivas, como dijimos.
La primera mostrará/ocultará un elemento dependiendo de la disponibilidad de funciones para un determinado país,
donde las características serán <code>COUNTRY_HEADER</code> y <code>COUNTRY_CONTENT</code>.
Esta directiva obtendrá la disponibilidad de funciones de un servicio, el llamado <code>CountryConfigService</code>.</p>
<pre><code class="typescript language-typescript">import {
  CountryConfigDictionary,
  DEFAULT_COUNTRY_CONFIG,
  FeatureVersionDictionary,
} from "./country-config.model";

@Injectable()
export class CountryConfigService {
  private config: CountryConfigDictionary = DEFAULT_COUNTRY_CONFIG;
  getCountryFeatures(countryCode: string): FeatureVersionDictionary {
    return this.config[countryCode].features;
  }

  isFeatureEnabled(feature: string, countryCode: string): boolean {
    const countryFeatures = this.getCountryFeatures(countryCode);
    return countryFeatures.hasOwnProperty(feature);
  }

  getFeatureVersion(feature: string, countryCode: string): number {
    const countryFeatures = this.getCountryFeatures(countryCode);
    return countryFeatures[feature];
  }
}
</code></pre>
<p>La <code>config</code> es un objeto que sigue un modelo <code>CountryConfigDictionary</code>
que nos permite definir qué versión de los componentes <code>COUNTRY_HEADER</code> y <code>COUNTRY_CONTENT</code>,
si hay alguno, está usando cada país:</p>
<pre><code class="typescript language-typescript">export const DEFAULT_COUNTRY_CONFIG: CountryConfigDictionary = {
  es: {
    features: {
      COUNTRY_HEADER: 2,
      COUNTRY_CONTENT: 2,
    },
  },
  fr: {
    features: {
      COUNTRY_HEADER: 2,
      COUNTRY_CONTENT: 2,
    },
  },
  it: {
    features: {
      COUNTRY_HEADER: 2,
      COUNTRY_CONTENT: 1,
    },
  },
  pt: {
    features: {
      COUNTRY_HEADER: 1,
      COUNTRY_CONTENT: 1,
    },
  },
  uk: {
    features: {
      COUNTRY_HEADER: 1,
    },
  },
};
</code></pre>
<h2 id="ladirectivafeatureif">La directiva FeatureIf</h2>
<p>Con eso en mente, veamos la directiva <code>FeatureIf</code>.
Mostrará un elemento si la función está habilitada para el país.
Opcionalmente, podemos definir la versión mínima implementada por el país,
lo que significa que si el país usa una versión más baja, el elemento estará oculto.
Omitiré los imports estándar para ahorrar espacio en el listado:</p>
<pre><code class="typescript language-typescript">import { CountryConfigService } from "../../services/country-config/country-config.service";

@Directive({
  selector: "[appFeatureIf]",
})
export class FeatureIfDirective implements OnChanges {
  private _featureName: string;
  private _countryCode: string;
  private _minVersion = 0;
  private _else = false;
  private _hasView: boolean;

  @Input() set appFeatureIf(featureName: string) {
    this._featureName = featureName;
  }

  @Input() set appFeatureIfCountryCode(value: string) {
    this._countryCode = value;
  }

  @Input() set appFeatureIfVersion(value: number) {
    this._minVersion = value;
  }

  @Input() set appFeatureIfElse(value: boolean) {
    this._else = value;
  }

  constructor(
    private templateRef: TemplateRef&lt;any&gt;,
    private viewContainerRef: ViewContainerRef,
    private countryConfigService: CountryConfigService
  ) {}

  ngOnChanges(changes: SimpleChanges): void {
    if (changes) {
      this.applyChanges();
    }
  }

  private applyChanges(): void {
    const featureEnabled = this.countryConfigService.isFeatureEnabled(
      this._featureName,
      this._countryCode
    );
    const featureVersion =
      this.countryConfigService.getFeatureVersion(
        this._featureName,
        this._countryCode
      ) || 0;
    const enabled: boolean =
      featureEnabled &amp;&amp; featureVersion &gt;= this._minVersion;
    const displayed: boolean =
      (enabled &amp;&amp; !this._else) || (!enabled &amp;&amp; this._else);
    this.embedTemplate(displayed);
  }

  private embedTemplate(enabled): void {
    if (enabled &amp;&amp; !this._hasView) {
      this.viewContainerRef.createEmbeddedView(this.templateRef);
      this._hasView = true;
    } else if (!enabled &amp;&amp; this._hasView) {
      this.viewContainerRef.clear();
      this._hasView = false;
    }
  }
}
</code></pre>
<p>Esta directiva estructural hace uso de 4 parámetros: <code>featureName</code>, <code>countryCode</code>, <code>featureVersion</code> y <code>else</code>.
Presta atención a cómo definimos las propiedades de entrada en una directiva estructural:</p>
<ul>
<li>La primera entrada toma el nombre de la misma directiva: <code>appFeatureIf</code>.
Usamos un setter para guardarlo internamente como <code>_featureName</code>.</li>
<li>El resto de entradas toman el nombre de la directiva más el nombre del parámetro.
Por ejemplo, la entrada <code>appFeatureIfCountryCode</code> hace referencia al parámetro de directiva <code>countryCode</code>.
También usamos aquí un setter para mapear la entrada a la variable privada <code>_countryCode</code>.</li>
</ul>
<p>Observa a continuación cómo se utiliza la directiva en una plantilla.
El primer parámetro no necesita una clave, mientras que el resto se pasa con tuplas <code>"key: value"</code>, separadas por un punto y coma (<code>;</code>).</p>
<pre><code class="html language-html">&lt;div *appFeatureIf="'COUNTRY_HEADER';countryCode:code;version:2"&gt;
  Show only for countries implementing the COUNTRY_HEADER feature with version
  &gt;= 2
&lt;/div&gt;

&lt;div *appFeatureIf="'COUNTRY_HEADER';countryCode:code;version:2; else:'true'"&gt;
  Show otherwise
&lt;/div&gt;
</code></pre>
<p>Lo que básicamente hace la directiva es:</p>
<ul>
<li>Registra cambios en cualquiera de los inputs.</li>
<li>Cuando se crea una instancia de la directiva o cualquiera de los inputs cambia, ejecuta <code>applyChanges()</code>.</li>
<li>Calcula si la funcionalidad está habilitada de acuerdo con <code>featureName</code>,<code>countryCode</code> y <code>minVersion</code>.</li>
<li>Calcula si el elemento debe mostrarse.
Si el parámetro <code>else</code> está definido y es <code>true</code>, se mostrará si la función está deshabilitada.</li>
<li>Ejecuta <code>embedTemplate()</code>, que crea la vista embebida en el contenedor de la vista si el elemento debe mostrarse,
o borra el contenedor de vista de lo contrario.</li>
</ul>
<p>Usamos esta directiva en dos casos en nuestra aplicación.
En el encabezado, lo usamos para ocultar la bandera de los países que implementan la versión 1 de <code>COUNTRY_HEADER</code>.</p>
<pre><code class="html language-html">&lt;div
  *appFeatureIf="'COUNTRY_HEADER';countryCode:country.code;
  version:2"
  class="flag {{country.code}}"
&gt;&lt;/div&gt;
</code></pre>
<p>En el componente padre, usamos la directiva con el parámetro <code>else</code> a <code>true</code>,
para mostrar un texto informativo cuando el componente de contenido no está disponible.</p>
<pre><code class="html language-html">&lt;div
  class="no-feature"
  *appFeatureIf="'COUNTRY_CONTENT';
  countryCode:country.code;else:'true'"
&gt;
  This feature is not yet available in {{country.name}}.
&lt;/div&gt;
</code></pre>
<h2 id="ladirectivafeatureversion">La directiva FeatureVersion</h2>
<p>Nuestra segunda directiva nos permitirá inyectar dinámicamente un componente u otro, dependiendo de algunos parámetros.</p>
<pre><code class="typescript language-typescript">import { CountryConfigService } from "../../services/country-config/country-config.service";
import { DynamicComponentService } from "../../services/dynamic-component/dynamic-component.service";
import { DynamicComponent } from "../../services/dynamic-component/dynamic-component.model";

@Directive({
  selector: "[appFeatureVersion]",
})
export class FeatureVersionDirective implements OnChanges {
  private _featureName: string;
  private _countryCode: string;
  private _data: any;
  private componentRef: ComponentRef&lt;DynamicComponent&gt;;

  @Input() set appFeatureVersion(featureName: string) {
    this._featureName = featureName;
  }

  @Input()
  set appFeatureVersionCountryCode(value: string) {
    this._countryCode = value;
  }

  @Input()
  set appFeatureVersionData(value: any) {
    this._data = value;
  }

  constructor(
    private viewContainerRef: ViewContainerRef,
    private countryConfigService: CountryConfigService,
    private dynamicComponentService: DynamicComponentService,
    private componentFactoryResolver: ComponentFactoryResolver
  ) {}

  ngOnChanges(changes: SimpleChanges): void {
    if (changes) {
      this.applyChanges();
    }
  }

  private applyChanges(): void {
    const featureEnabled = this.countryConfigService.isFeatureEnabled(
      this._featureName,
      this._countryCode
    );
    const featureVersion =
      this.countryConfigService.getFeatureVersion(
        this._featureName,
        this._countryCode
      ) || 0;
    const dynamicComponent = this.dynamicComponentService.getComponent(
      this._featureName,
      featureVersion
    );
    this.clearViewContainer();
    if (featureEnabled &amp;&amp; dynamicComponent) {
      this.embedComponent(dynamicComponent);
      this.injectComponentData();
    }
  }

  private clearViewContainer(): void {
    this.viewContainerRef.clear();
  }

  private embedComponent(component: Type&lt;DynamicComponent&gt;): void {
    const componentFactory = this.componentFactoryResolver.resolveComponentFactory(
      component
    );
    this.componentRef = this.viewContainerRef.createComponent(componentFactory);
  }

  private injectComponentData(): void {
    this.componentRef.instance.data = this._data;
  }
}
</code></pre>
<p>Esta vez, la directiva toma tres parámetros: <code>featureName</code>, <code>countryCode</code> y <code>data</code>.
El parámetro <code>data</code> se utilizará para pasar datos a nuestro componente dinámico.
Dado que los diferentes componentes pueden tener diferentes entradas,
tomamos el enfoque de recibir cualquier dato externo a través de este objeto <code>data</code>.
Los componentes dinámicos también pueden recibir datos externos a través de servicios, como veremos más adelante.</p>
<p>Entonces, básicamente, lo que hace esta directiva es:</p>
<ul>
<li>Registra cambios en alguna de los inputs.</li>
<li>Cuando se instancia la directiva o cualquiera de los inputs cambia, ejecuta <code>applyChanges()</code>.</li>
<li>Calcula si la función está habilitada según el nombre de la funcionalidad y el código de país.</li>
<li>Obtiene el tipo de componente dinámico para el nombre de la funcionalidad y la versión de <code>DynamicComponentService</code>.</li>
<li>Borra el view container.</li>
<li>Si se recuperó con éxito un tipo de componente dinámico, ejecuta <code>embedTemplate()</code>,
que resuelve una factoría para este tipo de componente y crea la vista embebida en el view container.</li>
<li>Finalmente, inyecta el objeto de datos en el componente instanciado dinámicamente.</li>
</ul>
<p>Veamos el código para esas clases <code>DynamicComponent</code> y <code>DynamicComponentService</code>.</p>
<p>El <code>DynamicComponent</code> es solo una clase con una propiedad pública <code>data</code>.
También crearemos una interfaz de diccionario y una constante con las clases de componentes dinámicos actuales
(versiones de contenido del país 1 y 2) que será utilizado por el servicio.</p>
<pre><code class="typescript language-typescript">import { CountryContentV1Component } from "../../../country/components/country-content/v1/country-content.v1.component";
import { CountryContentV2Component } from "../../../country/components/country-content/v2/country-content.v2.component";

export class DynamicComponent {
  data: any;
}

export interface DynamicComponentDictionary {
  [key: string]: {
    [key: number]: Type&lt;DynamicComponent&gt;;
  };
}

export const DEFAULT_DYNAMIC_COMPONENT_DICTIONARY: DynamicComponentDictionary = {
  COUNTRY_CONTENT: {
    1: CountryContentV1Component,
    2: CountryContentV2Component,
  },
};
</code></pre>
<p><code>DynamicComponentService</code> simplemente devuelve la clase de componente adecuada,
dependiendo de los parámetros <code>featureName</code> y <code>version</code>.</p>
<pre><code class="typescript language-typescript">import {
  DEFAULT_DYNAMIC_COMPONENT_DICTIONARY,
  DynamicComponent,
  DynamicComponentDictionary,
} from "./dynamic-component.model";

@Injectable()
export class DynamicComponentService {
  private componentDictionary: DynamicComponentDictionary = DEFAULT_DYNAMIC_COMPONENT_DICTIONARY;

  getComponent(featureName: string, version: number): Type&lt;DynamicComponent&gt; {
    const selectedComponent = this.componentDictionary[featureName]
      ? this.componentDictionary[featureName][version]
      : undefined;
    return selectedComponent;
  }
}
</code></pre>
<p>Veamos cómo se usa esta directiva en el componente principal.</p>
<pre><code class="html language-html">&lt;ng-template
  *appFeatureVersion="'COUNTRY_CONTENT';
  countryCode:country.code;data:{country: country}"
&gt;
&lt;/ng-template&gt;
</code></pre>
<p>Este es el código de la clase <code>CountryContentV1Component</code>.</p>
<pre><code class="typescript language-typescript">import { DynamicComponent } from "../../../../shared/services/dynamic-component/dynamic-component.model";
import { Country } from "../../../services/country.model";

@Component({
  selector: "app-country-content-v1",
  templateUrl: "./country-content.v1.component.html",
  styleUrls: ["./country-content.v1.component.scss"],
})
export class CountryContentV1Component implements DynamicComponent {
  data: { country: Country };
}
</code></pre>
<p>Y así es como la plantilla usa la propiedad <code>data</code> para mostrar los datos del país.</p>
<pre><code class="html language-html">&lt;div class="country-content"&gt;
  &lt;div class="data-row"&gt;
    &lt;span class="data-label"&gt; Area: &lt;/span&gt;
    &lt;span class="data-value"&gt; {{data.country.area | number}} &lt;/span&gt;
  &lt;/div&gt;
  &lt;div class="data-row"&gt;
    &lt;span class="data-label"&gt; Population: &lt;/span&gt;
    &lt;span class="data-value"&gt; {{data.country.population | number}} &lt;/span&gt;
  &lt;/div&gt;
&lt;/div&gt;
</code></pre>
<p>Puedes ver una demo de la aplicación aquí:<br />
https://stackblitz.com/edit/component-version-demo</p>
<h2 id="serviciosversionados">Servicios versionados</h2>
<p>La situación puede complicarse un poco más si los servicios también están versionados.
Imaginemos que la primera versión del servicio que proporciona datos del país solo incluye el nombre del país,
área y población, y que se debe crear una nueva versión para incluir los nuevos datos,
al mismo tiempo que proporciona la versión anterior para compatibilidad con versiones anteriores.</p>
<p>En este caso podemos inyectar la versión de servicio correspondiente en los componentes versionados.
No usaremos la propiedad <code>data</code> de <code>DynamicComponent</code>, sino que obtendremos los datos del servicio.
También podríamos usar <em>injection tokens</em> para inyectar dinámicamente el servicio versionado dependiendo de ciertas condiciones.</p>
<p>La siguiente demo es un enfoque simple que utiliza servicios versionados:<br />
https://stackblitz.com/edit/component-version-demo-services</p>
<h2 id="consideracionesfinales">Consideraciones finales</h2>
<p>La aplicación de demo probablemente sea demasiado simple para ese tipo de solución.
Podríamos haber usado inteligentemente algunas combinación de <code>ngIf</code> y <code>ngTemplate</code> para llegar a la misma solución.
Pero piensa en un caso en el que el usuario no selecciona el país de un cuadro combinado,
sino que el país se detecta automáticamente desde la configuración de su dispositivo,
y piensa en una interfaz de usuario más complicada con un panel con varios widgets que deberían mostrarse u ocultarse,
o tener contenido diferente según el país, y entonces este enfoque tendrá mucho más sentido.</p>
<p>Este post es lo suficientemente largo para entrar en más detalles.
Si tienes sugerencias para mejorarlo, inclúyelas en tus comentarios :)</p>]]></description><link>https://juanguijordan.com/blog/2018-04_versioning-features-in-an-angular-app</link><guid isPermaLink="true">https://juanguijordan.com/blog/2018-04_versioning-features-in-an-angular-app</guid><category><![CDATA[javascript]]></category><dc:creator><![CDATA[Juangui Jordán]]></dc:creator><pubDate>Tue, 24 Apr 2018 07:00:00 GMT</pubDate></item><item><title><![CDATA[Desplegando un proyecto Angular CLI en Github Pages y Stackblitz]]></title><description><![CDATA[<p>¿Estás ansioso por mostrarle al mundo tu prueba de concepto, proyecto paralelo, idea…?
Esta receta de bash de 5 líneas pondrá tu trabajo en el escaparate en cuestión de segundos.</p>
<p>Así que acabas de terminar de crear el proyecto más genial con <a href="https://cli.angular.io/">Angular CLI</a> y quieres compartirlo con tus colegas, o quizás escribir una publicación al respecto, pero quieres evitarles a tus colegas el dolor de bajarse el código, instalar dependencias y ejecutar la aplicación (lo sé, casi no puede ser más fácil hoy en día) y no tienes un servidor web, o tal vez eres tan vago como tus colegas y no te apetece poner mucho esfuerzo en desplegar el código en algún sitio.</p>
<p>Bien, ¡<a href="https://pages.github.com/">Github Pages</a> al rescate!</p>
<h2 id="githubpages">GitHub Pages</h2>
<p>Voy a asumir que ya creaste el proyecto con Angular CLI, por lo que tu proyecto ya está versionado con git.
Supongamos también que ya tienes una <strong>cuenta de GitHub</strong> con cierto <code>NICKNAME</code>.
Dirígete a GitHub y crea un nuevo proyecto, llamémoslo <code>MY_PROJECT</code>.
No coloques ningún archivo en él, puedes volver más tarde y agregar el <code>README</code> y la licencia deseada,
pero por ahora será más fácil si lo dejas en blanco.</p>
<p>Luego, conecta tu repositorio de git local con el nuevo repositorio remoto y haz push de los cambios:</p>
<pre><code class="bash language-bash">git remote add origin https://github.com/NICKNAME/MY_PROJECT.git
git push origin master
</code></pre>
<p>Ahora, si ya conocíaa GitHub Pages, estarás tentado a activarlas manualmente en el archivo <code>index.html</code> de tu proyecto.
<strong>¡NO HAGAS ESO! ¡¡No funcionará!!</strong></p>
<p>Tu proyecto aún debe ser generado para producción,
lo cual creará una carpeta <code>dist</code> desde la cual podrás servir tus páginas de GitHub, pero <strong>¡NO LO HAGAS! ¡¡¡No funcionará!!!</strong></p>
<p>Parece que GitHub Pages no son adecuadas para SPA, ya que redirigen las rutas de su aplicación a una página 404.
Pero algunos tipos muy majos desarrollaron <a href="https://www.npmjs.com/package/angular-cli-ghpages">angular-cli-ghpages</a>.
Este paquete npm llenará los huecos y hará que tu aplicación funcione en GitHub Pages.</p>
<p>Instálalo con:</p>
<pre><code class="bash language-bash">npm install -g angular-cli-ghpages
</code></pre>
<p>Luego ejecuta estos 2 comandos:</p>
<pre><code class="bash language-bash">ng build --prod --base-href "https://NICKNAME.github.io/MY_PROJECT/"
angular-cli-ghpages
</code></pre>
<p>El segundo comando tiene un montón de opciones, pero todas son opcionales como dice la palabra <code>option</code>,
y no necesitas mucho más para poner en marcha tu aplicación en GitHub Pages. ¡A disfrutar!</p>
<p>Bueno, ciertamente necesitarás la URL de tu aplicación para compartirla con el mundo.
Esta URL es exactamente la que usamos en el comando <code>ng build</code>:<br />
<a href="#">https://NICKNAME.github.io/MY_PROJECT/</a></p>
<h3 id="desplegandoproyectosionic">Desplegando proyectos Ionic</h3>
<p>Actualización: 2018-05-07</p>
<p>¿Qué pasa con los proyectos Ionic?
Se despliegan en <code>www</code> en lugar de la carpeta <code>dist</code>, y usan Ionic CLI en lugar de Angular CLI,
por lo que será necesario realizar un par de cambios.</p>
<pre><code class="bash language-bash">ionic build --prod
</code></pre>
<p>El <code>--base-href</code> no está disponible en Ionic CLI (que yo sepa),
por lo que deberá abrir el archivo <code>index.html</code> y escribir la etiqueta base por tu cuenta, una vez finalizada la compilación.
Puedes ponerlo después de la etiqueta del título, por ejemplo:</p>
<pre><code class="html language-html">&lt;title&gt;Ionic App&lt;/title&gt;
&lt;base href="https://NICKNAME.github.io/MY_PROJECT/" /&gt;
&lt;meta
  name="viewport"
  content="viewport-fit=cover, width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no"
/&gt;
</code></pre>
<p>Ahora, como dije, la salida de la compilación no es la predeterminada para Angular CLI, que sería la carpeta <code>dist</code>.
Usa el flag <code>--dir</code> para especificar la carpeta <code>www</code> como fuente para las páginas de GitHub.</p>
<pre><code class="bash language-bash">angular-cli-ghpages --dir www
</code></pre>
<h2 id="stackblitz">Stackblitz</h2>
<p>Ahora, para la parte de <a href="https://stackblitz.com/">Stackblitz</a> del post… ¿no sería bueno permitir que nuestros colegas o seguidores interactúen realmente con nuestro código y vean el impacto de las modificaciones en casi-tiempo-real?</p>
<p>Los chicos de Stackblitz han creado este tipo de IDE en línea donde puedes crear proyectos y ver la generación al mismo tiempo.
¡Es como <strong>JSfiddler</strong> con esteroides!</p>
<p><img src="/img/blog/2018-03_angular-cli-github-pages-stackblitz/stackblitz.png" alt="Stackblitz" /></p>
<p>Aún más simple que registrarte en Stackblitz, crear un proyecto y cargar los archivos de tu proyecto,
este truco de una línea cargará tu proyecto de GitHub en el IDE de Stackblitz.</p>
<p>Simplemente comparte esta URL, usando nuevamente tu apodo de GitHub y el nombre del proyecto:<br />
<a href="#">https://stackblitz.com/github/NICKNAME/MY_PROJECT</a></p>
<p>Esto también es válido para ramas, etiquetas o commits específicos. Simplemente use el siguiente esquema para la URL:<br />
<a href="#">https://stackblitz.com/github/NICKNAME/MY_PROJECT/tree/{TAG|BRANCH|COMMIT}</a></p>
<p>Espero que esta publicación te haya ayudado a publicar tus proyectos en un lugar donde otros puedan verlos, disfrutarlos y editarlos.</p>]]></description><link>https://juanguijordan.com/blog/2018-03_angular-cli-github-pages-stackblitz</link><guid isPermaLink="true">https://juanguijordan.com/blog/2018-03_angular-cli-github-pages-stackblitz</guid><category><![CDATA[javascript]]></category><dc:creator><![CDATA[Juangui Jordán]]></dc:creator><pubDate>Mon, 26 Mar 2018 07:00:00 GMT</pubDate></item></channel></rss>